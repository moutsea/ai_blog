<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/l.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/l.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.ailinghang.club","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="人工智能从零入门教程">
<meta property="og:type" content="website">
<meta property="og:title" content="Ai领航员">
<meta property="og:url" content="http://www.ailinghang.club/index.html">
<meta property="og:site_name" content="Ai领航员">
<meta property="og:description" content="人工智能从零入门教程">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ai领航员">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.ailinghang.club/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ai领航员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    	<a target="_blank" rel="noopener" href="https://github.com/moutsea/ai_tutorial" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ai领航员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-planet">

    <a href="/planet/" rel="section"><i class="fa fa-compass fa-fw"></i>知识星球</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/python-args/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/python-args/" class="post-title-link" itemprop="url">Python使用argparse解析命令行参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 09:55:00 / 修改时间：10:00:39" itemprop="dateCreated datePublished" datetime="2023-04-18T09:55:00+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是Python系列最后一篇文章，我们来聊聊Python当中的命令行参数工具argparse。</p>
<p>命令行参数工具是我们非常常用的工具，比如当我们做实验希望调节参数的时候，如果参数都是通过硬编码写在代码当中的话，我们每次修改参数都需要修改对应的代码和逻辑显然这不太方便。比较好的办法就是把必要的参数设置成<strong>通过命令行传入</strong>的形式，这样我们只需要在运行的时候修改参数就可以了。</p>
<h2 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h2><p>解析命令行传入参数最简单的办法就是通过<strong>sys.argv</strong>，<code>sys.argv</code>可以获取到我们通过命令行传入的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br></pre></td></tr></table></figure>
<p>用法很简单，只需要调用<code>sys.argv</code>即可。<code>argv</code>是一个数组，如果参数有多个，我们可以通过下标进行访问。但是有一点需要注意，<code>argv</code>当中存储的结果是从Python调用开始的。</p>
<p>我们来看一个例子，我们随意传入一些参数，<code>print sys.argv</code>之后是这样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python test.py -a -c -d=<span class="number">222</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;test.py&#x27;</span>, <span class="string">&#x27;-a&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;-d=222&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>也就是说我们python运行test.py这个<strong>文件名也当做参数之一</strong>，所以我们要获取自定义参数的话需要从<code>argv[1]</code>开始。</p>
<p><code>sys.argv</code>的好处是方便，我们只需要访问它就可以拿到传入的参数了。但是缺点也很明显，就是功能太少了。假如我们是看其他大神的代码，我们想要知道运行的时候需要传入什么参数，以及每个参数代表什么含义就做不到了。</p>
<p>为了解决这个问题，我们需要使用封装更多功能的工具，也是本篇文章的核心——<strong>argparse</strong>。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>argparse</code>是Python当中的一个库，我们需要先<code>import</code>一下，这个库我没记错应该是Python自带的，也不需要安装，我们直接就可以使用。</p>
<p>在我们使用之前，我们需要先初始化这个parse，也就是一个参数解析器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里ArgumentParser可以传入一个字符串，表示用途</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure>
<p>这个时候其实就已经有了一个解析器了，我们在运行的时候可以传入参数<code>-h</code>，表示help，也就是查看目前解析器当中定义的参数。由于我们现在什么也没有，所以能显示出来的就只有help。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtim589a2j318w052js7.jpg" alt=""></p>
<h2 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h2><p>首先我们来介绍<strong>必选参数</strong>，它的定义和函数当中的必填参数是一样的，也就是说我们运行程序必须要的参数。如果不传，那么程序不应该执行会进行报错并提示。</p>
<p>定义必选参数的方法非常简单，我们只需要通过<code>add_argument</code>传入参数的名称就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(<span class="string">&quot;For test the parser&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.test)</span><br></pre></td></tr></table></figure>
<p>这样我们就定义了一个名叫<code>test</code>的参数，我们可以通过<code>args.test</code>来访问它。</p>
<p>这个时候我们再运行<code>python test.py -h</code>就会发现提示的信息当中多了一行：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtiu7gumxj318e086q41.jpg" alt=""></p>
<p>告诉我们必选参数当中有test，<strong>必选参数直接传入，不需要加上前缀</strong>。所以我们执行的时候直接<code>python test.py xxx</code>就可以了。</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有必选参数当然就有可选参数，可选参数由于可选可不选， 所以我们在使用的时候需要在参数前加上标识-或者—。比如我们参数名叫做test，可以定义成<code>-test</code>或者<code>--test</code>，这两种都可以，也可以这两种都定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们运行<code>-h</code>可以发现<code>optional arguments</code>当中多了<code>test</code>和<code>--test</code>。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtj00hkhfj3184060my4.jpg" alt=""></p>
<p>但是这个只print出来了参数名，并没有告诉我们这个参数究竟是做什么的，像是help参数后面就跟了show this help message and exit这个提示语。如果我们也希望help能够提示我们参数的作用怎么办呢？</p>
<p>我们可以通过help参数传入我们希望打印出来的提示语，这样方便使用者在使用的时候了解参数的情况。</p>
<p>比如我们把这行语句改成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这样当我们运行的时候，就会看到提示语了：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtj2bewz8j31bc076t9t.jpg" alt=""></p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果参数很多的时候，我们有时候可能不希望每一个都指定一个值，而是希望可以在不填的时候有一个默认值。这个想法非常正常，想要做到这点也很简单，我们可以通过<strong>default参数</strong>来指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(<span class="string">&quot;For test the parser&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.test)</span><br></pre></td></tr></table></figure>
<p>比如这样我们在代码当中把test参数的默认值设置成了1，当我们运行的时候，如果不填test这个参数的话，那么程序就会使用它的默认值也就是1。</p>
<p>但有一点<strong>默认值的信息并不会print在help当中</strong>，所以我们需要自己在提示语当中告知使用者默认值是多少。</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>我们可以定义参数的默认值，当然也可以定义它的类型。</p>
<p>因为<strong>命令行传入的参数默认都是字符串</strong>，如果我们要进行数学上的计算，使用<code>str</code>还需要自己转换，这就很不方便。我们可以在传入参数的时候就完成类型的匹配，这样如果传入参数的类型不对， 那么直接报错，不往下运行。</p>
<p>想要做到这点也很简单，通过<code>type</code>参数就可以实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>比如当我们定义了一个<code>int</code>型的参数，而传入的是类型不匹配的话，那么就会引起报错：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtjk48uj6j31bo03c3za.jpg" alt=""></p>
<p>报错信息当中写得很清楚，我们得到了一个无效的<code>int</code>的值，它是abc。</p>
<h2 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h2><p>它同样还支持可选值，可选值很好理解，就是我们希望<strong>限定传入参数的范围仅仅在几个值当中</strong>。比如说我们希望传入的值不是0就是1，或者是在某几个具体的值当中，这个时候我们可以通过<code>choices</code>参数来实现这一点。</p>
<p><code>choices</code>参数传入的是一个list，也就是我们的限定范围，只有在这个范围当中的值才被允许。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, choices=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们运行传入<code>test=1</code>，那么就会引起报错，告诉我们传入的值不在<code>choices</code>范围当中。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtjpcsyrij317g02y0tj.jpg" alt=""></p>
<p>这是一个挺有意思的例子，仔细看会发现我们默认值设置成了1，但是可选值当中并没有1。这也是允许的，<strong>默认值可以不在可选值范围内</strong>，但是当我们传入1就会触发可选值校验。</p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p><code>action</code>是一个很神奇也很有用的操作，可以<strong>指定参数的处理方式</strong>。我们默认的方式是store，也就是存储的意思，这个我们都能理解。除此之外，还有<code>store_true</code>，它表示出现则是true，否则是false。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>当我们把test参数的定义改成这样之后，我们来对比一下运行的结果就明白了。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtq5deajdj31bs0443zf.jpg" alt=""></p>
<p>除了<code>store_true</code>之外还有<code>store_const</code>，也就是说出现就指定为一个固定值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>, const=<span class="number">23</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这样当我们指定<code>-test</code>参数之后，它会自动被赋值成23。</p>
<p>除了这两个之外，另外一个很常用的参数是<strong>append</strong>，可以将多次出现的同一个参数自动存入一个list当中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;append&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtl70htzwj31be01w74n.jpg" alt=""></p>
<h2 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h2><p><code>nargs</code>也是一个非常有用的参数，可以对参数进行一些花式操作。nargs的传入参数有以下几种，首先是N，也就是一个整数。代表可以<strong>接收N个参数值</strong>，这N个值会被存入一个list当中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, nargs=<span class="number">2</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>另外一种传入的参数是<code>&#39;+&#39;</code>或者是<code>&#39;*&#39;</code>，它可以将任意多个值存入一个list当中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, nargs=<span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtlno7hoej31cg01umxk.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了parser之后，我们在Python当中处理命令行参数会变得非常简单，我们可以做各种各样的定制化操作。除了我们上面介绍的之外，还有一些其他的做法，相对来说不是非常常用，所以就不一一穷尽了，感兴趣的同学可以自行了解一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/python-routine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/python-routine/" class="post-title-link" itemprop="url">详解Python中协程的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 09:32:04 / 修改时间：09:38:31" itemprop="dateCreated datePublished" datetime="2023-04-18T09:32:04+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章我们来聊聊Python当中的协程。</p>
<p>我们曾经在golang关于<code>goroutine</code>的文章当中简单介绍过<strong>协程</strong>的概念，我们再来简单review一下。协程又称为是微线程，英文名是<code>Coroutine</code>。它和线程一样可以调度，但是不同的是线程的启动和调度需要通过操作系统来处理。并且线程的启动和销毁需要涉及一些操作系统的变量申请和销毁处理，需要的时间比较长。而协程呢，它的<strong>调度和销毁都是程序自己来控制</strong>的，因此它更加轻量级也更加灵活。</p>
<p>协程有这么多优点，自然也会有一些缺点，其中最大的缺点就是<strong>需要编程语言自己支持</strong>，否则的话需要开发者自己通过一些方法来实现协程。对于大部分语言来说，都不支持这一机制。go语言由于天然支持协程，并且支持得非常好，使得它广受好评，短短几年时间就迅速流行起来。</p>
<p>对于Python来说，本身就有着一个GIL这个巨大的先天问题。GIL是Python的全局锁，在它的限制下<strong>一个Python进程同一时间只能同时执行一个线程</strong>，即使是在多核心的机器当中。这就大大影响了Python的性能，尤其是在CPU密集型的工作上。所以为了提升Python的性能，很多开发者想出了使用多进程+协程的方式。一开始是开发者自行实现的，后来在Python3.4的版本当中，官方也收入了这个功能，因此目前可以光明正大地说，Python是支持协程的语言了。</p>
<h2 id="生成器（generator"><a href="#生成器（generator" class="headerlink" title="生成器（generator)"></a>生成器（generator)</h2><p>生成器我们也在之前的文章当中介绍过，为什么我们介绍协程需要用到生成器呢，是因为Python的<strong>协程底层就是通过生成器来实现的</strong>。</p>
<p>通过生成器来实现协程的原因也很简单，我们都知道协程需要切换挂起，而生成器当中有一个<strong>yield关键字</strong>，刚好可以实现这个功能。所以当初那些自己在Python当中开发协程功能的程序员都是通过生成器来实现的，我们想要理解Python当中协程的运用，就必须从最原始的生成器开始。</p>
<p>生成器我们很熟悉了，本质上就是带有yield这个关键词的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">        val = <span class="keyword">yield</span> n </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;val = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(val))</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这个函数当中如果没有<code>yield</code>这个语句，那么它就是一个普通的Python函数。加上了<code>val = yield n</code>这个语句之后，它有什么变化呢？</p>
<p>我们尝试着运行一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用test函数获得一个生成器</span></span><br><span class="line">g = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure>
<p>得到这么一个结果：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghlitiji1mj30hj0340sr.jpg" alt="image-20200810104610713"></p>
<p>输出的0，1，2很好理解，就是通过next(g)返回的，这个也是生成器的标准用法。奇怪的是为什么<code>val=None</code>呢？val不应该等于n么？</p>
<p>这里想不明白是正常的，因为这里涉及到了一个新的用法就是<strong>生成器的send方法</strong>。当我们在<code>yield</code>语句之前加上变量名的时候，它的含义其实是返回<code>yield</code>之后的内容，再从外界接收一个变量。也就是说当我们执行<code>next(g)</code>的时候，会从获取<code>yield</code>之后的数，当我们执行<code>g.send()</code>时，传入的值会被赋值给<code>yield</code>之前的数。比如我们把执行的代码改成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">g.send(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure>
<p>我们再来看执行的结果，会发现是这样的：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghliwy0798j30ii03iwel.jpg" alt=""></p>
<p>第一行<code>val</code>不再是<code>None</code>，而是我们刚刚传入的abc了。</p>
<h2 id="队列调度"><a href="#队列调度" class="headerlink" title="队列调度"></a>队列调度</h2><p>生成器每次在执行到<code>yield</code>语句之后都会自然挂起，我们可以利用这一点来当做协程来调度。我们可以自己实现一个简易的队列来模拟这个过程。</p>
<p>首先我们声明一个双端队列，<strong>每次从队列左边头部获取任务，调度执行到挂起之后，放入到队列末尾</strong>。相当于我们用循环的方式轮询执行了所有任务，并且这整个全程不涉及任何线程创建和销毁的过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_task</span>(<span class="params">self, task</span>):</span><br><span class="line">        self._queue.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> self._queue:</span><br><span class="line">            <span class="comment"># 每次从队列左侧获取task</span></span><br><span class="line">            task = self._queue.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 通过next执行之后放入队列右侧</span></span><br><span class="line">                <span class="built_in">next</span>(task)</span><br><span class="line">                self._queue.append(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sch = Scheduler()</span><br><span class="line">sch.new_task(test(<span class="number">5</span>))</span><br><span class="line">sch.new_task(test(<span class="number">10</span>))</span><br><span class="line">sch.new_task(test(<span class="number">8</span>))</span><br><span class="line">sch.run()</span><br></pre></td></tr></table></figure>
<p>这个只是一个很简易的调度方法，事实上结合上<code>yield from</code>以及<code>send</code>功能，我们还可以实现出更加复杂的协程调度方式。但是我们也没有必要一一穷尽，只需要理解最基础的方法就可以了，毕竟现在我们使用协程一般也不会自己实现了，都会通过官方原生的工具库来实现。</p>
<h2 id="asyncio-coroutine"><a href="#asyncio-coroutine" class="headerlink" title="@asyncio.coroutine"></a>@asyncio.coroutine</h2><p>在Python3.4之后的版本当中，我们可以通过<code>@asyncio.coroutine</code>这个注解来将一个函数封装成协程执行的生成器。</p>
<p>在吸收了协程这个概念之后，Python<strong>对生成器以及协程做了区分</strong>。加上了<code>@asyncio.coroutine</code>注解的函数称为<strong>协程函数</strong>，我们可以用<code>iscoroutinefunction()</code>方法来判断一个函数是不是协程函数，通过这个协程函数返回的生成器对象称为<strong>协程对象</strong>，我们可以通过<code>iscoroutine</code>方法来判断一个对象是不是协程对象。</p>
<p>比如我把刚刚写的函数上加上注解之后再来执行这两个函数都会得到<code>True</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(asyncio.iscoroutinefunction(test))</span><br><span class="line"><span class="built_in">print</span>(asyncio.iscoroutine(test(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>那我们通过注解将方法转变成了协程之后，又该怎么使用呢？</p>
<p>一个比较好的方式是<strong>通过<code>asynio</code>库当中提供的<code>loop</code>工具</strong>，比如我们来看这么一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(test(<span class="number">10</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>我们通过<code>asyncio.get_event_loop</code>函数创建了一个调度器，通过调度器的run相关的方法来执行一个协程对象。我们可以<code>run_until_complete</code>也可以<code>run_forever</code>，具体怎么执行要看我们实际的使用场景。</p>
<h2 id="async，await和future"><a href="#async，await和future" class="headerlink" title="async，await和future"></a>async，await和future</h2><p>从Python3.5版本开始，引入了<code>async，await</code>和<code>future</code>。我们来简单说说它们各自的用途，其中<code>async</code>其实就是<code>@asyncio.coroutine</code>，用途是完全一样的。同样<code>await</code>代替的是<code>yield from</code>，意为等待另外一个协程结束。</p>
<p>我们用这两个一改，上面的代码就成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>由于我们加上了<code>await</code>，所以每次在打印之前都会等待0.5秒。我们<strong>把<code>await</code>换成<code>yield from</code>也是一样的</strong>，只不过用<code>await</code>更加直观也更加贴合协程的含义。</p>
<p><code>Future</code>其实可以看成是一个信号量，我们创建一个全局的future，当一个协程执行完成之后，将结果存入这个future当中。<strong>其他的协程可以<code>await future</code>来实现阻塞</strong>。我们来看一个例子就明白了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">future = asyncio.Future()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    future.set_result(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log</span>():</span><br><span class="line">    result = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait([</span><br><span class="line">    log(),</span><br><span class="line">    test(<span class="number">5</span>)</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>在这个例子当中我们创建了两个协程，第一个协程是每隔0.5秒<code>print</code>一个数字，在<code>print</code>完成之后把success写入到<code>future</code>当中。第二个协程就是等待future当中的数据，之后print出来。</p>
<p>在loop当中我们要调度执行的不在是一个协程对象了而是两个，所以我们<strong>用<code>asyncio</code>当中的<code>wait</code>将这两个对象包起来</strong>。只有当wait当中的两个对象执行结束，wait才会结束。loop等待的是wait的结束，而wait等待的是传入其中的协程的结束，这就形成了一个依赖循环，等价于这两个协程对象结束，loop才会结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>async</code><strong>并不止是可以用在函数上</strong>，事实上还有很多其他的用法，比如用在with语句上，用在for循环上等等。这些用法比较小众，细节也很多，就不一一展开了，大家感兴趣的可以自行去了解一下。</p>
<p>不知道大家在读这篇文章的过程当中有没有觉得有些费劲，如果有的话，其实是很正常的。原因也很简单，因为Python原生是不支持协程这个概念的，所以在一开始设计的时候也没有做这方面的准备，是后来觉得有必要才加入的。那么作为后面加入的内容，必然会对原先的很多内容产生影响，尤其是协程借助了之前生成器的概念来实现的，那么必然会有很多耦合不清楚的情况。这也是这一块的语法很乱，对初学者不友好的原因。</p>
<p>我建议大家可以<strong>先了解一下go语言当中的协程的概念和用法</strong>再来学习Python当中的async的用法，很多不明白的地方会清晰很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/multi-thread-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/multi-thread-4/" class="post-title-link" itemprop="url">Python中死锁问题巧妙解决办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 09:18:03 / 修改时间：09:21:19" itemprop="dateCreated datePublished" datetime="2023-04-18T09:18:03+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章，我们一起来聊聊多线程开发当中死锁的问题。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的原理非常简单，用一句话就可以描述完。就是当多线程访问多个锁的时候，<strong>不同的锁被不同的线程持有</strong>，它们都在等待其他线程释放出锁来，于是便陷入了永久等待。比如A线程持有1号锁，等待2号锁，B线程持有2号锁等待1号锁，那么它们永远也等不到执行的那天，这种情况就叫做死锁。</p>
<p>关于死锁有一个著名的问题叫做<strong>哲学家就餐</strong>问题，有5个哲学家围坐在一起，他们每个人需要拿到两个叉子才可以吃饭。如果他们同时拿起自己左手边的叉子，那么就会永远等待右手边的叉子释放出来。这样就陷入了永久等待，于是这些哲学家都会饿死。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghdbrswecrj30sg0tie4y.jpg" alt="img"></p>
<p>这是一个很形象的模型，因为在计算机并发场景当中，一些<strong>资源的数量往往是有限的</strong>。很有可能出现多个线程抢占的情况，如果处理不好就会发生大家都获取了一部分资源，然后在等待另外的资源的情况。</p>
<p>对于死锁的问题有多种解决方法，这里我们介绍比较简单的一种，就是对这些锁进行编号。我们规定当一个线程需要同时持有多个锁的时候，<strong>必须要按照序号升序的顺序对这些锁进行访问</strong>。通过上下文管理器我们可以很容易实现这一点。</p>
<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>首先我们来简单介绍一下上下文管理器，上下文管理器我们其实经常使用，比如我们经常使用的<strong>with语句</strong>就是一个上下文管理器的经典使用。当我们通过<code>with</code>语句打开文件的时候，它会自动替我们处理好文件读取之后的关闭以及抛出异常的处理，可以节约我们大量的代码。</p>
<p>同样我们也可以自己定义一个上下文处理器，其实很简单，我们只需要实现<code>__enter__</code>和<code>__exit__</code>这两个函数即可。<code>__enter__</code>函数用来实现进入资源之前的操作和处理，那么显然<code>__exit__</code>函数对应的就是使用资源结束之后或者是出现异常的处理逻辑。有了这两个函数之后，我们就有了自己的上下文处理类了。</p>
<p>我们来看一个样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter resources&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(exc_type)</span></span><br><span class="line">        <span class="comment"># print(exc_val)</span></span><br><span class="line">        <span class="comment"># print(exc_tb)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doSomething</span>(<span class="params">self</span>):</span><br><span class="line">        a = <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSample</span>():</span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> getSample() <span class="keyword">as</span> sample:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>)</span><br><span class="line">        sample.doSomething()</span><br></pre></td></tr></table></figure>
<p>当我们运行这段代码的时候，屏幕上打印的结果和我们的预期是一致的。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghdcveh1o3j30mr025aa5.jpg" alt="image-20200803091558632"></p>
<p>我们观察一下<code>__exit__</code>函数，会发现它的参数有4个，<strong>后面的三个参数对应的是抛出异常的情况</strong>。<code>type</code>对应异常的类型，<code>val</code>对应异常时的输出值，<code>trace</code>对应异常抛出时的运行堆栈。这些信息都是我们排查异常的时候经常需要用到的信息，通过这三个字段，我们可以根据我们的需要对可能出现的异常进行自定义的处理。</p>
<p>实现上下文管理器并不一定要通过类实现，Python当中也提供了上下文管理的注解，通过使用注解我们可以很方便地实现上下文管理。我们同样也来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timethis</span>(<span class="params">label</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(label, end - start))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> timethis(<span class="string">&#x27;timer&#x27;</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在这个方法当中yield之前的部分相当于<code>__enter__</code>函数，<code>yield</code>之后的部分相当于<code>__exit__</code>。如果出现异常会在try语句当中抛出，那么我们编写except对异常进行处理即可。</p>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>了解了上下文管理器之后，我们要做的就是<strong>在lock的外面包装一层</strong>，使得我们在获取和释放锁的时候可以根据我们的需要，对锁进行排序，按照升序的顺序进行持有。</p>
<p>这段代码源于Python的著名进阶书籍《Python cookbook》，非常经典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储local的数据</span></span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire</span>(<span class="params">*locks</span>):</span><br><span class="line">	<span class="comment"># 对锁按照id进行排序</span></span><br><span class="line">    locks = <span class="built_in">sorted</span>(locks, key=<span class="keyword">lambda</span> x: <span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果已经持有锁当中的序号有比当前更大的，说明策略失败</span></span><br><span class="line">    acquired = <span class="built_in">getattr</span>(_local,<span class="string">&#x27;acquired&#x27;</span>,[])</span><br><span class="line">    <span class="keyword">if</span> acquired <span class="keyword">and</span> <span class="built_in">max</span>(<span class="built_in">id</span>(lock) <span class="keyword">for</span> lock <span class="keyword">in</span> acquired) &gt;= <span class="built_in">id</span>(locks[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Lock Order Violation&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有锁</span></span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 倒叙释放</span></span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> <span class="built_in">reversed</span>(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">del</span> acquired[-<span class="built_in">len</span>(locks):]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码写得非常漂亮，可读性很高，逻辑我们都应该能看懂，但是有一个小问题是这里用到了<strong><code>threading.local</code></strong>这个组件。</p>
<p>它是一个多线程场景当中的<strong>共享变量</strong>，虽然说是共享的，但是对于每个线程来说读取到的值都是独立的。听起来有些难以理解，其实我们可以将它理解成一个<code>dict</code>，<code>dict</code>的key是每一个线程的id，value是一个存储数据的dict。每个线程在访问local变量的时候，都相当于先通过线程id获取了一个独立的dict，再对这个dict进行的操作。</p>
<p>看起来我们在使用的时候直接使用了<code>_local</code>，这是因为通过线程id先进行查询的步骤在其中封装了。不明就里的话可能会觉得有些难以理解。</p>
<p>我们再来看下这个acquire的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(x_lock, y_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(y_lock, x_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p>运行一下会发现没有出现死锁的情况，但如果我们把代码稍加调整，写成这样，那么就会触发异常了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">thread_1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">            <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">	            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">            <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">	            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>因为我们把锁写成了层次结构，这样就没办法进行排序保证持有的有序性了，那么就会触发我们代码当中定义的异常。</p>
<p>最后我们再来看下哲学家就餐问题，通过我们自己实现的acquire函数我们可以非常方便地解决他们死锁吃不了饭的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">philosopher</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(left, right):</span><br><span class="line">             <span class="built_in">print</span>(threading.currentThread(), <span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叉子的数量</span></span><br><span class="line">NSTICKS = <span class="number">5</span></span><br><span class="line">chopsticks = [threading.Lock() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(NSTICKS)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(NSTICKS):</span><br><span class="line">    t = threading.Thread(target=philosopher,</span><br><span class="line">                         args=(chopsticks[n],chopsticks[(n+<span class="number">1</span>) % NSTICKS]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于死锁的问题，对锁进行排序<strong>只是其中的一种解决方案</strong>，除此之外还有很多解决死锁的模型。比如我们可以让线程在尝试持有新的锁失败的时候主动放弃所有目前已经持有的锁，比如我们可以设置机制检测死锁的发生并对其进行处理等等。发散出去其实有很多种方法，这些方法起作用的原理各不相同，其中涉及大量操作系统的基础概念和知识，感兴趣的同学可以深入研究一下这个部分，一定会对操作系统以及锁的使用有一个深刻的认识。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/multi-thread-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/multi-thread-3/" class="post-title-link" itemprop="url">Python中并发与锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 09:08:37 / 修改时间：09:17:29" itemprop="dateCreated datePublished" datetime="2023-04-18T09:08:37+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇我们一起来聊聊多线程场景当中不可或缺的另外一个部分——<strong>锁</strong>。</p>
<p>如果你学过操作系统，那么对于锁应该不陌生。锁的含义是线程锁，可以用来指定某一个逻辑或者是资源<strong>同一时刻只能有一个线程访问</strong>。这个很好理解，就好像是有一个房间被一把锁锁住了，只有拿到钥匙的人才能进入。每一个人从房间门口拿到钥匙进入房间，出房间的时候会把钥匙再放回到门口。这样下一个到门口的人就可以拿到钥匙了。这里的房间就是某一个资源或者是一段逻辑，而拿取钥匙的人其实指的是一个线程。</p>
<h2 id="加锁的原因"><a href="#加锁的原因" class="headerlink" title="加锁的原因"></a>加锁的原因</h2><p>我们明白了锁的原理，不禁有了一个问题，我们为什么需要锁呢，它在哪些场景当中会用到呢？</p>
<p>其实它的使用场景非常广，我们举一个非常简单的例子，就是淘宝买东西。我们都知道商家的库存都是有限的，卖掉一个少一个。假如说当前某个商品库存只剩下一个，但当下却有两个人同时购买。两个人同时购买也就是有两个请求同时发起购买请求，如果我们不加锁的话，两个线程同时查询到商品的库存是1，大于0，进行购买逻辑之后，减一。由于两个线程同时执行，所以最后商品的库存会变成-1。</p>
<p>显然商品的库存不应该是一个负数，所以我们需要避免这种情况发生。通过<strong>加锁</strong>可以完美解决这个问题。我们规定一次只能有一个线程发起购买的请求，那么这样当一个线程将库存减到0的时候，第二个请求就无法修改了，就保证了数据的准确性。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>那么在Python当中，我们怎么样来实现这个锁呢？</p>
<p>其实很简单，<code>threading</code>库当中已经为我们提供了现成的工具，我们直接拿过来用就可以了。我们通过使用<code>threading</code>当中的<code>Lock</code>对象， 可以很轻易的实现方法加锁的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       	加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        self._value += delta</span><br><span class="line">        self._lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        self._value -= delta</span><br><span class="line">        self._lock.release()</span><br></pre></td></tr></table></figure>
<p>我们从代码当中就可以很轻易的看出<code>Lock</code>这个对象的使用方法，我们在进入<strong>加锁区</strong>（资源抢占区）之前，我们需要先使用<code>lock.acquire()</code>方法获取锁。<code>Lock</code>对象可以保证同一时刻只能有一个线程获取锁，只有获取了锁之后才会继续往下执行。当我们执行完成之后，我们需要把锁“放回门口”，所以需要再调用一下<code>release</code>方法，表示锁的释放。</p>
<p>这里有一个小问题是很多程序员在编程的时候总是会<strong>忘记<code>release</code>，导致不必要的bug</strong>，而且这种分布式场景当中的bug很难通过测试发现。因为测试的时候往往很难测试并发场景，code review的时候也很容易忽略，因此一旦泄露了还是挺难发现的。</p>
<p>为了解决这个问题，<code>Lock</code>还提供了一种改进的用法，就是<strong>使用with语句</strong>。with语句我们之前在使用文件的时候用到过，使用with可以替我们完成try catch以及资源回收等工作，我们只管用就完事了。这里也是一样，使用<code>with</code>之后我们就可以不用管锁的申请和释放了，直接写代码就行，所以上面的代码可以改写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       	加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">with</span> self._lock:</span><br><span class="line">	        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">	        self._value -= delta</span><br></pre></td></tr></table></figure>
<p>这样看起来是不是清爽很多？</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>上面介绍的只是最简单的锁，我们经常使用的往往是<strong>可重入锁</strong>。</p>
<p>什么叫可重入锁呢？简单解释一下，就是在一个线程已经持有了锁的情况下，它可以再次进入被加锁的区域。但是既然线程还持有锁没有释放，那么它不应该还是在加锁区域吗，怎么会有需要再次进入被加锁区域的情况呢？其实是有的，<strong>道理也很简单，就是递归</strong>。</p>
<p>我们把上面的例子稍微改一点点，就完全不一样了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       	加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">with</span> self._lock:</span><br><span class="line">	        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">	        self.incr(-delta)</span><br></pre></td></tr></table></figure>
<p>我们关注一下上面的<code>decr</code>方法，我们用<code>incr</code>来代替了原本的逻辑实现了<code>decr</code>。但是有一个问题是decr也是一个加锁的方法，需要前一个锁释放了才能进入。但它已经持有了锁了，那么这种情况下就会发生<strong>死锁</strong>。</p>
<p>我们只需要把Lock换成可重入锁就可以解决这个问题，只需要修改一行代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    我们使用RLock代替了Lock，也可重入锁代替了普通锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       	加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">with</span> self._lock:</span><br><span class="line">	        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">	        self.incr(-delta)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们的文章介绍了Python当中锁的使用方法，以及可重入锁的概念。在并发场景下开发和调试都是一个比较困难的工作，稍微不小心就会踩到各种各样的坑，<strong>死锁只是其中一种比较常见并且比较容易解决的问题</strong>，除此之外还有很多其他各种各样的问题。</p>
<p>针对死锁的问题，Python还提供了其他的解决方案，我们放到下一篇文章当中再和大家分享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/multi-thread-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/multi-thread-2/" class="post-title-link" itemprop="url">Python中生产者、消费者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 09:02:09 / 修改时间：09:08:05" itemprop="dateCreated datePublished" datetime="2023-04-18T09:02:09+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章，我们来聊聊关于多线程的一个经典<strong>设计模式</strong>。</p>
<p>在之前的文章当中我们曾经说道，在多线程并发的场景当中，如果我们需要感知线程之间的状态，交换线程之间的信息是一件非常复杂和困难的事情。因为我们没有更高级的系统权限，也没有上帝视角，很难知道目前运行的状态的全貌，所以想要设计出一个稳健运行没有<code>bug</code>的功能，不仅非常困难，而且调试起来非常麻烦。</p>
<h2 id="生产消费者模式"><a href="#生产消费者模式" class="headerlink" title="生产消费者模式"></a>生产消费者模式</h2><p>在日常开发当中，<strong>从一个线程向另外的线程传输数据又是一件家常便饭的事情</strong>。举个最简单的例子，我们在处理网页请求的时候，需要打印下来这一次请求的相关日志。打印日志是一次<code>IO</code>行为，这是非常消耗时间的，所以我们不能放在请求当中同步进行，否则会影响系统的性能。最好的办法就是启动一系列线程专门负责打印，后端的线程只负责响应请求，相关的日志以消息的形式传送给打印线程打印。</p>
<p>这个简单的不能再简单的功能当中涉及了诸多细节，我们来盘点几个。首先<code>IO</code>线程的数据都是从后台线程来的，假如一段时间内没有请求，那么这些线程都应该休眠，应该在有请求的时候才会启动。其次，如果某一段时间内请求非常多，导致<code>IO</code>线程一时间来不及打印所有的数据，那么当下的请求应该先暂存起来，等<code>IO</code>线程”忙过来“之后再进行处理。</p>
<p>把这些细节都考虑到，自己来设计功能还是挺麻烦的。好在这个问题前人已经替我们想过了，并且得出了一个非常经典的设计模式，使用它可以很好的解决这个问题。这个模式就是<strong>生产消费者模式</strong>。</p>
<p>这个设计模式的原理其实非常简单，我们来看张图就明白了。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggx4r053p3j30vq092aaq.jpg" alt=""></p>
<p>线程根据和数据的关系分为<strong>生产者线程和消费者线程</strong>，其中生产者线程负责生产数据，产生了数据之后会存储到任务队列当中。消费者线程从这个队列获取需要消费的数据，它和生产者线程之间不会直接交互，避免了线程之间互相依赖的问题。</p>
<p>另外一个细节是这里的任务队列并不是普通的队列，一般情况下是一个<strong>阻塞队列</strong>。也就是说当消费者线程尝试从其中获取数据的时候，如果队列是空的，那么这些消费者线程会自动挂起等待，直到它获得了数据为止。有阻塞队列当然也有非阻塞队列，如果是非阻塞队列的话，当我们尝试从其中获取数据的时候，如果它当中没有数据的话，并不会挂起等待，而是会返回一个空值。</p>
<p>当然阻塞队列的挂起等待时间也是可以设置的，我们可以让它一直等待下去，也可以设置一个<strong>最长等待时间</strong>。如果超过这个时间也会返回空，不同的队列应用在不同的场景当中，我们需要根据场景性质做出调整。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>看完了设计模式的原理，我们下面来试着用代码来实现一下。</p>
<p>在一般的高级语言当中都有现成的队列的库，由于在生产消费者模式当中用到的是阻塞型<code>queue</code>，有阻塞性的队列当然也就有非阻塞型的队列。我们在用之前需要先了解清楚，如果用错了队列会导致整个程序出现问题。在Python当中，我们最常用的<code>queue</code>就是一个<strong>支持多线程场景的阻塞队列</strong>，所以我们直接拿来用就好了。</p>
<p>由于这个设计模式非常简单，这个代码并不长只有几行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">que = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(que, ))</span><br><span class="line">t2 = Thread(target=producer, args=(que, ))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p>我们运行一下就会发现它是可行的，并且由于队列<strong>先进先出</strong>的限制，可以保证了<code>consumer</code>线程读取到的内容的<strong>顺序和<code>producer</code>生产的顺序是一致的</strong>。</p>
<p>如果我们运行一下这个代码会发现它是不会结束的，因为<code>consumer</code>和<code>producer</code>当中都用到了<code>while True</code>构建的死循环，假设我们希望可以控制程序的结束，应该怎么办？</p>
<p>其实也很简单，我们也可以利用队列。我们创建一个特殊的信号量，约定好当<code>consumer</code>接受到这个特殊值的时候就停止程序。这样当我们要结束程序的时候，我们只需要把这个信号量加入队列即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">singal = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> data &lt; <span class="number">20</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">    que.put(singal)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> singal:</span><br><span class="line">            <span class="comment"># 继续插入singal</span></span><br><span class="line">            que.put(singal)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>这里有一个细节是我们在<code>consumer</code>当中，当读取到<code>singal</code>的时候，在跳出循环之前我们又把<code>singal</code>放回了队列。原因也很简单，因为有时候<code>consumer</code>线程不止一个，这个<code>singal</code>上游<strong>只放置了一个，只会被一个线程读取进来</strong>，其他线程并不会知道已经获得了<code>singal</code>的消息，所以还是会继续执行。</p>
<p>而当<code>consumer</code>关闭之前放入<code>singal</code>就可以保证每一个<code>consumer</code>在关闭的之前都会再传递一个结束的信号给其他未关闭的<code>consumer</code>读取。这样一个一个的传递，就可以保证所有<code>consumer</code>都关闭。</p>
<p>这里还有一个小细节，虽然利用队列可以解决生产者和消费者通信的问题，但是上游的生产者并不知道下游的消费者是否已经执行完成了。假如我们想要知道，应该怎么办？</p>
<p>Python的设计者们也考虑到了这个问题，所以他们在<code>Queue</code>这个类当中加入了<strong><code>task_done</code>和<code>join</code>方法</strong>。利用<code>task_done</code>，消费者可以通知<code>queue</code>这一个任务已经执行完成了。而通过调用<code>join</code>，可以等待所有的<code>consumer</code>完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> data &lt; <span class="number">20</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        que.task_done()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">que = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(que, ))</span><br><span class="line">t2 = Thread(target=producer, args=(que, ))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">que.join()</span><br></pre></td></tr></table></figure>
<p>除了使用<code>task_done</code>之外，我们还可以在<code>que</code>传递的消息当中加入一个Event，这样我们还可以继续感知到每一个Event执行的情况。</p>
<h2 id="优先队列与其他设置"><a href="#优先队列与其他设置" class="headerlink" title="优先队列与其他设置"></a>优先队列与其他设置</h2><p>我们之前在介绍一些分布式调度系统的时候曾经说到过，在调度系统当中，调度者会用一个优先队列来管理所有的任务。当有机器空闲的时候，会有限调度那些优先级高的任务。</p>
<p>其实这个调度系统也是基于我们刚才介绍的生产消费者模型开发的，只不过<strong>将调度队列从普通队列换成了优先队列</strong>而已。所以如果我们也希望我们的<code>consumer</code>能够根据任务的优先级来改变执行顺序的话，也可以使用优先队列来进行管理任务。</p>
<p>关于优先队列的实现我们已经很熟悉了，但是有一个问题是我们需要实现挂起等待的阻塞功能。这个我们自己实现是比较麻烦的，但好在我们可以通过调用相关的库来实现。比如<code>threading</code>中的<code>Condition</code>，<strong><code>Condition</code>是一个条件变量可以通知其他线程，也可以实现挂起等待</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._cv = Condition()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            <span class="comment"># 通知下游，唤醒wait状态的线程</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="comment"># 如果对列为空则挂起</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="comment"># 否则返回优先级最大的</span></span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>最后介绍一下<code>Queue</code>的其他设置，比如我们可以<strong>通过size参数设置队列的大小</strong>，由于这是一个阻塞式队列，所以如果我们设置了队列的大小，那么当队列被装满的时候，往其中插入数据的操作也会被阻塞。此时<code>producer</code>线程会被挂起，一直到队列不再满为止。</p>
<p>当然我们也可以通过<code>block</code>参数<strong>将队列的操作设置成非阻塞</strong>。比如<code>que.get(block=False)</code>，那么当队列为空的时候，将会抛出一个队列为空的异常。同样，<code>que.put(data, block=False)</code>时也一样会得到一个队列已满的异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章当中我们主要介绍了多线程场景中经典的生产消费者模式，这个模式在许多场景当中都有使用。比如kafka等消息系统，以及yarn等调度系统等等，几乎只要是涉及到多线程上下游通信的，往往都会用到。也正因此它的使用场景太广了，所以它<strong>经常在各种面试当中出现</strong>，也可以认为是工程师必须知道的几种基础设计模式之一。</p>
<p>另外，队列也是一个在设计模式以及使用场景当中经常出现的数据结构。从侧面也说明了，为什么算法和数据结构非常重要，许多大公司喜欢问一些算法题，也是因为<strong>有实际的使用场景</strong>，并且的的确确能锻炼工程师的思维能力。经常有同学问我算法和数据结构的使用案例，这就是一个很好的例子。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/multi-thread-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/multi-thread-1/" class="post-title-link" itemprop="url">Python通过Event与信号量感知线程状态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 08:56:01 / 修改时间：09:00:34" itemprop="dateCreated datePublished" datetime="2023-04-18T08:56:01+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天这篇文章我们继续多线程的话题。</p>
<p>上篇文章当中我们简单介绍了线程和进程的概念，以及在Python当中如何在主线程之外创建其他线程，并且还了解了<strong>用户级线程和后台线程</strong>的区别以及使用方法。今天我们来看看线程的其他使用，比如如何停止一个线程，线程之间的Event用法等等。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>利用<code>Threading</code>库我们可以很方便地创建线程，让它按照我们的想法执行我们想让它执行的事情，从而加快程序运行的效率。然而有一点坑爹的是，线程创建之后，就交给了操作系统执行，<strong>我们无法直接结束一个线程，也无法给它发送信号，无法调整它的调度</strong>，也没有其他高级操作。如果想要相关的功能，只能自己开发。</p>
<p>怎么开发呢？</p>
<p>我们创建线程的时候指定了<code>target</code>等于一个我们想让它执行的函数，<strong>这个函数并不一定是全局函数，实际上也可以是一个对象中的函数</strong>。如果是对象中的函数，那么我们就可以在这个函数当中获取到对象中的其他信息，我们可以利用这一点来实现手动控制线程的停止。</p>
<p>说起来好像不太好理解，但是看下代码真的非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWithSwitch</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Running &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = TaskWithSwitch()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>, ))</span><br><span class="line">t.start()</span><br><span class="line">c.terminate()</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure>
<p>如果你运行这段代码，会发现屏幕上只输出了10，因为我们将<code>_running</code>这个字段置为<code>False</code>之后，下次循环的时候不再满足循环条件，它就会自己退出了。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggh3b5y6tmj30mx011mx6.jpg" alt=""></p>
<p>如果我们想要用多线程来读取<code>IO</code>，由于<strong>IO可能存在堵塞</strong>，所以可能会出现线程一直无法返回的情况。也就是说我们在循环内部卡死了，这个时候单纯用<code>_running</code>来判断还是不够的，我们需要<strong>在线程内部设置计时器</strong>，防止循环内部的卡死。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, sock</span>):</span><br><span class="line">        <span class="comment"># 在socket中设置计时器</span></span><br><span class="line">        sock.settimeout(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span> self._running:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 由于设置了计时器，所以这里不会永久等待</span></span><br><span class="line">                data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="线程信号的传递"><a href="#线程信号的传递" class="headerlink" title="线程信号的传递"></a>线程信号的传递</h2><p>我们之所以如此费劲才能控制线程的运行，主要原因是<strong>线程的状态是不可知的</strong>，并且我们无法直接操作它，因为它是被操作系统管理的。我们运行的主线程和创建出来的线程是独立的，两者之间并没有从属关系，所以想要实现对线程的状态进行控制，往往需要我们通过其他手段来实现。</p>
<p>我们来思考一个场景，假设我们有一个任务，需要在另外一个线程运行结束之后才能开始执行。要想要实现这一点，就<strong>必须对线程的状态有所感知</strong>，需要其他线程传递出信号来才行。我们可以使用<code>threading</code>中的<code>Event</code>工具来实现这一点。<code>Event</code>工具就是可以用来传递信号的，就好像是一个开关，当一个线程执行完成之后，会去启动这个开关。而这个开关控制着另外一段逻辑的运行。</p>
<p>我们来看下样例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_in_thread</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thread is running&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Thread(target=run_in_thread)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Main thread print&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在线程里面就只做了输出一行提示符，没有其他任何逻辑。由于我们在<code>run_in_thread</code>函数当中沉睡了<code>1s</code>，所以一定是先输出<code>Main thread print</code>再输出的<code>Thread is running</code>。假设这个线程是一个很重要的任务，我们希望主线程能够等待它运行到一个阶段再往下执行，我们应该怎么办呢？</p>
<p>注意，<strong>这里说的是运行到一个阶段，并不是运行结束</strong>。运行结束我们很好处理，可以通过<code>join</code>来完成。但如果不是运行结束，而是运行完成了某一个阶段，当然通过<code>join</code>也可以，但是会损害整体的效率。这个时候我们就必须要用上<code>Event</code>了。加上<code>Event</code>之后，我们再来看下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_in_thread</span>(<span class="params">event</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thread is running&#x27;</span>)</span><br><span class="line">    <span class="comment"># set一下event，这样外面wait的部分就会被启动</span></span><br><span class="line">    event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Event</span></span><br><span class="line">event = Event()</span><br><span class="line">t = Thread(target=run_in_thread, args=(event, ))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># event等待set</span></span><br><span class="line">event.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Main thread print&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>整体的逻辑没有太多的修改，主要的是增加了几行关于<code>Event</code>的使用代码。</p>
<p>我们<strong>如果要用到<code>Event</code>，最好在代码当中只使用一次</strong>。当然通过<code>Event</code>中的<code>clear</code>方法我们可以重置<code>Event</code>的值，但问题是我们没办法保证重置的这个逻辑会在<code>wait</code>之前执行。如果是在之后执行的，那么就会问题，并且在<code>debug</code>的时候会异常痛苦，因为<code>bug</code>不是必现的，而是有时候会出现有时候不会出现。这种情况往往都是因为多线程的使用问题。</p>
<p>所以如果要多次使用开关和信号的话，不要使用<code>Event</code>，可以使用信号量。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><code>Event</code>的问题在于如果多个线程在等待<code>Event</code>的发生，当它一旦被<code>set</code>的时候，那么这些线程都会同时执行。但有时候我们并不希望这样，我们<strong>希望可以控制这些线程一个一个地运行</strong>。如果想要做到这一点，<code>Event</code>就无法满足了，而需要使用信号量。</p>
<p>信号量和<code>Event</code>的使用方法类似，不同的是，<strong>信号量可以保证每次只会启动一个线程</strong>。因为这两者的底层逻辑不太一致，对于<code>Event</code>来说，它更像是一个开关。一旦开关启动，所有和这个开关关联的逻辑都会同时执行。而信号量则像是许可证，只有拿到许可证的线程才能执行工作，并且许可证一次只发一张。</p>
<p>想要使用信号量并不需要自己开发，<code>thread</code>库当中为我们提供了现成的工具——<code>Semaphore</code>，我们来看它的使用代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作线程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n, sema</span>):</span><br><span class="line">    <span class="comment"># 等待信号量</span></span><br><span class="line">    sema.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working&#x27;</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">sema = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line">nworkers = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(nworkers):</span><br><span class="line">    t = threading.Thread(target=worker, args=(n, sema,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>在上面的代码当中我们创建了10个线程，虽然这些线程都被启动了，但是都不会执行逻辑，因为<strong><code>sema.acquire</code>是一个阻塞方法</strong>，没有监听到信号量是会一直挂起等待。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggh3b57xvoj30ga03kdfq.jpg" alt=""></p>
<p>当我们释放信号量之后，线程被启动，才开始了执行。我们每释放一个信号，则会多启动一个线程。这里面的逻辑应该不难理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发场景当中，多线程的使用<strong>绝不是多启动几个线程做不同的任务</strong>而已，我们需要线程间协作，需要同步、获取它们的状态，这是非常不容易的。一不小心就会出现幽灵<code>bug</code>，时显时隐，这也是并发问题让人头疼的主要原因。</p>
<p>这篇文章当中我们只是简单介绍了线程间通信的基本方法，针对这个问题，<strong>还有更好的解决方案</strong>。我们将在后续的文章当中继续讨论这个问题，敬请期待。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/multi-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/multi-thread/" class="post-title-link" itemprop="url">Python多线程与多进程入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 08:48:02 / 修改时间：08:55:03" itemprop="dateCreated datePublished" datetime="2023-04-18T08:48:02+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章我们来聊聊Python当中的多线程。</p>
<p>其实关于元类还有很多种用法，比如说如何在元类当中设置参数啦，以及一些规约的用法等等。只不过这些用法比较小众，使用频率非常低，所以我们<strong>不过多阐述</strong>了，可以在用到的时候再去详细了解。我想只要大家理解了元类的原理以及使用方法，再去学习那些具体的用法应该会很容易。所以我们今天开始了一个新的话题——<strong>多线程和并发</strong>。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>为了照顾小白，我们来简单聊聊<strong>进程和线程</strong>这两个概念。这两个概念属于操作系统，我们经常听说，但是可能很少有人会细究它们的含义。对于工程师而言，两者的定义和区别还是很有必要了解清楚的。</p>
<p>首先说进程，进程可以看成是<strong>CPU执行的具体的任务</strong>。在操作系统当中，由于CPU的运行速度非常快，要比计算机当中的其他设备要快得多。比如内存、磁盘等等，所以如果CPU一次只执行一个任务，那么会导致CPU大量时间在等待这些设备，这样操作效率很低。为了提升计算机的运行效率，把机器的机能尽可能压榨出来，CPU是轮询工作的。也就是说<strong>它一次只执行一个任务，执行一小段碎片时间之后立即切换</strong>，去执行其他任务。</p>
<p>所以在早期的单核机器的时候，看起来电脑也是并发工作的。我们可以一边听歌一边上网，也不会觉得卡顿。但实际上，这是CPU轮询的结果。在这个例子当中，听歌的软件和上网的软件对于CPU而言都是<strong>独立的进程</strong>。我们可以把进程简单地理解成运行的应用，比如在安卓手机里面，一个app启动的时候就会对应系统中的一个进程。当然这种说法不完全准确，<strong>一个应用也是可以启动多个进程的</strong>。</p>
<p>进程是对应CPU而言的，线程则更多针对的是程序。即使是CPU在执行当前进程的时候，程序运行的任务其实也是有分工的。举个例子，比如听歌软件当中，我们需要显示歌词的字幕，需要播放声音，需要监听用户的行为，比如是否发生了切歌、调节音量等等。所以，我们需要<strong>进一步拆分CPU的工作</strong>，让它在执行当前进程的时候，继续通过轮询的方式来同时做多件事情。</p>
<p>进程中的任务就是线程，所以从这点上来说，<strong>进程和线程是包含关系</strong>。一个进程当中可以包含多个线程，对于CPU而言，不能直接执行线程，一个线程一定属于一个进程。所以我们知道，CPU进程切换切换的是执行的应用程序或者是软件，而进程内部的线程切换，切换的是软件当中具体的执行任务。</p>
<p>关于进程和线程有一个经典的模型可以说明它们之间的关系，假设CPU是一家工厂，工厂当中有多个车间。不同的车间对应不同的生产任务，有的车间生产汽车轮胎，有的车间生产汽车骨架。但是工厂的电力是有限的，同时只能满足一个厂房的使用。</p>
<p>为了让大家的进度协调，所以工厂个需要轮流提供各个车间的供电。<strong>这里的车间对应的就是进程</strong>。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo2io5qj30ex0c8gm2.jpg" alt=""></p>
<p>一个车间虽然只生产一种产品，但是其中的工序却不止一个。一个车间可能会有好几条流水线，具体的生产任务其实是流水线完成的，每一条流水线对应一个具体执行的任务。但是同样的，<strong>车间同一时刻也只能执行一条流水线</strong>，所以我们需要车间在这些流水线之间切换供电，让各个流水线生产进度统一。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo4w3r3j30go0ivwgb.jpg" alt=""></p>
<p>这里车间里的<strong>流水线自然对应的就是线程的概念</strong>，这个模型很好地诠释了CPU、进程和线程之间的关系。实际的原理也的确如此，不过CPU中的情况要比现实中的车间复杂得多。因为对于进程和CPU来说，它们面临的局面都是实时变化的。车间当中的流水线是x个，下一刻可能就成了y个。</p>
<p>了解完了线程和进程的概念之后，对于理解电脑的配置也有帮助。比如我们买电脑，经常会碰到一个术语，就是这个电脑的CPU是某某核某某线程的。比如我当年买的第一台笔记本是4核8线程的，这其实是在说这台电脑的CPU有<strong>4个计算核心</strong>，但是使用了超线程技术，使得可以把一个物理核心模拟成两个逻辑核心。相当于我们可以用4个核心同时执行8个线程，相当于8个核心同时执行，但其实有4个核心是模拟出来的虚拟核心。</p>
<p>有一个问题是<strong>为什么是4核8线程而不是4核8进程呢</strong>？因为CPU并不会直接执行进程，而是执行的是进程当中的某一个线程。就好像车间并不能直接生产零件，只有流水线才能生产零件。车间负责的更多是资源的调配，所以教科书里有一句非常经典的话来诠释：<strong>进程是资源分配的最小单元，线程是CPU调度的最小单元</strong>。</p>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>Python当中为我们提供了完善的<code>threading</code>库，通过它，我们可以非常方便地创建线程来执行多线程。</p>
<p>首先，我们引入<code>threading</code>中的<code>Thread</code>，这是一个线程的类，我们可以通过创建一个线程的实例来执行多线程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=func, name=<span class="string">&#x27;therad&#x27;</span>, args=(x, y))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<p>简单解释一下它的用法，我们传入了三个参数，分别是<strong>target，name和args</strong>，从名字上我们就可以猜测出它们的含义。首先是<code>target</code>，它传入的是一个方法，也就是我们希望多线程执行的方法。<code>name</code>是我们为这个新创建的线程起的名字，这个参数可以省略，如果省略的话，系统会为它起一个系统名。当我们执行Python的时候启动的线程名叫<code>MainThread</code>，通过线程的名字我们可以做区分。<code>args</code>是会传递给<code>target</code>这个函数的参数。</p>
<p>我们来举个经典的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span>, args=(<span class="number">10</span>, ))</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p>我们创建了一个非常简单的<code>loop</code>函数，用来执行一个循环来打印数字，我们每次打印一个数字之后这个线程会睡眠5秒钟，所以我们看到的结果应该是每过5秒钟屏幕上多出一行数字。</p>
<p>我们在Jupyter里执行一下：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo2yndaj30ii06pq3c.jpg" alt=""></p>
<p>表面上看这个结果没毛病，但是其实有一个问题，什么问题呢？<strong>输出的顺序不太对</strong>，为什么我们在打印了第一个数字0之后，主线程就结束了呢？另外一个问题是，既然主线程已经结束了，<strong>为什么Python进程没有结束</strong>， 还在向外打印结果呢？</p>
<p>因为线程之间是独立的，对于主线程而言，它在执行了<code>t.start()</code>之后，并<strong>不会停留，而是会一直往下执行一直到结束</strong>。如果我们不希望主线程在这个时候结束，而是阻塞等待子线程运行结束之后再继续运行，我们可以在代码当中加上<code>t.join()</code>这一行来实现这点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><code>join</code>操作可以让主线程在<code>join</code>处挂起等待，直到子线程执行结束之后，再继续往下执行。我们加上了<code>join</code>之后的运行结果是这样的：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8wz0n5r7j30ha06q3z2.jpg" alt=""></p>
<p>这个就是我们预期的样子了，等待子线程执行结束之后再继续。</p>
<p>我们再来看第二个问题，为什么主线程结束的时候，子线程还在继续运行，Python进程没有退出呢？这是因为默认情况下我们创建的都是用户级线程，对于进程而言，<strong>会等待所有用户级线程执行结束之后才退出</strong>。这里就有了一个问题，那假如我们创建了一个线程尝试从一个接口当中获取数据，由于接口一直没有返回，当前进程岂不是会永远等待下去？</p>
<p>这显然是不合理的，所以为了解决这个问题，我们可以把创建出来的线程设置成<strong>守护线程</strong>。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程即<code>daemon</code>线程，它的英文直译其实是后台驻留程序，所以我们也可以理解成<strong>后台线程</strong>，这样更方便理解。<code>daemon</code>线程和用户线程级别不同，进程不会主动等待<code>daemon</code>线程的执行，<strong>当所有用户级线程执行结束之后即会退出。进程退出时会kill掉所有守护线程</strong>。</p>
<p>我们传入<code>daemon=True</code>参数来将创建出来的线程设置成后台线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span>, args=(<span class="number">10</span>, ), daemon=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样我们再执行看到的结果就是这样了：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo1oitwj30jc024q2w.jpg" alt=""></p>
<p>这里有一点需要注意，如果你<strong>在jupyter当中运行是看不到这样的结果的</strong>。因为<code>jupyter</code>自身是一个进程，对于<code>jupyter</code>当中的cell而言，它一直是有用户级线程存活的，所以进程不会退出。所以想要看到这样的效果，只能通过命令行执行Python文件。</p>
<p>如果我们想要等待这个子线程结束，就必须通过<code>join</code>方法。另外，为了预防子线程锁死一直无法退出的情况， 我们还可以<strong>在<code>join</code>当中设置timeout</strong>，即最长等待时间，当等待时间到达之后，将不再等待。</p>
<p>比如我在<code>join</code>当中设置的<code>timeout</code>等于5时，屏幕上就只会输出5个数字。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo3thicj30i7045q32.jpg" alt=""></p>
<p>另外，如果没有设置成后台线程的话，设置<code>timeout</code>虽然也有用，但是<strong>进程仍然会等待所有子线程结束</strong>。所以屏幕上的输出结果会是这样的：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8xsb5qjsj30ix06y0t9.jpg" alt=""></p>
<p>虽然主线程继续往下执行并且结束了，但是子线程仍然一直运行，直到子线程也运行结束。</p>
<p>关于<code>join</code>设置<code>timeout</code>这里有一个坑，如果我们只有一个线程要等待还好，如果有多个线程，我们用一个循环将它们设置等待的话。那么<strong>主线程一共会等待N * timeout的时间</strong>，这里的<code>N</code>是线程的数量。因为每个线程计算是否超时的开始时间是上一个线程超时结束的时间，它会等待所有线程都超时，才会一起终止它们。</p>
<p>比如我这样创建3个线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span> + <span class="built_in">str</span>(i), args=(<span class="number">10</span>, ), daemon=<span class="literal">True</span>)</span><br><span class="line">    ths.append(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> ths:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> ths:</span><br><span class="line">    t.join(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最后屏幕上输出的结果是这样的：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo3dc9nj30km0bhdgl.jpg" alt=""></p>
<p>所有线程都存活了6秒，不得不说，这个设计有点坑，和我们预想的完全不一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天的文章当中，我们一起简单了解了<strong>操作系统当中线程和进程的概念</strong>，以及Python当中如何创建一个线程，以及关于创建线程之后的相关使用。今天介绍的只是最基础的使用和概念，关于线程还有很多高端的用法，我们将在后续的文章当中和大家分享。</p>
<p>多线程在许多语言当中都是至关重要的，许多场景下必定会使用到多线程。比如<strong>web后端，比如爬虫，再比如游戏开发</strong>以及其他所有需要涉及开发<code>ui</code>界面的领域。因为凡是涉及到<code>ui</code>，必然会需要一个线程单独渲染页面，另外的线程负责准备数据和执行逻辑。因此，多线程是专业程序员绕不开的一个话题，也是一定要掌握的内容之一。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/18/orm-db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/18/orm-db/" class="post-title-link" itemprop="url">通过元类实现ORM数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-18 08:17:38 / 修改时间：08:55:13" itemprop="dateCreated datePublished" datetime="2023-04-18T08:17:38+08:00">2023-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天这篇文章我们一起来用元类实现一个简易的ORM数据库框架。</p>
<p>本文主要是受到了廖雪峰老师Python3入门教程的启发，不过廖老师的博客有些精简，一些小白可能看起来比较吃力。我在他的基础上做了一些<strong>补充和注释</strong>，尽量写得浅显一些。</p>
<h2 id="ORM框架是什么"><a href="#ORM框架是什么" class="headerlink" title="ORM框架是什么"></a>ORM框架是什么</h2><p>如果是没有做过后端的小伙伴上来估计会有点蒙，这个ORM框架究竟是什么？ORM框架是后端工程师常用的一个框架，它的英文全称是Object Relational Mapping，即<strong>对象-关系映射</strong>框架。顾名思义就是把关系转化成对象的框架，关系这个词我们在哪里用的最多呢？</p>
<p>显然应该是数据库。之前我们在分布式的文章介绍关系型数据库和非关系型数据库的时候就着重介绍过关系的含义。我们常用的MySQL就是经典的关系型数据库，它存储的形式是表，但是<strong>表承载的数据其实是两个实体之间的”关系”</strong>。比如学生上课这个场景，学生和课程是两个主体（entity），我们要记录的是这两个主体之间的关系，也就是学生上课这件事。</p>
<p>而ORM框架做的事情是将这些关系映射成类，这样我们可以将这张表当中增删改查的功能抽象成类当中的方法。这样我们就可以通过调用类的方式来操作数据库了，从而达到<strong>高度抽象业务逻辑、降低用户使用难度</strong>的目的。</p>
<p>比如Java后端工程师常用的<code>hibernate</code>和<code>ibatis</code>都是用来做这件事情的，明确了框架的功能之后，我们先来设想一下最后的成果。假设我们现在开发出来了这么一套框架，那么它用起来的感觉应该是怎样的？</p>
<p>我们来看下廖老师博客里给的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="comment"># 定义类的属性到列的映射：</span></span><br><span class="line">    <span class="built_in">id</span> = IntegerField(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    name = StringField(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    email = StringField(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">    password = StringField(<span class="string">&#x27;password&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>User类代表了数据库当中的一张表，它有4个字段：<code>id, name, email</code>和<code>password</code>，我们在定义字段的同时也通过类别指定了它们的类型。这个应该不难理解，上面的这个类等价于我们在数据库当中执行了这么一段建表的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> (</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name string,</span><br><span class="line">    email string,</span><br><span class="line">    password string</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们定义了表字段之后，接下来要做的就是<strong>根据字段创建数据</strong>了，其实也就是根据类创建实例。我们希望<strong>User类型的实例就对应User表当中的一条记录</strong>，并且我们可以通过调用实例当中的方法，来操作这张表进行增删改查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个实例：</span></span><br><span class="line">u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存到数据库：</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>
<p>那么，我们怎样可以实现这样的功能呢？</p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>我们先从简单的功能开始实现，首先是<code>Field</code>类，<strong>Field类表示数据库表当中一个字段的类型</strong>。这里的逻辑很容易理清楚，我们需要定义多种类型，比如<code>IntegerField</code>和<code>StringField</code>。我们可以对这些<code>field</code>类抽象出一个父类来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, column_type</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#123;&#125;:&#123;&#125;&gt;&#x27;</span>.<span class="built_in">format</span>(self.__class__.__name__, self.name)</span><br></pre></td></tr></table></figure>
<p><code>__str__</code>方法当中打印出来的两个字段，分别是类别的名称和字段的名称，这段代码应该不难理解。</p>
<p>接着，我们实现它的两个子类，分别是<code>IntegerField</code>和<code>StringField</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(StringField, self).__init__(name, <span class="string">&#x27;varchar(100)&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(IntegerField, self).__init__(name, <span class="string">&#x27;bigint&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里也不难理解，只是一个简单的继承应用而已。</p>
<p>接下来就到了最关键的部分，也就是<code>Model</code>类的实现。我们先来分析一下我们希望<code>Model</code>这个类拥有的功能，由于它是我们定义出来的每一张表的父类，所以它应该<strong>能够获取子类当中的字段</strong>，并且将它存放在一个容器当中。由于我们需要存储的是字段名和类型的映射，所以将它存储在<code>dict</code>当中比较合理。</p>
<p>另外一个功能是我们希望它<strong>能够提供增删改查的接口</strong>，能够根据子类当中定义的字段自动生成相应的SQL语句去调用数据库。这个也是ORM框架的意义所在。</p>
<p>第二个功能容易实现，只要第一个功能搞定了，做一下字符串处理即可。但是第一个功能有些麻烦，它也是元类的意义所在。因为<strong>父类当中的方法是无法获取子类中定义的类属性的</strong>，只能通过元类，在构建类的时候可以拿到属性的信息。</p>
<p>所以我们已经很明确了，我们实现元类的目的就是为了实现这个功能。理清楚了之后，再来写代码就不难了。我们先来实现这个元类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 创建model类的时候不做任何处理</span></span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">&#x27;Model&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line">        <span class="comment"># 打印表名的信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Found model: %s&#x27;</span> % name)</span><br><span class="line">        <span class="comment"># mappings用来存储字段的信息</span></span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 判断v的类型，只有是Field的子类才会存储起来</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">        <span class="comment"># 将mappings当中的数据从类属性当中移除，防止关键字冲突</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>
<p>如果你看过之前的文章，对元类已经很熟悉了，那么这段代码对你来说应该不难理解。元类搞定了，剩下的<code>Model</code>就更简单了。按照规范，我们需要实现增删改查四个函数，但是这里我们只是为了展示，所以就只实现其中一个作为例子，其他几个都可以如法炮制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">dict</span>, metaclass=ModelMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):</span><br><span class="line">        <span class="comment"># 由于Model的基类是dict，所以创造Model的字段会被解析成dict的构造参数</span></span><br><span class="line">        <span class="comment"># 也就是说字段名和字段值的映射会存储在dict当中</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__(**kw)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            <span class="comment"># fields存储字段名</span></span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            <span class="comment"># params填充问号</span></span><br><span class="line">            params.append(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            <span class="comment"># 获取字段的值</span></span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(params))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ARGS: %s&#x27;</span> % <span class="built_in">str</span>(args))</span><br></pre></td></tr></table></figure>
<p>Model当中的save方法不难看懂，但是前面的几个方法看起来有些多余。但实际上它们也很重要，这里有一个关键信息是<strong>Model类的父类是<code>dict</code></strong>，我们在构建<code>Model</code>的时候传入的参数会被用来初始化一个<code>dict</code>。所以我们创建数据实例的时候数据的名称和数据值的映射会被存储在<code>dict</code>当中，所以我们在<code>save</code>方法当中才会从<code>self</code>的<code>attr</code>当中获取字段的值。并且我们<strong>在初始化<code>User</code>的时候，也必须要填写每个字段的名称</strong>，原因就在这里。</p>
<p>最后我们来运行一下：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg0uhfmqhhj30jg03lq36.jpg" alt=""></p>
<p>从结果上来看，我们输出了User这个类的插入SQL以及它的字段的值。只需要链接一下数据库，我们的这个ORM框架就可以真正投入使用了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在整个ORM框架实现的过程当中，最重要的是我们对Model这个类创建了元类，但是<strong>真正应用的地方却是在Model的子类</strong>。实际上在实际创建User类的时候，解释器会先搜索User内部是否定义了元类，如果没有，会上一层去往User的父类也就是Model类搜索元类，如果找到了元类，就会使用元类来创建User。<strong>相当于元类被隐形地继承了下来</strong>，但是我们在使用子类的时候却感知不到。</p>
<p>对于框架的使用者来说，也的确不需要了解框架内部的实现机制，只需要明白使用方法，照着使用就行了。虽然元类的实现和理解很复杂，但是使用起来却很简单，这也是它的一个显著特点。</p>
<p>最后，本文的代码示例源于廖雪峰老师的博客，<strong>向廖雪峰老师致敬</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/17/python-meta/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/17/python-meta/" class="post-title-link" itemprop="url">Python元类入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-17 22:40:59 / 修改时间：22:47:19" itemprop="dateCreated datePublished" datetime="2023-04-17T22:40:59+08:00">2023-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天我们来继续聊聊Python当中的元类。</p>
<p>在之前的文章当中我们介绍了type元类的用法，在上一篇文章当中我们介绍了<code>__new__</code>函数与<code>__init__</code>函数的区别，以及它在一些设计模式当中的运用。这篇文章我们来看看<code>metacalss</code>与元类，以及<code>__new__</code>函数在元类当中的使用。</p>
<p><strong>那文章非常重要，是这一篇的基础</strong>，如果错过了上篇文章，推荐回顾一下。</p>
<h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h2><p><code>metaclass</code>的英文直译过来就是元类，这既是一个概念也可以认为是Python当中的一个关键字，不管怎么理解，对它的内核含义并没有什么影响。我们可以不必纠结，就认为它是类的类的意思即可。在这个用法当中，<strong>支持我们自己定义一个类，使得它是后面某一个类的元类。</strong></p>
<p>之前使用type动态创建类的时候，我们传入了类名，和父类的<code>tuple</code>以及属性的<code>dict</code>。在<code>metaclass</code>用法当中，其实核心相差不大，只是表现形式有所区别。我们来看一个例子即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddInfo</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attr</span>):</span><br><span class="line">        attr[<span class="string">&#x27;info&#x27;</span>] = <span class="string">&#x27;add by metaclass&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attr)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(metaclass=AddInfo):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在这个例子当中，我们首先创建了一个类叫做<code>AddInfo</code>，这是我们定义的一个元类。由于我们希望通过它来实现元类的功能，所以我们<strong>需要它继承type类</strong>。我们在之前的文章当中说过，在Python面向对象当中，所有的类的根本来源就是<code>type</code>。也就是说Python当中的每一个类都是<code>type</code>的实例。</p>
<p>我们在这个类当中重载了<code>__new__</code>方法，我们在<code>__new__</code>方法当中传入了四个参数。眼尖一点的小伙伴一定已经看出来了，<strong>这个函数的四个参数，正是我们调用type创建类的时候传入的参数</strong>。其实我们调用<code>type</code>的方法来创建类的时候，就是调用的<code>__new__</code>这个函数完成的，这两种写法对应的逻辑是完全一样的。</p>
<p>我们之后又创建了一个新的类叫做<code>Test</code>，这个当中没有任何逻辑，直接pass。但是我们在创建类的时候指定了一个参数<code>metaclass=AddInfo</code>，这里<strong>这个参数其实就是指定的这个类的元类</strong>，也就是指定这个类的创建逻辑。虽然我们用代码写了类的定义，但是在实际执行的时候，这个类是以<code>metaclass</code>为元类创建的。</p>
<p>根据上面的逻辑，我们可以知道，Test类在创建的时候就被赋予了类属性<code>info</code>。我们可以验证一下：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt5zn6ej30rc086weq.jpg" alt=""></p>
<h2 id="拓展类功能"><a href="#拓展类功能" class="headerlink" title="拓展类功能"></a>拓展类功能</h2><p>上面这段就是元类的基本用法了，其实本质上和我们之前介绍的<code>type</code>的动态类创建是一样的，只不过展现的形式不同。那么我们就有一个问题要问了，我们使用元类究竟能够做什么呢？</p>
<p>这里有一个经典的例子，我们都知道Python原生的list是没有<code>add</code>这个方法的。假设我们习惯了Java当中list的使用，习惯用add来为它添加元素。我们希望创建一个新的类，在这个新的类当中，我们可以通过add来添加函数。通过元类可以很方便地使用这一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 在类属性当中添加了add函数</span></span><br><span class="line">        <span class="comment"># 通过匿名函数映射到append函数上</span></span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attrs)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="built_in">list</span>, metaclass=ListMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>我们首先是定义了一个叫做<code>ListMeta</code>的元类，在这个元类当中我们给类添加了一个属性叫做<code>add</code>。它只是包装了一下而已，<strong>底层是通过<code>append</code>方法实现的</strong>。我们来实验一下：</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt5gcc2j30q806yaa5.jpg" alt=""></p>
<p>从结果来看也没什么问题，我们成功通过调用<code>add</code>方法往list当中插入了元素。这里藏着一个小细节，我们在<code>ListMeta</code>当中为<code>attrs</code>添加了一个名叫<code>add</code>的属性。<strong>这个属性是添加给类的</strong>，而不是类初始化出来的实例的。所以如果我们print出<code>MyList</code>这个类当中的所有属性，也能看到<code>add</code>的存在。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt4y8okj31cc07g0ts.jpg" alt=""></p>
<p>如果我们直接去通过<code>MyList</code>去访问<code>add</code>方法的话会引起报错，因为我们实现<code>add</code>这个方法逻辑的匿名函数<strong>限制了需要传入两个参数</strong>。第一个参数是实例的对象<code>self</code>，第二个参数才是添加的元素<code>value</code>。如果我们通过<code>MyList</code>的类属性去访问它的话会触发一个错误，因为缺少了一个参数。因为类当中的属性实例也是可以调用的，并且Python会在参数前面自动添加self这个参数，就刚好满足了要求。</p>
<p>搞明白了这些我们只是解决了可能性问题，我们明白了元类可以实现这样的操作，但没有解决我们为什么必须要使用元类呢？就拿刚才的例子来说，我们完全可以继承list这个类，然后在其中再开发我们想要的方法，为什么一定要使用元类呢？</p>
<p>就刚才这个场景来说，的确，我们是找不出任何理由的。完全没有理由不使用继承，而非要用元类。但是在有些场景和有些问题当中，我们必须要使用元类不可。就是<strong>涉及类属性变更和类创建的时候</strong>，我们来看下面这个例子。</p>
<h2 id="控制实例的创建"><a href="#控制实例的创建" class="headerlink" title="控制实例的创建"></a>控制实例的创建</h2><p>还记得我们上篇文章介绍的工厂设计模式的例子吗？就是我们可以通过参数来得到不同类的实例。</p>
<p>我们创建了三种游戏的类和一个工厂类，我们重载了工厂类的<code>__new__</code>函数。使得我们可以根据实例化时传入的参数返回不同类型的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Last_of_us</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Last Of Us is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uncharted</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Uncharted is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;PS has many games&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameFactory</span>:</span><br><span class="line">    games = &#123;<span class="string">&#x27;last_of_us&#x27;</span>: Last_of_us, <span class="string">&#x27;uncharted&#x27;</span>: Uncharted&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.games:</span><br><span class="line">            <span class="keyword">return</span> cls.games[name]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> PSGame()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">uncharted = GameFactory(<span class="string">&#x27;uncharted&#x27;</span>)</span><br><span class="line">last_of_us = GameFactory(<span class="string">&#x27;last_of_us&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>假设这个需求完成得很好顺利上线了，但是运行了一段时间之后我们<strong>发现下游有的时候为了偷懒会不通过工厂类来创建实例</strong>，而是直接对需要的类做实例化。原本这没有问题，但是现在产品想要在工厂类当中加上一些埋点，统计出访问我们工厂的访问量。所以我们需要<strong>限制这些游戏类不能直接实例化，必须要通过工厂返回实例</strong>。</p>
<p>那么这个功能我们怎么实现呢？</p>
<p>我们分析一下问题就会发现，这一次不是需要我们在创建实例的时候做动态的添加，而是直接限制一些类不允许直接调用进行创建。限制的方法比较常用的一种就是抛出异常，所以我们希望可以给这些类加上一个逻辑，<strong>实例化类的时候传入一个参数，表明是否是通过工厂类进行的，如果不是，则抛出异常</strong>。</p>
<p>这里，我们需要用到另外一个默认函数，叫做<code>__call__</code>，它是<strong>允许将类实例当做函数调用</strong>。我们通过类名来实例化，其实也是一个调用逻辑。这个<code>__call__</code>的逻辑并不难写，我们随手就来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> <span class="keyword">or</span> args[<span class="number">0</span>] != <span class="string">&#x27;factory&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;Can&#x27;t instantiate directly&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>但问题是这个<code>__call__</code>函数<strong>并不能直接加在类当中，因为它的应用范围是实例</strong>，而不是类。而我们希望的是在创建实例的时候进行限制，而不是对调用实例的时候进行限制，所以这段逻辑<strong>只能通过元类实现</strong>。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt7e4pkj310q09igna.jpg" alt=""></p>
<p>我们直接创建类的时候就会触发异常，因为不是通过工厂创建的。我们这里判断是否是工厂创建的逻辑简化掉了，只是通过一个简单的字符串来进行的判断，实际上会用一些更加复杂的逻辑，这不是本文的重点，我们了解即可。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt6j702j314i0hqacv.jpg" alt=""></p>
<p>整体运行的逻辑和我们设想的一样，说明这样实现是正确的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们日常开发当中用到元类的情况非常罕见，一般都是在一些<strong>高端开发的场景</strong>当中。比如说开发一些框架或者是中间件，为了方便下游的使用，需要创建一些关于类属性的动态逻辑，才会用到元类。对于普通开发者而言，如果你无法理解元类的含义以及应用，也没有关系，使用频率非常低。</p>
<p>另外，<strong>元类的概念和动态类、动态语言的概念有关</strong>，Python语言的动态特性很多正是通过这一点体现的。所以随着我们对于Python动态特性理解的加深，理解元类也会变得越来越容易，同样也会理解越来越深刻。如果我们把Python的元类和装饰器做一个类比的话，会发现<strong>两者的核心逻辑是很类似的</strong>。本质上都是在原有的逻辑之外封装新的逻辑，只不过装饰器针对的是一段逻辑，而元类针对的是类的属性和创建过程。</p>
<p>仔细思考，我相信一定会有灵光乍现的感觉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.ailinghang.club/2023/04/17/python-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ai.jpg">
      <meta itemprop="name" content="Ai领航员">
      <meta itemprop="description" content="人工智能从零入门教程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai领航员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/17/python-new/" class="post-title-link" itemprop="url">详解Python构造函数__new__</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-17 09:08:00 / 修改时间：09:19:04" itemprop="dateCreated datePublished" datetime="2023-04-17T09:08:00+08:00">2023-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章我们来聊聊Python当中一个新的默认函数<code>__new__</code>。</p>
<p>上一篇当中我们讲了如何使用type函数来动态创建Python当中的类，除了type可以完成这一点之外，还有另外一种用法叫做<code>metaclass</code>。原本这一篇应该是继续元类的内容，讲解<code>metaclass</code>的使用。但是<code>metaclass</code>当中用到了一个<strong>新的默认函数<code>__new__</code></strong>，关于这个函数大家可能会比较陌生，所以在我们研究<code>metaclass</code>之前，我们先来看看<code>__new__</code>这个函数的用法。</p>
<h2 id="真假构造函数"><a href="#真假构造函数" class="headerlink" title="真假构造函数"></a>真假构造函数</h2><p>如果你去面试Python工程师的岗位，面试官问你，请问Python当中的类的<strong>构造函数</strong>是什么？</p>
<p>你不假思索，当然是<code>__init__</code>啦！如果你这么回答，很有可能你就和offer无缘了。因为在Python当中<code>__init__</code>并不是构造函数，<code>__new__</code>才是。是不是有点蒙，多西得（日语：为什么）？我们不是一直将<code>__init__</code>方法当做构造函数来用的吗？怎么又冒出来一个<code>__new__，</code>如果<code>__new__</code>才是构造函数，那么<strong>为什么我们创建类的时候从来不用它呢？</strong></p>
<p>别着急，我们慢慢来看。首先我们回顾一下<code>__init__</code>的用法，我们随便写一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br></pre></td></tr></table></figure>
<p>我们一直都是这么用的，对不对，毫无问题。但是我们换一个问题，我们在Python当中怎么实现单例(Singleton)的设计模式呢？怎么样实现工厂呢？</p>
<p>从这个问题出发，你会发现只使用<code>__init__</code>函数是不可能完成的，因为<code>__init__</code>并不是构造函数，它只是<strong>初始化方法</strong>。也就是说在调用<code>__init__</code>之前，我们的实例就已经被创建好了，<code>__init__</code>只是为这个实例赋上了一些值。如果我们把创建实例的过程比喻成做一个蛋糕，<code>__init__</code>方法并不是烘焙蛋糕的，只是点缀蛋糕的。那么显然，在点缀之前必须先烘焙出一个蛋糕来才行，那么这个烘焙蛋糕的函数就是<code>__new__</code>。</p>
<h2 id="new-函数"><a href="#new-函数" class="headerlink" title="__new__函数"></a><code>__new__</code>函数</h2><p>我们来看下<code>__new__</code>这个函数的定义，我们在使用Python面向对象的时候，<strong>一般都不会重构这个函数</strong>，而是使用Python提供的默认构造函数，Python默认构造函数的逻辑大概是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>从代码可以看得出来，函数当中基本上什么也没做，就原封不动地调用了父类的构造函数。这里隐藏着Python当中类的创建逻辑，是根据继承关系一级一级创建的。根据逻辑关系，我们可以知道，当我们创建一个实例的时候，实际上是<strong>先调用的<code>__new__</code>函数创建实例，然后再调用<code>__init__</code>对实例进行的初始化</strong>。我们可以简单做个实验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__new__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>().__new__(cls)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>当我们创建Test这个类的时候，通过输出的顺序就可以知道Python内部的调用顺序。</p>
<p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfl6w59vwkj30b8028jr7.jpg" alt=""></p>
<p>从结果上来看，和我们的推测完全一样。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>那么我们重载<code>__new__</code>函数可以做什么呢？一般都是用来完成<code>__init__</code>无法完成的事情，比如前面说的<strong>单例模式</strong>，通过<code>__new__</code>函数就可以实现。我们来简单实现一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(SingletonObject, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            SingletonObject._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> SingletonObject._instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>当然，如果是在并发场景当中使用，还需要加上线程锁防止并发问题，但逻辑是一样的。</p>
<p>除了可以实现一些功能之外，还可以<strong>控制实例的创建</strong>。因为Python当中是先调用的<code>__new__</code>再调用的<code>__init__</code>，所以如果当调用<code>__new__</code>的时候返回了<code>None</code>，那么最后得到的结果也是<code>None</code>。通过这个特性，我们可以控制类的创建。比如设置条件，只有在满足条件的时候才能正确创建实例，否则会返回一个<code>None</code>。</p>
<p>比如我们想要创建一个类，它是一个<code>int</code>，但是不能为0值，我们就可以利用<code>__new__</code>的这个特性来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonZero</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, value</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, value) <span class="keyword">if</span> value != <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>那么当我们用0值来创建它的时候就会得到一个<code>None</code>，而不是一个实例。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>理解了<code>__new__</code>函数的特性之后，我们就可以灵活运用了。我们可以用它来实现许多其他的设计模式，比如大名鼎鼎经常使用的<strong>工厂模式</strong>。</p>
<p>所谓的工厂模式是指通过一个接口，<strong>根据参数的取值来创建不同的实例</strong>。创建过程的逻辑对外封闭，用户不必关系实现的逻辑。就好比一个工厂可以生产多种零件，用户并不关心生产的过程，只需要告知需要零件的种类。也因此称为工厂模式。</p>
<p>比如说我们来创建一系列游戏的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Last_of_us</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Last Of Us is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uncharted</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Uncharted is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;PS has many games&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后这个时候我们希望可以通过一个接口根据参数的不同返回不同的游戏，如果不通过<strong>new</strong>，这段逻辑就只能写成函数而不能通过面向对象来实现。通过重载<code>__new__</code>我们就可以很方便地用参数来获取不同类的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameFactory</span>:</span><br><span class="line">    games = &#123;<span class="string">&#x27;last_of_us&#x27;</span>: Last_Of_us, <span class="string">&#x27;uncharted&#x27;</span>: Uncharted&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.games:</span><br><span class="line">            <span class="keyword">return</span> cls.games[name]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> PSGame()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">uncharted = GameFactory(<span class="string">&#x27;uncharted&#x27;</span>)</span><br><span class="line">last_of_us = GameFactory(<span class="string">&#x27;last_of_us&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信看到这里，关于<code>__new__</code>这个函数的用法应该都能理解了。一般情况下我们是用不到这个函数的，只会在一些特殊的场景下使用。虽然如此，我们学会它并不只是用来实现设计模式，更重要的是可以加深我们对于Python面向对象的理解。</p>
<p>除此之外，另一个经常使用<code>__new__</code>场景是元类。所以今天的这篇文章其实也是为了后面介绍元类的其他用法打基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>


        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ai领航员"
      src="/images/ai.jpg">
  <p class="site-author-name" itemprop="name">Ai领航员</p>
  <div class="site-description" itemprop="description">人工智能从零入门教程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/moutsea/ai_tutorial" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moutsea&#x2F;ai_tutorial" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suyuxuan94@qq.com" title="E-Mail → suyuxuan94@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/coderliangt" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;coderliangt" rel="noopener" target="_blank"><i class="fal fa-zhihu fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ai领航员</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">72k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        

<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
