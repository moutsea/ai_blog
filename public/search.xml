<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python使用argparse解析命令行参数</title>
      <link href="/2023/04/18/python-args/"/>
      <url>/2023/04/18/python-args/</url>
      
        <content type="html"><![CDATA[<p>这是Python系列最后一篇文章，我们来聊聊Python当中的命令行参数工具argparse。</p><p>命令行参数工具是我们非常常用的工具，比如当我们做实验希望调节参数的时候，如果参数都是通过硬编码写在代码当中的话，我们每次修改参数都需要修改对应的代码和逻辑显然这不太方便。比较好的办法就是把必要的参数设置成<strong>通过命令行传入</strong>的形式，这样我们只需要在运行的时候修改参数就可以了。</p><h2 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h2><p>解析命令行传入参数最简单的办法就是通过<strong>sys.argv</strong>，<code>sys.argv</code>可以获取到我们通过命令行传入的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br></pre></td></tr></table></figure><p>用法很简单，只需要调用<code>sys.argv</code>即可。<code>argv</code>是一个数组，如果参数有多个，我们可以通过下标进行访问。但是有一点需要注意，<code>argv</code>当中存储的结果是从Python调用开始的。</p><p>我们来看一个例子，我们随意传入一些参数，<code>print sys.argv</code>之后是这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python test.py -a -c -d=<span class="number">222</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;test.py&#x27;</span>, <span class="string">&#x27;-a&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;-d=222&#x27;</span>]</span><br></pre></td></tr></table></figure><p>也就是说我们python运行test.py这个<strong>文件名也当做参数之一</strong>，所以我们要获取自定义参数的话需要从<code>argv[1]</code>开始。</p><p><code>sys.argv</code>的好处是方便，我们只需要访问它就可以拿到传入的参数了。但是缺点也很明显，就是功能太少了。假如我们是看其他大神的代码，我们想要知道运行的时候需要传入什么参数，以及每个参数代表什么含义就做不到了。</p><p>为了解决这个问题，我们需要使用封装更多功能的工具，也是本篇文章的核心——<strong>argparse</strong>。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>argparse</code>是Python当中的一个库，我们需要先<code>import</code>一下，这个库我没记错应该是Python自带的，也不需要安装，我们直接就可以使用。</p><p>在我们使用之前，我们需要先初始化这个parse，也就是一个参数解析器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里ArgumentParser可以传入一个字符串，表示用途</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure><p>这个时候其实就已经有了一个解析器了，我们在运行的时候可以传入参数<code>-h</code>，表示help，也就是查看目前解析器当中定义的参数。由于我们现在什么也没有，所以能显示出来的就只有help。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtim589a2j318w052js7.jpg" alt=""></p><h2 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h2><p>首先我们来介绍<strong>必选参数</strong>，它的定义和函数当中的必填参数是一样的，也就是说我们运行程序必须要的参数。如果不传，那么程序不应该执行会进行报错并提示。</p><p>定义必选参数的方法非常简单，我们只需要通过<code>add_argument</code>传入参数的名称就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(<span class="string">&quot;For test the parser&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.test)</span><br></pre></td></tr></table></figure><p>这样我们就定义了一个名叫<code>test</code>的参数，我们可以通过<code>args.test</code>来访问它。</p><p>这个时候我们再运行<code>python test.py -h</code>就会发现提示的信息当中多了一行：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtiu7gumxj318e086q41.jpg" alt=""></p><p>告诉我们必选参数当中有test，<strong>必选参数直接传入，不需要加上前缀</strong>。所以我们执行的时候直接<code>python test.py xxx</code>就可以了。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有必选参数当然就有可选参数，可选参数由于可选可不选， 所以我们在使用的时候需要在参数前加上标识-或者—。比如我们参数名叫做test，可以定义成<code>-test</code>或者<code>--test</code>，这两种都可以，也可以这两种都定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们运行<code>-h</code>可以发现<code>optional arguments</code>当中多了<code>test</code>和<code>--test</code>。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtj00hkhfj3184060my4.jpg" alt=""></p><p>但是这个只print出来了参数名，并没有告诉我们这个参数究竟是做什么的，像是help参数后面就跟了show this help message and exit这个提示语。如果我们也希望help能够提示我们参数的作用怎么办呢？</p><p>我们可以通过help参数传入我们希望打印出来的提示语，这样方便使用者在使用的时候了解参数的情况。</p><p>比如我们把这行语句改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样当我们运行的时候，就会看到提示语了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtj2bewz8j31bc076t9t.jpg" alt=""></p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果参数很多的时候，我们有时候可能不希望每一个都指定一个值，而是希望可以在不填的时候有一个默认值。这个想法非常正常，想要做到这点也很简单，我们可以通过<strong>default参数</strong>来指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(<span class="string">&quot;For test the parser&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.test)</span><br></pre></td></tr></table></figure><p>比如这样我们在代码当中把test参数的默认值设置成了1，当我们运行的时候，如果不填test这个参数的话，那么程序就会使用它的默认值也就是1。</p><p>但有一点<strong>默认值的信息并不会print在help当中</strong>，所以我们需要自己在提示语当中告知使用者默认值是多少。</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>我们可以定义参数的默认值，当然也可以定义它的类型。</p><p>因为<strong>命令行传入的参数默认都是字符串</strong>，如果我们要进行数学上的计算，使用<code>str</code>还需要自己转换，这就很不方便。我们可以在传入参数的时候就完成类型的匹配，这样如果传入参数的类型不对， 那么直接报错，不往下运行。</p><p>想要做到这点也很简单，通过<code>type</code>参数就可以实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>比如当我们定义了一个<code>int</code>型的参数，而传入的是类型不匹配的话，那么就会引起报错：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtjk48uj6j31bo03c3za.jpg" alt=""></p><p>报错信息当中写得很清楚，我们得到了一个无效的<code>int</code>的值，它是abc。</p><h2 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h2><p>它同样还支持可选值，可选值很好理解，就是我们希望<strong>限定传入参数的范围仅仅在几个值当中</strong>。比如说我们希望传入的值不是0就是1，或者是在某几个具体的值当中，这个时候我们可以通过<code>choices</code>参数来实现这一点。</p><p><code>choices</code>参数传入的是一个list，也就是我们的限定范围，只有在这个范围当中的值才被允许。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, default=<span class="number">1</span>, choices=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果我们运行传入<code>test=1</code>，那么就会引起报错，告诉我们传入的值不在<code>choices</code>范围当中。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtjpcsyrij317g02y0tj.jpg" alt=""></p><p>这是一个挺有意思的例子，仔细看会发现我们默认值设置成了1，但是可选值当中并没有1。这也是允许的，<strong>默认值可以不在可选值范围内</strong>，但是当我们传入1就会触发可选值校验。</p><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p><code>action</code>是一个很神奇也很有用的操作，可以<strong>指定参数的处理方式</strong>。我们默认的方式是store，也就是存储的意思，这个我们都能理解。除此之外，还有<code>store_true</code>，它表示出现则是true，否则是false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们把test参数的定义改成这样之后，我们来对比一下运行的结果就明白了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtq5deajdj31bs0443zf.jpg" alt=""></p><p>除了<code>store_true</code>之外还有<code>store_const</code>，也就是说出现就指定为一个固定值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>, const=<span class="number">23</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样当我们指定<code>-test</code>参数之后，它会自动被赋值成23。</p><p>除了这两个之外，另外一个很常用的参数是<strong>append</strong>，可以将多次出现的同一个参数自动存入一个list当中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, action=<span class="string">&#x27;append&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtl70htzwj31be01w74n.jpg" alt=""></p><h2 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h2><p><code>nargs</code>也是一个非常有用的参数，可以对参数进行一些花式操作。nargs的传入参数有以下几种，首先是N，也就是一个整数。代表可以<strong>接收N个参数值</strong>，这N个值会被存入一个list当中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, nargs=<span class="number">2</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p>另外一种传入的参数是<code>&#39;+&#39;</code>或者是<code>&#39;*&#39;</code>，它可以将任意多个值存入一个list当中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-test&#x27;</span>, <span class="string">&#x27;--test&#x27;</span>, nargs=<span class="string">&#x27;*&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&#x27;just for help&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghtlno7hoej31cg01umxk.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了parser之后，我们在Python当中处理命令行参数会变得非常简单，我们可以做各种各样的定制化操作。除了我们上面介绍的之外，还有一些其他的做法，相对来说不是非常常用，所以就不一一穷尽了，感兴趣的同学可以自行了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行参数 </tag>
            
            <tag> argparse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python中协程的使用</title>
      <link href="/2023/04/18/python-routine/"/>
      <url>/2023/04/18/python-routine/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来聊聊Python当中的协程。</p><p>我们曾经在golang关于<code>goroutine</code>的文章当中简单介绍过<strong>协程</strong>的概念，我们再来简单review一下。协程又称为是微线程，英文名是<code>Coroutine</code>。它和线程一样可以调度，但是不同的是线程的启动和调度需要通过操作系统来处理。并且线程的启动和销毁需要涉及一些操作系统的变量申请和销毁处理，需要的时间比较长。而协程呢，它的<strong>调度和销毁都是程序自己来控制</strong>的，因此它更加轻量级也更加灵活。</p><p>协程有这么多优点，自然也会有一些缺点，其中最大的缺点就是<strong>需要编程语言自己支持</strong>，否则的话需要开发者自己通过一些方法来实现协程。对于大部分语言来说，都不支持这一机制。go语言由于天然支持协程，并且支持得非常好，使得它广受好评，短短几年时间就迅速流行起来。</p><p>对于Python来说，本身就有着一个GIL这个巨大的先天问题。GIL是Python的全局锁，在它的限制下<strong>一个Python进程同一时间只能同时执行一个线程</strong>，即使是在多核心的机器当中。这就大大影响了Python的性能，尤其是在CPU密集型的工作上。所以为了提升Python的性能，很多开发者想出了使用多进程+协程的方式。一开始是开发者自行实现的，后来在Python3.4的版本当中，官方也收入了这个功能，因此目前可以光明正大地说，Python是支持协程的语言了。</p><h2 id="生成器（generator"><a href="#生成器（generator" class="headerlink" title="生成器（generator)"></a>生成器（generator)</h2><p>生成器我们也在之前的文章当中介绍过，为什么我们介绍协程需要用到生成器呢，是因为Python的<strong>协程底层就是通过生成器来实现的</strong>。</p><p>通过生成器来实现协程的原因也很简单，我们都知道协程需要切换挂起，而生成器当中有一个<strong>yield关键字</strong>，刚好可以实现这个功能。所以当初那些自己在Python当中开发协程功能的程序员都是通过生成器来实现的，我们想要理解Python当中协程的运用，就必须从最原始的生成器开始。</p><p>生成器我们很熟悉了，本质上就是带有yield这个关键词的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">        val = <span class="keyword">yield</span> n </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;val = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(val))</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个函数当中如果没有<code>yield</code>这个语句，那么它就是一个普通的Python函数。加上了<code>val = yield n</code>这个语句之后，它有什么变化呢？</p><p>我们尝试着运行一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用test函数获得一个生成器</span></span><br><span class="line">g = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><p>得到这么一个结果：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghlitiji1mj30hj0340sr.jpg" alt="image-20200810104610713"></p><p>输出的0，1，2很好理解，就是通过next(g)返回的，这个也是生成器的标准用法。奇怪的是为什么<code>val=None</code>呢？val不应该等于n么？</p><p>这里想不明白是正常的，因为这里涉及到了一个新的用法就是<strong>生成器的send方法</strong>。当我们在<code>yield</code>语句之前加上变量名的时候，它的含义其实是返回<code>yield</code>之后的内容，再从外界接收一个变量。也就是说当我们执行<code>next(g)</code>的时候，会从获取<code>yield</code>之后的数，当我们执行<code>g.send()</code>时，传入的值会被赋值给<code>yield</code>之前的数。比如我们把执行的代码改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">g.send(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><p>我们再来看执行的结果，会发现是这样的：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghliwy0798j30ii03iwel.jpg" alt=""></p><p>第一行<code>val</code>不再是<code>None</code>，而是我们刚刚传入的abc了。</p><h2 id="队列调度"><a href="#队列调度" class="headerlink" title="队列调度"></a>队列调度</h2><p>生成器每次在执行到<code>yield</code>语句之后都会自然挂起，我们可以利用这一点来当做协程来调度。我们可以自己实现一个简易的队列来模拟这个过程。</p><p>首先我们声明一个双端队列，<strong>每次从队列左边头部获取任务，调度执行到挂起之后，放入到队列末尾</strong>。相当于我们用循环的方式轮询执行了所有任务，并且这整个全程不涉及任何线程创建和销毁的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_task</span>(<span class="params">self, task</span>):</span><br><span class="line">        self._queue.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> self._queue:</span><br><span class="line">            <span class="comment"># 每次从队列左侧获取task</span></span><br><span class="line">            task = self._queue.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 通过next执行之后放入队列右侧</span></span><br><span class="line">                <span class="built_in">next</span>(task)</span><br><span class="line">                self._queue.append(task)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sch = Scheduler()</span><br><span class="line">sch.new_task(test(<span class="number">5</span>))</span><br><span class="line">sch.new_task(test(<span class="number">10</span>))</span><br><span class="line">sch.new_task(test(<span class="number">8</span>))</span><br><span class="line">sch.run()</span><br></pre></td></tr></table></figure><p>这个只是一个很简易的调度方法，事实上结合上<code>yield from</code>以及<code>send</code>功能，我们还可以实现出更加复杂的协程调度方式。但是我们也没有必要一一穷尽，只需要理解最基础的方法就可以了，毕竟现在我们使用协程一般也不会自己实现了，都会通过官方原生的工具库来实现。</p><h2 id="asyncio-coroutine"><a href="#asyncio-coroutine" class="headerlink" title="@asyncio.coroutine"></a>@asyncio.coroutine</h2><p>在Python3.4之后的版本当中，我们可以通过<code>@asyncio.coroutine</code>这个注解来将一个函数封装成协程执行的生成器。</p><p>在吸收了协程这个概念之后，Python<strong>对生成器以及协程做了区分</strong>。加上了<code>@asyncio.coroutine</code>注解的函数称为<strong>协程函数</strong>，我们可以用<code>iscoroutinefunction()</code>方法来判断一个函数是不是协程函数，通过这个协程函数返回的生成器对象称为<strong>协程对象</strong>，我们可以通过<code>iscoroutine</code>方法来判断一个对象是不是协程对象。</p><p>比如我把刚刚写的函数上加上注解之后再来执行这两个函数都会得到<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(asyncio.iscoroutinefunction(test))</span><br><span class="line"><span class="built_in">print</span>(asyncio.iscoroutine(test(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>那我们通过注解将方法转变成了协程之后，又该怎么使用呢？</p><p>一个比较好的方式是<strong>通过<code>asynio</code>库当中提供的<code>loop</code>工具</strong>，比如我们来看这么一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(test(<span class="number">10</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>我们通过<code>asyncio.get_event_loop</code>函数创建了一个调度器，通过调度器的run相关的方法来执行一个协程对象。我们可以<code>run_until_complete</code>也可以<code>run_forever</code>，具体怎么执行要看我们实际的使用场景。</p><h2 id="async，await和future"><a href="#async，await和future" class="headerlink" title="async，await和future"></a>async，await和future</h2><p>从Python3.5版本开始，引入了<code>async，await</code>和<code>future</code>。我们来简单说说它们各自的用途，其中<code>async</code>其实就是<code>@asyncio.coroutine</code>，用途是完全一样的。同样<code>await</code>代替的是<code>yield from</code>，意为等待另外一个协程结束。</p><p>我们用这两个一改，上面的代码就成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于我们加上了<code>await</code>，所以每次在打印之前都会等待0.5秒。我们<strong>把<code>await</code>换成<code>yield from</code>也是一样的</strong>，只不过用<code>await</code>更加直观也更加贴合协程的含义。</p><p><code>Future</code>其实可以看成是一个信号量，我们创建一个全局的future，当一个协程执行完成之后，将结果存入这个future当中。<strong>其他的协程可以<code>await future</code>来实现阻塞</strong>。我们来看一个例子就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">future = asyncio.Future()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; k:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;n = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    future.set_result(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log</span>():</span><br><span class="line">    result = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait([</span><br><span class="line">    log(),</span><br><span class="line">    test(<span class="number">5</span>)</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>在这个例子当中我们创建了两个协程，第一个协程是每隔0.5秒<code>print</code>一个数字，在<code>print</code>完成之后把success写入到<code>future</code>当中。第二个协程就是等待future当中的数据，之后print出来。</p><p>在loop当中我们要调度执行的不在是一个协程对象了而是两个，所以我们<strong>用<code>asyncio</code>当中的<code>wait</code>将这两个对象包起来</strong>。只有当wait当中的两个对象执行结束，wait才会结束。loop等待的是wait的结束，而wait等待的是传入其中的协程的结束，这就形成了一个依赖循环，等价于这两个协程对象结束，loop才会结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>async</code><strong>并不止是可以用在函数上</strong>，事实上还有很多其他的用法，比如用在with语句上，用在for循环上等等。这些用法比较小众，细节也很多，就不一一展开了，大家感兴趣的可以自行去了解一下。</p><p>不知道大家在读这篇文章的过程当中有没有觉得有些费劲，如果有的话，其实是很正常的。原因也很简单，因为Python原生是不支持协程这个概念的，所以在一开始设计的时候也没有做这方面的准备，是后来觉得有必要才加入的。那么作为后面加入的内容，必然会对原先的很多内容产生影响，尤其是协程借助了之前生成器的概念来实现的，那么必然会有很多耦合不清楚的情况。这也是这一块的语法很乱，对初学者不友好的原因。</p><p>我建议大家可以<strong>先了解一下go语言当中的协程的概念和用法</strong>再来学习Python当中的async的用法，很多不明白的地方会清晰很多。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中死锁问题巧妙解决办法</title>
      <link href="/2023/04/18/multi-thread-4/"/>
      <url>/2023/04/18/multi-thread-4/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，我们一起来聊聊多线程开发当中死锁的问题。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的原理非常简单，用一句话就可以描述完。就是当多线程访问多个锁的时候，<strong>不同的锁被不同的线程持有</strong>，它们都在等待其他线程释放出锁来，于是便陷入了永久等待。比如A线程持有1号锁，等待2号锁，B线程持有2号锁等待1号锁，那么它们永远也等不到执行的那天，这种情况就叫做死锁。</p><p>关于死锁有一个著名的问题叫做<strong>哲学家就餐</strong>问题，有5个哲学家围坐在一起，他们每个人需要拿到两个叉子才可以吃饭。如果他们同时拿起自己左手边的叉子，那么就会永远等待右手边的叉子释放出来。这样就陷入了永久等待，于是这些哲学家都会饿死。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghdbrswecrj30sg0tie4y.jpg" alt="img"></p><p>这是一个很形象的模型，因为在计算机并发场景当中，一些<strong>资源的数量往往是有限的</strong>。很有可能出现多个线程抢占的情况，如果处理不好就会发生大家都获取了一部分资源，然后在等待另外的资源的情况。</p><p>对于死锁的问题有多种解决方法，这里我们介绍比较简单的一种，就是对这些锁进行编号。我们规定当一个线程需要同时持有多个锁的时候，<strong>必须要按照序号升序的顺序对这些锁进行访问</strong>。通过上下文管理器我们可以很容易实现这一点。</p><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>首先我们来简单介绍一下上下文管理器，上下文管理器我们其实经常使用，比如我们经常使用的<strong>with语句</strong>就是一个上下文管理器的经典使用。当我们通过<code>with</code>语句打开文件的时候，它会自动替我们处理好文件读取之后的关闭以及抛出异常的处理，可以节约我们大量的代码。</p><p>同样我们也可以自己定义一个上下文处理器，其实很简单，我们只需要实现<code>__enter__</code>和<code>__exit__</code>这两个函数即可。<code>__enter__</code>函数用来实现进入资源之前的操作和处理，那么显然<code>__exit__</code>函数对应的就是使用资源结束之后或者是出现异常的处理逻辑。有了这两个函数之后，我们就有了自己的上下文处理类了。</p><p>我们来看一个样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter resources&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(exc_type)</span></span><br><span class="line">        <span class="comment"># print(exc_val)</span></span><br><span class="line">        <span class="comment"># print(exc_tb)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doSomething</span>(<span class="params">self</span>):</span><br><span class="line">        a = <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSample</span>():</span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> getSample() <span class="keyword">as</span> sample:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>)</span><br><span class="line">        sample.doSomething()</span><br></pre></td></tr></table></figure><p>当我们运行这段代码的时候，屏幕上打印的结果和我们的预期是一致的。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ghdcveh1o3j30mr025aa5.jpg" alt="image-20200803091558632"></p><p>我们观察一下<code>__exit__</code>函数，会发现它的参数有4个，<strong>后面的三个参数对应的是抛出异常的情况</strong>。<code>type</code>对应异常的类型，<code>val</code>对应异常时的输出值，<code>trace</code>对应异常抛出时的运行堆栈。这些信息都是我们排查异常的时候经常需要用到的信息，通过这三个字段，我们可以根据我们的需要对可能出现的异常进行自定义的处理。</p><p>实现上下文管理器并不一定要通过类实现，Python当中也提供了上下文管理的注解，通过使用注解我们可以很方便地实现上下文管理。我们同样也来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timethis</span>(<span class="params">label</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(label, end - start))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> timethis(<span class="string">&#x27;timer&#x27;</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这个方法当中yield之前的部分相当于<code>__enter__</code>函数，<code>yield</code>之后的部分相当于<code>__exit__</code>。如果出现异常会在try语句当中抛出，那么我们编写except对异常进行处理即可。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>了解了上下文管理器之后，我们要做的就是<strong>在lock的外面包装一层</strong>，使得我们在获取和释放锁的时候可以根据我们的需要，对锁进行排序，按照升序的顺序进行持有。</p><p>这段代码源于Python的著名进阶书籍《Python cookbook》，非常经典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储local的数据</span></span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire</span>(<span class="params">*locks</span>):</span><br><span class="line"><span class="comment"># 对锁按照id进行排序</span></span><br><span class="line">    locks = <span class="built_in">sorted</span>(locks, key=<span class="keyword">lambda</span> x: <span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果已经持有锁当中的序号有比当前更大的，说明策略失败</span></span><br><span class="line">    acquired = <span class="built_in">getattr</span>(_local,<span class="string">&#x27;acquired&#x27;</span>,[])</span><br><span class="line">    <span class="keyword">if</span> acquired <span class="keyword">and</span> <span class="built_in">max</span>(<span class="built_in">id</span>(lock) <span class="keyword">for</span> lock <span class="keyword">in</span> acquired) &gt;= <span class="built_in">id</span>(locks[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Lock Order Violation&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有锁</span></span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 倒叙释放</span></span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> <span class="built_in">reversed</span>(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">del</span> acquired[-<span class="built_in">len</span>(locks):]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码写得非常漂亮，可读性很高，逻辑我们都应该能看懂，但是有一个小问题是这里用到了<strong><code>threading.local</code></strong>这个组件。</p><p>它是一个多线程场景当中的<strong>共享变量</strong>，虽然说是共享的，但是对于每个线程来说读取到的值都是独立的。听起来有些难以理解，其实我们可以将它理解成一个<code>dict</code>，<code>dict</code>的key是每一个线程的id，value是一个存储数据的dict。每个线程在访问local变量的时候，都相当于先通过线程id获取了一个独立的dict，再对这个dict进行的操作。</p><p>看起来我们在使用的时候直接使用了<code>_local</code>，这是因为通过线程id先进行查询的步骤在其中封装了。不明就里的话可能会觉得有些难以理解。</p><p>我们再来看下这个acquire的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(x_lock, y_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(y_lock, x_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>运行一下会发现没有出现死锁的情况，但如果我们把代码稍加调整，写成这样，那么就会触发异常了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">thread_1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">            <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">            <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为我们把锁写成了层次结构，这样就没办法进行排序保证持有的有序性了，那么就会触发我们代码当中定义的异常。</p><p>最后我们再来看下哲学家就餐问题，通过我们自己实现的acquire函数我们可以非常方便地解决他们死锁吃不了饭的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">philosopher</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> acquire(left, right):</span><br><span class="line">             <span class="built_in">print</span>(threading.currentThread(), <span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叉子的数量</span></span><br><span class="line">NSTICKS = <span class="number">5</span></span><br><span class="line">chopsticks = [threading.Lock() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(NSTICKS)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(NSTICKS):</span><br><span class="line">    t = threading.Thread(target=philosopher,</span><br><span class="line">                         args=(chopsticks[n],chopsticks[(n+<span class="number">1</span>) % NSTICKS]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于死锁的问题，对锁进行排序<strong>只是其中的一种解决方案</strong>，除此之外还有很多解决死锁的模型。比如我们可以让线程在尝试持有新的锁失败的时候主动放弃所有目前已经持有的锁，比如我们可以设置机制检测死锁的发生并对其进行处理等等。发散出去其实有很多种方法，这些方法起作用的原理各不相同，其中涉及大量操作系统的基础概念和知识，感兴趣的同学可以深入研究一下这个部分，一定会对操作系统以及锁的使用有一个深刻的认识。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中并发与锁</title>
      <link href="/2023/04/18/multi-thread-3/"/>
      <url>/2023/04/18/multi-thread-3/</url>
      
        <content type="html"><![CDATA[<p>这篇我们一起来聊聊多线程场景当中不可或缺的另外一个部分——<strong>锁</strong>。</p><p>如果你学过操作系统，那么对于锁应该不陌生。锁的含义是线程锁，可以用来指定某一个逻辑或者是资源<strong>同一时刻只能有一个线程访问</strong>。这个很好理解，就好像是有一个房间被一把锁锁住了，只有拿到钥匙的人才能进入。每一个人从房间门口拿到钥匙进入房间，出房间的时候会把钥匙再放回到门口。这样下一个到门口的人就可以拿到钥匙了。这里的房间就是某一个资源或者是一段逻辑，而拿取钥匙的人其实指的是一个线程。</p><h2 id="加锁的原因"><a href="#加锁的原因" class="headerlink" title="加锁的原因"></a>加锁的原因</h2><p>我们明白了锁的原理，不禁有了一个问题，我们为什么需要锁呢，它在哪些场景当中会用到呢？</p><p>其实它的使用场景非常广，我们举一个非常简单的例子，就是淘宝买东西。我们都知道商家的库存都是有限的，卖掉一个少一个。假如说当前某个商品库存只剩下一个，但当下却有两个人同时购买。两个人同时购买也就是有两个请求同时发起购买请求，如果我们不加锁的话，两个线程同时查询到商品的库存是1，大于0，进行购买逻辑之后，减一。由于两个线程同时执行，所以最后商品的库存会变成-1。</p><p>显然商品的库存不应该是一个负数，所以我们需要避免这种情况发生。通过<strong>加锁</strong>可以完美解决这个问题。我们规定一次只能有一个线程发起购买的请求，那么这样当一个线程将库存减到0的时候，第二个请求就无法修改了，就保证了数据的准确性。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>那么在Python当中，我们怎么样来实现这个锁呢？</p><p>其实很简单，<code>threading</code>库当中已经为我们提供了现成的工具，我们直接拿过来用就可以了。我们通过使用<code>threading</code>当中的<code>Lock</code>对象， 可以很轻易的实现方法加锁的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        self._value += delta</span><br><span class="line">        self._lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        self._value -= delta</span><br><span class="line">        self._lock.release()</span><br></pre></td></tr></table></figure><p>我们从代码当中就可以很轻易的看出<code>Lock</code>这个对象的使用方法，我们在进入<strong>加锁区</strong>（资源抢占区）之前，我们需要先使用<code>lock.acquire()</code>方法获取锁。<code>Lock</code>对象可以保证同一时刻只能有一个线程获取锁，只有获取了锁之后才会继续往下执行。当我们执行完成之后，我们需要把锁“放回门口”，所以需要再调用一下<code>release</code>方法，表示锁的释放。</p><p>这里有一个小问题是很多程序员在编程的时候总是会<strong>忘记<code>release</code>，导致不必要的bug</strong>，而且这种分布式场景当中的bug很难通过测试发现。因为测试的时候往往很难测试并发场景，code review的时候也很容易忽略，因此一旦泄露了还是挺难发现的。</p><p>为了解决这个问题，<code>Lock</code>还提供了一种改进的用法，就是<strong>使用with语句</strong>。with语句我们之前在使用文件的时候用到过，使用with可以替我们完成try catch以及资源回收等工作，我们只管用就完事了。这里也是一样，使用<code>with</code>之后我们就可以不用管锁的申请和释放了，直接写代码就行，所以上面的代码可以改写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> self._lock:</span><br><span class="line">        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">        self._value -= delta</span><br></pre></td></tr></table></figure><p>这样看起来是不是清爽很多？</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>上面介绍的只是最简单的锁，我们经常使用的往往是<strong>可重入锁</strong>。</p><p>什么叫可重入锁呢？简单解释一下，就是在一个线程已经持有了锁的情况下，它可以再次进入被加锁的区域。但是既然线程还持有锁没有释放，那么它不应该还是在加锁区域吗，怎么会有需要再次进入被加锁区域的情况呢？其实是有的，<strong>道理也很简单，就是递归</strong>。</p><p>我们把上面的例子稍微改一点点，就完全不一样了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> self._lock:</span><br><span class="line">        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">        self.incr(-delta)</span><br></pre></td></tr></table></figure><p>我们关注一下上面的<code>decr</code>方法，我们用<code>incr</code>来代替了原本的逻辑实现了<code>decr</code>。但是有一个问题是decr也是一个加锁的方法，需要前一个锁释放了才能进入。但它已经持有了锁了，那么这种情况下就会发生<strong>死锁</strong>。</p><p>我们只需要把Lock换成可重入锁就可以解决这个问题，只需要修改一行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化库存与锁</span></span><br><span class="line"><span class="string">    我们使用RLock代替了Lock，也可重入锁代替了普通锁</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_value = <span class="number">0</span></span>):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._lock = threading.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       加库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> self._lock:</span><br><span class="line">        self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self,delta=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减库存</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">        self.incr(-delta)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们的文章介绍了Python当中锁的使用方法，以及可重入锁的概念。在并发场景下开发和调试都是一个比较困难的工作，稍微不小心就会踩到各种各样的坑，<strong>死锁只是其中一种比较常见并且比较容易解决的问题</strong>，除此之外还有很多其他各种各样的问题。</p><p>针对死锁的问题，Python还提供了其他的解决方案，我们放到下一篇文章当中再和大家分享。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中生产者、消费者模式</title>
      <link href="/2023/04/18/multi-thread-2/"/>
      <url>/2023/04/18/multi-thread-2/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，我们来聊聊关于多线程的一个经典<strong>设计模式</strong>。</p><p>在之前的文章当中我们曾经说道，在多线程并发的场景当中，如果我们需要感知线程之间的状态，交换线程之间的信息是一件非常复杂和困难的事情。因为我们没有更高级的系统权限，也没有上帝视角，很难知道目前运行的状态的全貌，所以想要设计出一个稳健运行没有<code>bug</code>的功能，不仅非常困难，而且调试起来非常麻烦。</p><h2 id="生产消费者模式"><a href="#生产消费者模式" class="headerlink" title="生产消费者模式"></a>生产消费者模式</h2><p>在日常开发当中，<strong>从一个线程向另外的线程传输数据又是一件家常便饭的事情</strong>。举个最简单的例子，我们在处理网页请求的时候，需要打印下来这一次请求的相关日志。打印日志是一次<code>IO</code>行为，这是非常消耗时间的，所以我们不能放在请求当中同步进行，否则会影响系统的性能。最好的办法就是启动一系列线程专门负责打印，后端的线程只负责响应请求，相关的日志以消息的形式传送给打印线程打印。</p><p>这个简单的不能再简单的功能当中涉及了诸多细节，我们来盘点几个。首先<code>IO</code>线程的数据都是从后台线程来的，假如一段时间内没有请求，那么这些线程都应该休眠，应该在有请求的时候才会启动。其次，如果某一段时间内请求非常多，导致<code>IO</code>线程一时间来不及打印所有的数据，那么当下的请求应该先暂存起来，等<code>IO</code>线程”忙过来“之后再进行处理。</p><p>把这些细节都考虑到，自己来设计功能还是挺麻烦的。好在这个问题前人已经替我们想过了，并且得出了一个非常经典的设计模式，使用它可以很好的解决这个问题。这个模式就是<strong>生产消费者模式</strong>。</p><p>这个设计模式的原理其实非常简单，我们来看张图就明白了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggx4r053p3j30vq092aaq.jpg" alt=""></p><p>线程根据和数据的关系分为<strong>生产者线程和消费者线程</strong>，其中生产者线程负责生产数据，产生了数据之后会存储到任务队列当中。消费者线程从这个队列获取需要消费的数据，它和生产者线程之间不会直接交互，避免了线程之间互相依赖的问题。</p><p>另外一个细节是这里的任务队列并不是普通的队列，一般情况下是一个<strong>阻塞队列</strong>。也就是说当消费者线程尝试从其中获取数据的时候，如果队列是空的，那么这些消费者线程会自动挂起等待，直到它获得了数据为止。有阻塞队列当然也有非阻塞队列，如果是非阻塞队列的话，当我们尝试从其中获取数据的时候，如果它当中没有数据的话，并不会挂起等待，而是会返回一个空值。</p><p>当然阻塞队列的挂起等待时间也是可以设置的，我们可以让它一直等待下去，也可以设置一个<strong>最长等待时间</strong>。如果超过这个时间也会返回空，不同的队列应用在不同的场景当中，我们需要根据场景性质做出调整。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>看完了设计模式的原理，我们下面来试着用代码来实现一下。</p><p>在一般的高级语言当中都有现成的队列的库，由于在生产消费者模式当中用到的是阻塞型<code>queue</code>，有阻塞性的队列当然也就有非阻塞型的队列。我们在用之前需要先了解清楚，如果用错了队列会导致整个程序出现问题。在Python当中，我们最常用的<code>queue</code>就是一个<strong>支持多线程场景的阻塞队列</strong>，所以我们直接拿来用就好了。</p><p>由于这个设计模式非常简单，这个代码并不长只有几行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">que = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(que, ))</span><br><span class="line">t2 = Thread(target=producer, args=(que, ))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>我们运行一下就会发现它是可行的，并且由于队列<strong>先进先出</strong>的限制，可以保证了<code>consumer</code>线程读取到的内容的<strong>顺序和<code>producer</code>生产的顺序是一致的</strong>。</p><p>如果我们运行一下这个代码会发现它是不会结束的，因为<code>consumer</code>和<code>producer</code>当中都用到了<code>while True</code>构建的死循环，假设我们希望可以控制程序的结束，应该怎么办？</p><p>其实也很简单，我们也可以利用队列。我们创建一个特殊的信号量，约定好当<code>consumer</code>接受到这个特殊值的时候就停止程序。这样当我们要结束程序的时候，我们只需要把这个信号量加入队列即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">singal = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> data &lt; <span class="number">20</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">    que.put(singal)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> singal:</span><br><span class="line">            <span class="comment"># 继续插入singal</span></span><br><span class="line">            que.put(singal)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><p>这里有一个细节是我们在<code>consumer</code>当中，当读取到<code>singal</code>的时候，在跳出循环之前我们又把<code>singal</code>放回了队列。原因也很简单，因为有时候<code>consumer</code>线程不止一个，这个<code>singal</code>上游<strong>只放置了一个，只会被一个线程读取进来</strong>，其他线程并不会知道已经获得了<code>singal</code>的消息，所以还是会继续执行。</p><p>而当<code>consumer</code>关闭之前放入<code>singal</code>就可以保证每一个<code>consumer</code>在关闭的之前都会再传递一个结束的信号给其他未关闭的<code>consumer</code>读取。这样一个一个的传递，就可以保证所有<code>consumer</code>都关闭。</p><p>这里还有一个小细节，虽然利用队列可以解决生产者和消费者通信的问题，但是上游的生产者并不知道下游的消费者是否已经执行完成了。假如我们想要知道，应该怎么办？</p><p>Python的设计者们也考虑到了这个问题，所以他们在<code>Queue</code>这个类当中加入了<strong><code>task_done</code>和<code>join</code>方法</strong>。利用<code>task_done</code>，消费者可以通知<code>queue</code>这一个任务已经执行完成了。而通过调用<code>join</code>，可以等待所有的<code>consumer</code>完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">que</span>):</span><br><span class="line">    data = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> data &lt; <span class="number">20</span>:</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line">        que.put(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = que.get()</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        que.task_done()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">que = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(que, ))</span><br><span class="line">t2 = Thread(target=producer, args=(que, ))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">que.join()</span><br></pre></td></tr></table></figure><p>除了使用<code>task_done</code>之外，我们还可以在<code>que</code>传递的消息当中加入一个Event，这样我们还可以继续感知到每一个Event执行的情况。</p><h2 id="优先队列与其他设置"><a href="#优先队列与其他设置" class="headerlink" title="优先队列与其他设置"></a>优先队列与其他设置</h2><p>我们之前在介绍一些分布式调度系统的时候曾经说到过，在调度系统当中，调度者会用一个优先队列来管理所有的任务。当有机器空闲的时候，会有限调度那些优先级高的任务。</p><p>其实这个调度系统也是基于我们刚才介绍的生产消费者模型开发的，只不过<strong>将调度队列从普通队列换成了优先队列</strong>而已。所以如果我们也希望我们的<code>consumer</code>能够根据任务的优先级来改变执行顺序的话，也可以使用优先队列来进行管理任务。</p><p>关于优先队列的实现我们已经很熟悉了，但是有一个问题是我们需要实现挂起等待的阻塞功能。这个我们自己实现是比较麻烦的，但好在我们可以通过调用相关的库来实现。比如<code>threading</code>中的<code>Condition</code>，<strong><code>Condition</code>是一个条件变量可以通知其他线程，也可以实现挂起等待</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._cv = Condition()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            <span class="comment"># 通知下游，唤醒wait状态的线程</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="comment"># 如果对列为空则挂起</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="comment"># 否则返回优先级最大的</span></span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>最后介绍一下<code>Queue</code>的其他设置，比如我们可以<strong>通过size参数设置队列的大小</strong>，由于这是一个阻塞式队列，所以如果我们设置了队列的大小，那么当队列被装满的时候，往其中插入数据的操作也会被阻塞。此时<code>producer</code>线程会被挂起，一直到队列不再满为止。</p><p>当然我们也可以通过<code>block</code>参数<strong>将队列的操作设置成非阻塞</strong>。比如<code>que.get(block=False)</code>，那么当队列为空的时候，将会抛出一个队列为空的异常。同样，<code>que.put(data, block=False)</code>时也一样会得到一个队列已满的异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章当中我们主要介绍了多线程场景中经典的生产消费者模式，这个模式在许多场景当中都有使用。比如kafka等消息系统，以及yarn等调度系统等等，几乎只要是涉及到多线程上下游通信的，往往都会用到。也正因此它的使用场景太广了，所以它<strong>经常在各种面试当中出现</strong>，也可以认为是工程师必须知道的几种基础设计模式之一。</p><p>另外，队列也是一个在设计模式以及使用场景当中经常出现的数据结构。从侧面也说明了，为什么算法和数据结构非常重要，许多大公司喜欢问一些算法题，也是因为<strong>有实际的使用场景</strong>，并且的的确确能锻炼工程师的思维能力。经常有同学问我算法和数据结构的使用案例，这就是一个很好的例子。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python通过Event与信号量感知线程状态</title>
      <link href="/2023/04/18/multi-thread-1/"/>
      <url>/2023/04/18/multi-thread-1/</url>
      
        <content type="html"><![CDATA[<p>今天这篇文章我们继续多线程的话题。</p><p>上篇文章当中我们简单介绍了线程和进程的概念，以及在Python当中如何在主线程之外创建其他线程，并且还了解了<strong>用户级线程和后台线程</strong>的区别以及使用方法。今天我们来看看线程的其他使用，比如如何停止一个线程，线程之间的Event用法等等。</p><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>利用<code>Threading</code>库我们可以很方便地创建线程，让它按照我们的想法执行我们想让它执行的事情，从而加快程序运行的效率。然而有一点坑爹的是，线程创建之后，就交给了操作系统执行，<strong>我们无法直接结束一个线程，也无法给它发送信号，无法调整它的调度</strong>，也没有其他高级操作。如果想要相关的功能，只能自己开发。</p><p>怎么开发呢？</p><p>我们创建线程的时候指定了<code>target</code>等于一个我们想让它执行的函数，<strong>这个函数并不一定是全局函数，实际上也可以是一个对象中的函数</strong>。如果是对象中的函数，那么我们就可以在这个函数当中获取到对象中的其他信息，我们可以利用这一点来实现手动控制线程的停止。</p><p>说起来好像不太好理解，但是看下代码真的非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWithSwitch</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Running &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = TaskWithSwitch()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>, ))</span><br><span class="line">t.start()</span><br><span class="line">c.terminate()</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>如果你运行这段代码，会发现屏幕上只输出了10，因为我们将<code>_running</code>这个字段置为<code>False</code>之后，下次循环的时候不再满足循环条件，它就会自己退出了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggh3b5y6tmj30mx011mx6.jpg" alt=""></p><p>如果我们想要用多线程来读取<code>IO</code>，由于<strong>IO可能存在堵塞</strong>，所以可能会出现线程一直无法返回的情况。也就是说我们在循环内部卡死了，这个时候单纯用<code>_running</code>来判断还是不够的，我们需要<strong>在线程内部设置计时器</strong>，防止循环内部的卡死。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, sock</span>):</span><br><span class="line">        <span class="comment"># 在socket中设置计时器</span></span><br><span class="line">        sock.settimeout(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span> self._running:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 由于设置了计时器，所以这里不会永久等待</span></span><br><span class="line">                data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="线程信号的传递"><a href="#线程信号的传递" class="headerlink" title="线程信号的传递"></a>线程信号的传递</h2><p>我们之所以如此费劲才能控制线程的运行，主要原因是<strong>线程的状态是不可知的</strong>，并且我们无法直接操作它，因为它是被操作系统管理的。我们运行的主线程和创建出来的线程是独立的，两者之间并没有从属关系，所以想要实现对线程的状态进行控制，往往需要我们通过其他手段来实现。</p><p>我们来思考一个场景，假设我们有一个任务，需要在另外一个线程运行结束之后才能开始执行。要想要实现这一点，就<strong>必须对线程的状态有所感知</strong>，需要其他线程传递出信号来才行。我们可以使用<code>threading</code>中的<code>Event</code>工具来实现这一点。<code>Event</code>工具就是可以用来传递信号的，就好像是一个开关，当一个线程执行完成之后，会去启动这个开关。而这个开关控制着另外一段逻辑的运行。</p><p>我们来看下样例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_in_thread</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thread is running&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Thread(target=run_in_thread)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Main thread print&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在线程里面就只做了输出一行提示符，没有其他任何逻辑。由于我们在<code>run_in_thread</code>函数当中沉睡了<code>1s</code>，所以一定是先输出<code>Main thread print</code>再输出的<code>Thread is running</code>。假设这个线程是一个很重要的任务，我们希望主线程能够等待它运行到一个阶段再往下执行，我们应该怎么办呢？</p><p>注意，<strong>这里说的是运行到一个阶段，并不是运行结束</strong>。运行结束我们很好处理，可以通过<code>join</code>来完成。但如果不是运行结束，而是运行完成了某一个阶段，当然通过<code>join</code>也可以，但是会损害整体的效率。这个时候我们就必须要用上<code>Event</code>了。加上<code>Event</code>之后，我们再来看下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_in_thread</span>(<span class="params">event</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thread is running&#x27;</span>)</span><br><span class="line">    <span class="comment"># set一下event，这样外面wait的部分就会被启动</span></span><br><span class="line">    event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Event</span></span><br><span class="line">event = Event()</span><br><span class="line">t = Thread(target=run_in_thread, args=(event, ))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># event等待set</span></span><br><span class="line">event.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Main thread print&#x27;</span>)</span><br></pre></td></tr></table></figure><p>整体的逻辑没有太多的修改，主要的是增加了几行关于<code>Event</code>的使用代码。</p><p>我们<strong>如果要用到<code>Event</code>，最好在代码当中只使用一次</strong>。当然通过<code>Event</code>中的<code>clear</code>方法我们可以重置<code>Event</code>的值，但问题是我们没办法保证重置的这个逻辑会在<code>wait</code>之前执行。如果是在之后执行的，那么就会问题，并且在<code>debug</code>的时候会异常痛苦，因为<code>bug</code>不是必现的，而是有时候会出现有时候不会出现。这种情况往往都是因为多线程的使用问题。</p><p>所以如果要多次使用开关和信号的话，不要使用<code>Event</code>，可以使用信号量。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><code>Event</code>的问题在于如果多个线程在等待<code>Event</code>的发生，当它一旦被<code>set</code>的时候，那么这些线程都会同时执行。但有时候我们并不希望这样，我们<strong>希望可以控制这些线程一个一个地运行</strong>。如果想要做到这一点，<code>Event</code>就无法满足了，而需要使用信号量。</p><p>信号量和<code>Event</code>的使用方法类似，不同的是，<strong>信号量可以保证每次只会启动一个线程</strong>。因为这两者的底层逻辑不太一致，对于<code>Event</code>来说，它更像是一个开关。一旦开关启动，所有和这个开关关联的逻辑都会同时执行。而信号量则像是许可证，只有拿到许可证的线程才能执行工作，并且许可证一次只发一张。</p><p>想要使用信号量并不需要自己开发，<code>thread</code>库当中为我们提供了现成的工具——<code>Semaphore</code>，我们来看它的使用代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作线程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n, sema</span>):</span><br><span class="line">    <span class="comment"># 等待信号量</span></span><br><span class="line">    sema.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working&#x27;</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">sema = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line">nworkers = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(nworkers):</span><br><span class="line">    t = threading.Thread(target=worker, args=(n, sema,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>在上面的代码当中我们创建了10个线程，虽然这些线程都被启动了，但是都不会执行逻辑，因为<strong><code>sema.acquire</code>是一个阻塞方法</strong>，没有监听到信号量是会一直挂起等待。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggh3b57xvoj30ga03kdfq.jpg" alt=""></p><p>当我们释放信号量之后，线程被启动，才开始了执行。我们每释放一个信号，则会多启动一个线程。这里面的逻辑应该不难理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发场景当中，多线程的使用<strong>绝不是多启动几个线程做不同的任务</strong>而已，我们需要线程间协作，需要同步、获取它们的状态，这是非常不容易的。一不小心就会出现幽灵<code>bug</code>，时显时隐，这也是并发问题让人头疼的主要原因。</p><p>这篇文章当中我们只是简单介绍了线程间通信的基本方法，针对这个问题，<strong>还有更好的解决方案</strong>。我们将在后续的文章当中继续讨论这个问题，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程与多进程入门</title>
      <link href="/2023/04/18/multi-thread/"/>
      <url>/2023/04/18/multi-thread/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来聊聊Python当中的多线程。</p><p>其实关于元类还有很多种用法，比如说如何在元类当中设置参数啦，以及一些规约的用法等等。只不过这些用法比较小众，使用频率非常低，所以我们<strong>不过多阐述</strong>了，可以在用到的时候再去详细了解。我想只要大家理解了元类的原理以及使用方法，再去学习那些具体的用法应该会很容易。所以我们今天开始了一个新的话题——<strong>多线程和并发</strong>。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>为了照顾小白，我们来简单聊聊<strong>进程和线程</strong>这两个概念。这两个概念属于操作系统，我们经常听说，但是可能很少有人会细究它们的含义。对于工程师而言，两者的定义和区别还是很有必要了解清楚的。</p><p>首先说进程，进程可以看成是<strong>CPU执行的具体的任务</strong>。在操作系统当中，由于CPU的运行速度非常快，要比计算机当中的其他设备要快得多。比如内存、磁盘等等，所以如果CPU一次只执行一个任务，那么会导致CPU大量时间在等待这些设备，这样操作效率很低。为了提升计算机的运行效率，把机器的机能尽可能压榨出来，CPU是轮询工作的。也就是说<strong>它一次只执行一个任务，执行一小段碎片时间之后立即切换</strong>，去执行其他任务。</p><p>所以在早期的单核机器的时候，看起来电脑也是并发工作的。我们可以一边听歌一边上网，也不会觉得卡顿。但实际上，这是CPU轮询的结果。在这个例子当中，听歌的软件和上网的软件对于CPU而言都是<strong>独立的进程</strong>。我们可以把进程简单地理解成运行的应用，比如在安卓手机里面，一个app启动的时候就会对应系统中的一个进程。当然这种说法不完全准确，<strong>一个应用也是可以启动多个进程的</strong>。</p><p>进程是对应CPU而言的，线程则更多针对的是程序。即使是CPU在执行当前进程的时候，程序运行的任务其实也是有分工的。举个例子，比如听歌软件当中，我们需要显示歌词的字幕，需要播放声音，需要监听用户的行为，比如是否发生了切歌、调节音量等等。所以，我们需要<strong>进一步拆分CPU的工作</strong>，让它在执行当前进程的时候，继续通过轮询的方式来同时做多件事情。</p><p>进程中的任务就是线程，所以从这点上来说，<strong>进程和线程是包含关系</strong>。一个进程当中可以包含多个线程，对于CPU而言，不能直接执行线程，一个线程一定属于一个进程。所以我们知道，CPU进程切换切换的是执行的应用程序或者是软件，而进程内部的线程切换，切换的是软件当中具体的执行任务。</p><p>关于进程和线程有一个经典的模型可以说明它们之间的关系，假设CPU是一家工厂，工厂当中有多个车间。不同的车间对应不同的生产任务，有的车间生产汽车轮胎，有的车间生产汽车骨架。但是工厂的电力是有限的，同时只能满足一个厂房的使用。</p><p>为了让大家的进度协调，所以工厂个需要轮流提供各个车间的供电。<strong>这里的车间对应的就是进程</strong>。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo2io5qj30ex0c8gm2.jpg" alt=""></p><p>一个车间虽然只生产一种产品，但是其中的工序却不止一个。一个车间可能会有好几条流水线，具体的生产任务其实是流水线完成的，每一条流水线对应一个具体执行的任务。但是同样的，<strong>车间同一时刻也只能执行一条流水线</strong>，所以我们需要车间在这些流水线之间切换供电，让各个流水线生产进度统一。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo4w3r3j30go0ivwgb.jpg" alt=""></p><p>这里车间里的<strong>流水线自然对应的就是线程的概念</strong>，这个模型很好地诠释了CPU、进程和线程之间的关系。实际的原理也的确如此，不过CPU中的情况要比现实中的车间复杂得多。因为对于进程和CPU来说，它们面临的局面都是实时变化的。车间当中的流水线是x个，下一刻可能就成了y个。</p><p>了解完了线程和进程的概念之后，对于理解电脑的配置也有帮助。比如我们买电脑，经常会碰到一个术语，就是这个电脑的CPU是某某核某某线程的。比如我当年买的第一台笔记本是4核8线程的，这其实是在说这台电脑的CPU有<strong>4个计算核心</strong>，但是使用了超线程技术，使得可以把一个物理核心模拟成两个逻辑核心。相当于我们可以用4个核心同时执行8个线程，相当于8个核心同时执行，但其实有4个核心是模拟出来的虚拟核心。</p><p>有一个问题是<strong>为什么是4核8线程而不是4核8进程呢</strong>？因为CPU并不会直接执行进程，而是执行的是进程当中的某一个线程。就好像车间并不能直接生产零件，只有流水线才能生产零件。车间负责的更多是资源的调配，所以教科书里有一句非常经典的话来诠释：<strong>进程是资源分配的最小单元，线程是CPU调度的最小单元</strong>。</p><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>Python当中为我们提供了完善的<code>threading</code>库，通过它，我们可以非常方便地创建线程来执行多线程。</p><p>首先，我们引入<code>threading</code>中的<code>Thread</code>，这是一个线程的类，我们可以通过创建一个线程的实例来执行多线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=func, name=<span class="string">&#x27;therad&#x27;</span>, args=(x, y))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>简单解释一下它的用法，我们传入了三个参数，分别是<strong>target，name和args</strong>，从名字上我们就可以猜测出它们的含义。首先是<code>target</code>，它传入的是一个方法，也就是我们希望多线程执行的方法。<code>name</code>是我们为这个新创建的线程起的名字，这个参数可以省略，如果省略的话，系统会为它起一个系统名。当我们执行Python的时候启动的线程名叫<code>MainThread</code>，通过线程的名字我们可以做区分。<code>args</code>是会传递给<code>target</code>这个函数的参数。</p><p>我们来举个经典的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span>, args=(<span class="number">10</span>, ))</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>我们创建了一个非常简单的<code>loop</code>函数，用来执行一个循环来打印数字，我们每次打印一个数字之后这个线程会睡眠5秒钟，所以我们看到的结果应该是每过5秒钟屏幕上多出一行数字。</p><p>我们在Jupyter里执行一下：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo2yndaj30ii06pq3c.jpg" alt=""></p><p>表面上看这个结果没毛病，但是其实有一个问题，什么问题呢？<strong>输出的顺序不太对</strong>，为什么我们在打印了第一个数字0之后，主线程就结束了呢？另外一个问题是，既然主线程已经结束了，<strong>为什么Python进程没有结束</strong>， 还在向外打印结果呢？</p><p>因为线程之间是独立的，对于主线程而言，它在执行了<code>t.start()</code>之后，并<strong>不会停留，而是会一直往下执行一直到结束</strong>。如果我们不希望主线程在这个时候结束，而是阻塞等待子线程运行结束之后再继续运行，我们可以在代码当中加上<code>t.join()</code>这一行来实现这点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p><code>join</code>操作可以让主线程在<code>join</code>处挂起等待，直到子线程执行结束之后，再继续往下执行。我们加上了<code>join</code>之后的运行结果是这样的：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8wz0n5r7j30ha06q3z2.jpg" alt=""></p><p>这个就是我们预期的样子了，等待子线程执行结束之后再继续。</p><p>我们再来看第二个问题，为什么主线程结束的时候，子线程还在继续运行，Python进程没有退出呢？这是因为默认情况下我们创建的都是用户级线程，对于进程而言，<strong>会等待所有用户级线程执行结束之后才退出</strong>。这里就有了一个问题，那假如我们创建了一个线程尝试从一个接口当中获取数据，由于接口一直没有返回，当前进程岂不是会永远等待下去？</p><p>这显然是不合理的，所以为了解决这个问题，我们可以把创建出来的线程设置成<strong>守护线程</strong>。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程即<code>daemon</code>线程，它的英文直译其实是后台驻留程序，所以我们也可以理解成<strong>后台线程</strong>，这样更方便理解。<code>daemon</code>线程和用户线程级别不同，进程不会主动等待<code>daemon</code>线程的执行，<strong>当所有用户级线程执行结束之后即会退出。进程退出时会kill掉所有守护线程</strong>。</p><p>我们传入<code>daemon=True</code>参数来将创建出来的线程设置成后台线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span>, args=(<span class="number">10</span>, ), daemon=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>这样我们再执行看到的结果就是这样了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo1oitwj30jc024q2w.jpg" alt=""></p><p>这里有一点需要注意，如果你<strong>在jupyter当中运行是看不到这样的结果的</strong>。因为<code>jupyter</code>自身是一个进程，对于<code>jupyter</code>当中的cell而言，它一直是有用户级线程存活的，所以进程不会退出。所以想要看到这样的效果，只能通过命令行执行Python文件。</p><p>如果我们想要等待这个子线程结束，就必须通过<code>join</code>方法。另外，为了预防子线程锁死一直无法退出的情况， 我们还可以<strong>在<code>join</code>当中设置timeout</strong>，即最长等待时间，当等待时间到达之后，将不再等待。</p><p>比如我在<code>join</code>当中设置的<code>timeout</code>等于5时，屏幕上就只会输出5个数字。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo3thicj30i7045q32.jpg" alt=""></p><p>另外，如果没有设置成后台线程的话，设置<code>timeout</code>虽然也有用，但是<strong>进程仍然会等待所有子线程结束</strong>。所以屏幕上的输出结果会是这样的：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8xsb5qjsj30ix06y0t9.jpg" alt=""></p><p>虽然主线程继续往下执行并且结束了，但是子线程仍然一直运行，直到子线程也运行结束。</p><p>关于<code>join</code>设置<code>timeout</code>这里有一个坑，如果我们只有一个线程要等待还好，如果有多个线程，我们用一个循环将它们设置等待的话。那么<strong>主线程一共会等待N * timeout的时间</strong>，这里的<code>N</code>是线程的数量。因为每个线程计算是否超时的开始时间是上一个线程超时结束的时间，它会等待所有线程都超时，才会一起终止它们。</p><p>比如我这样创建3个线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span> + <span class="built_in">str</span>(i), args=(<span class="number">10</span>, ), daemon=<span class="literal">True</span>)</span><br><span class="line">    ths.append(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> ths:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> ths:</span><br><span class="line">    t.join(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>最后屏幕上输出的结果是这样的：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg8zo3dc9nj30km0bhdgl.jpg" alt=""></p><p>所有线程都存活了6秒，不得不说，这个设计有点坑，和我们预想的完全不一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天的文章当中，我们一起简单了解了<strong>操作系统当中线程和进程的概念</strong>，以及Python当中如何创建一个线程，以及关于创建线程之后的相关使用。今天介绍的只是最基础的使用和概念，关于线程还有很多高端的用法，我们将在后续的文章当中和大家分享。</p><p>多线程在许多语言当中都是至关重要的，许多场景下必定会使用到多线程。比如<strong>web后端，比如爬虫，再比如游戏开发</strong>以及其他所有需要涉及开发<code>ui</code>界面的领域。因为凡是涉及到<code>ui</code>，必然会需要一个线程单独渲染页面，另外的线程负责准备数据和执行逻辑。因此，多线程是专业程序员绕不开的一个话题，也是一定要掌握的内容之一。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过元类实现ORM数据库</title>
      <link href="/2023/04/18/orm-db/"/>
      <url>/2023/04/18/orm-db/</url>
      
        <content type="html"><![CDATA[<p>今天这篇文章我们一起来用元类实现一个简易的ORM数据库框架。</p><p>本文主要是受到了廖雪峰老师Python3入门教程的启发，不过廖老师的博客有些精简，一些小白可能看起来比较吃力。我在他的基础上做了一些<strong>补充和注释</strong>，尽量写得浅显一些。</p><h2 id="ORM框架是什么"><a href="#ORM框架是什么" class="headerlink" title="ORM框架是什么"></a>ORM框架是什么</h2><p>如果是没有做过后端的小伙伴上来估计会有点蒙，这个ORM框架究竟是什么？ORM框架是后端工程师常用的一个框架，它的英文全称是Object Relational Mapping，即<strong>对象-关系映射</strong>框架。顾名思义就是把关系转化成对象的框架，关系这个词我们在哪里用的最多呢？</p><p>显然应该是数据库。之前我们在分布式的文章介绍关系型数据库和非关系型数据库的时候就着重介绍过关系的含义。我们常用的MySQL就是经典的关系型数据库，它存储的形式是表，但是<strong>表承载的数据其实是两个实体之间的”关系”</strong>。比如学生上课这个场景，学生和课程是两个主体（entity），我们要记录的是这两个主体之间的关系，也就是学生上课这件事。</p><p>而ORM框架做的事情是将这些关系映射成类，这样我们可以将这张表当中增删改查的功能抽象成类当中的方法。这样我们就可以通过调用类的方式来操作数据库了，从而达到<strong>高度抽象业务逻辑、降低用户使用难度</strong>的目的。</p><p>比如Java后端工程师常用的<code>hibernate</code>和<code>ibatis</code>都是用来做这件事情的，明确了框架的功能之后，我们先来设想一下最后的成果。假设我们现在开发出来了这么一套框架，那么它用起来的感觉应该是怎样的？</p><p>我们来看下廖老师博客里给的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="comment"># 定义类的属性到列的映射：</span></span><br><span class="line">    <span class="built_in">id</span> = IntegerField(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    name = StringField(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    email = StringField(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">    password = StringField(<span class="string">&#x27;password&#x27;</span>)</span><br></pre></td></tr></table></figure><p>User类代表了数据库当中的一张表，它有4个字段：<code>id, name, email</code>和<code>password</code>，我们在定义字段的同时也通过类别指定了它们的类型。这个应该不难理解，上面的这个类等价于我们在数据库当中执行了这么一段建表的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    name string,</span><br><span class="line">    email string,</span><br><span class="line">    password string</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们定义了表字段之后，接下来要做的就是<strong>根据字段创建数据</strong>了，其实也就是根据类创建实例。我们希望<strong>User类型的实例就对应User表当中的一条记录</strong>，并且我们可以通过调用实例当中的方法，来操作这张表进行增删改查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个实例：</span></span><br><span class="line">u = User(<span class="built_in">id</span>=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存到数据库：</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure><p>那么，我们怎样可以实现这样的功能呢？</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>我们先从简单的功能开始实现，首先是<code>Field</code>类，<strong>Field类表示数据库表当中一个字段的类型</strong>。这里的逻辑很容易理清楚，我们需要定义多种类型，比如<code>IntegerField</code>和<code>StringField</code>。我们可以对这些<code>field</code>类抽象出一个父类来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, column_type</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#123;&#125;:&#123;&#125;&gt;&#x27;</span>.<span class="built_in">format</span>(self.__class__.__name__, self.name)</span><br></pre></td></tr></table></figure><p><code>__str__</code>方法当中打印出来的两个字段，分别是类别的名称和字段的名称，这段代码应该不难理解。</p><p>接着，我们实现它的两个子类，分别是<code>IntegerField</code>和<code>StringField</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(StringField, self).__init__(name, <span class="string">&#x27;varchar(100)&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(IntegerField, self).__init__(name, <span class="string">&#x27;bigint&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里也不难理解，只是一个简单的继承应用而已。</p><p>接下来就到了最关键的部分，也就是<code>Model</code>类的实现。我们先来分析一下我们希望<code>Model</code>这个类拥有的功能，由于它是我们定义出来的每一张表的父类，所以它应该<strong>能够获取子类当中的字段</strong>，并且将它存放在一个容器当中。由于我们需要存储的是字段名和类型的映射，所以将它存储在<code>dict</code>当中比较合理。</p><p>另外一个功能是我们希望它<strong>能够提供增删改查的接口</strong>，能够根据子类当中定义的字段自动生成相应的SQL语句去调用数据库。这个也是ORM框架的意义所在。</p><p>第二个功能容易实现，只要第一个功能搞定了，做一下字符串处理即可。但是第一个功能有些麻烦，它也是元类的意义所在。因为<strong>父类当中的方法是无法获取子类中定义的类属性的</strong>，只能通过元类，在构建类的时候可以拿到属性的信息。</p><p>所以我们已经很明确了，我们实现元类的目的就是为了实现这个功能。理清楚了之后，再来写代码就不难了。我们先来实现这个元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 创建model类的时候不做任何处理</span></span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">&#x27;Model&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line">        <span class="comment"># 打印表名的信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Found model: %s&#x27;</span> % name)</span><br><span class="line">        <span class="comment"># mappings用来存储字段的信息</span></span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 判断v的类型，只有是Field的子类才会存储起来</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">        <span class="comment"># 将mappings当中的数据从类属性当中移除，防止关键字冲突</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure><p>如果你看过之前的文章，对元类已经很熟悉了，那么这段代码对你来说应该不难理解。元类搞定了，剩下的<code>Model</code>就更简单了。按照规范，我们需要实现增删改查四个函数，但是这里我们只是为了展示，所以就只实现其中一个作为例子，其他几个都可以如法炮制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">dict</span>, metaclass=ModelMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):</span><br><span class="line">        <span class="comment"># 由于Model的基类是dict，所以创造Model的字段会被解析成dict的构造参数</span></span><br><span class="line">        <span class="comment"># 也就是说字段名和字段值的映射会存储在dict当中</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__(**kw)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            <span class="comment"># fields存储字段名</span></span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            <span class="comment"># params填充问号</span></span><br><span class="line">            params.append(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            <span class="comment"># 获取字段的值</span></span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(params))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ARGS: %s&#x27;</span> % <span class="built_in">str</span>(args))</span><br></pre></td></tr></table></figure><p>Model当中的save方法不难看懂，但是前面的几个方法看起来有些多余。但实际上它们也很重要，这里有一个关键信息是<strong>Model类的父类是<code>dict</code></strong>，我们在构建<code>Model</code>的时候传入的参数会被用来初始化一个<code>dict</code>。所以我们创建数据实例的时候数据的名称和数据值的映射会被存储在<code>dict</code>当中，所以我们在<code>save</code>方法当中才会从<code>self</code>的<code>attr</code>当中获取字段的值。并且我们<strong>在初始化<code>User</code>的时候，也必须要填写每个字段的名称</strong>，原因就在这里。</p><p>最后我们来运行一下：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gg0uhfmqhhj30jg03lq36.jpg" alt=""></p><p>从结果上来看，我们输出了User这个类的插入SQL以及它的字段的值。只需要链接一下数据库，我们的这个ORM框架就可以真正投入使用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在整个ORM框架实现的过程当中，最重要的是我们对Model这个类创建了元类，但是<strong>真正应用的地方却是在Model的子类</strong>。实际上在实际创建User类的时候，解释器会先搜索User内部是否定义了元类，如果没有，会上一层去往User的父类也就是Model类搜索元类，如果找到了元类，就会使用元类来创建User。<strong>相当于元类被隐形地继承了下来</strong>，但是我们在使用子类的时候却感知不到。</p><p>对于框架的使用者来说，也的确不需要了解框架内部的实现机制，只需要明白使用方法，照着使用就行了。虽然元类的实现和理解很复杂，但是使用起来却很简单，这也是它的一个显著特点。</p><p>最后，本文的代码示例源于廖雪峰老师的博客，<strong>向廖雪峰老师致敬</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> orm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python元类入门</title>
      <link href="/2023/04/17/python-meta/"/>
      <url>/2023/04/17/python-meta/</url>
      
        <content type="html"><![CDATA[<p>今天我们来继续聊聊Python当中的元类。</p><p>在之前的文章当中我们介绍了type元类的用法，在上一篇文章当中我们介绍了<code>__new__</code>函数与<code>__init__</code>函数的区别，以及它在一些设计模式当中的运用。这篇文章我们来看看<code>metacalss</code>与元类，以及<code>__new__</code>函数在元类当中的使用。</p><p><strong>那文章非常重要，是这一篇的基础</strong>，如果错过了上篇文章，推荐回顾一下。</p><h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h2><p><code>metaclass</code>的英文直译过来就是元类，这既是一个概念也可以认为是Python当中的一个关键字，不管怎么理解，对它的内核含义并没有什么影响。我们可以不必纠结，就认为它是类的类的意思即可。在这个用法当中，<strong>支持我们自己定义一个类，使得它是后面某一个类的元类。</strong></p><p>之前使用type动态创建类的时候，我们传入了类名，和父类的<code>tuple</code>以及属性的<code>dict</code>。在<code>metaclass</code>用法当中，其实核心相差不大，只是表现形式有所区别。我们来看一个例子即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddInfo</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attr</span>):</span><br><span class="line">        attr[<span class="string">&#x27;info&#x27;</span>] = <span class="string">&#x27;add by metaclass&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attr)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(metaclass=AddInfo):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这个例子当中，我们首先创建了一个类叫做<code>AddInfo</code>，这是我们定义的一个元类。由于我们希望通过它来实现元类的功能，所以我们<strong>需要它继承type类</strong>。我们在之前的文章当中说过，在Python面向对象当中，所有的类的根本来源就是<code>type</code>。也就是说Python当中的每一个类都是<code>type</code>的实例。</p><p>我们在这个类当中重载了<code>__new__</code>方法，我们在<code>__new__</code>方法当中传入了四个参数。眼尖一点的小伙伴一定已经看出来了，<strong>这个函数的四个参数，正是我们调用type创建类的时候传入的参数</strong>。其实我们调用<code>type</code>的方法来创建类的时候，就是调用的<code>__new__</code>这个函数完成的，这两种写法对应的逻辑是完全一样的。</p><p>我们之后又创建了一个新的类叫做<code>Test</code>，这个当中没有任何逻辑，直接pass。但是我们在创建类的时候指定了一个参数<code>metaclass=AddInfo</code>，这里<strong>这个参数其实就是指定的这个类的元类</strong>，也就是指定这个类的创建逻辑。虽然我们用代码写了类的定义，但是在实际执行的时候，这个类是以<code>metaclass</code>为元类创建的。</p><p>根据上面的逻辑，我们可以知道，Test类在创建的时候就被赋予了类属性<code>info</code>。我们可以验证一下：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt5zn6ej30rc086weq.jpg" alt=""></p><h2 id="拓展类功能"><a href="#拓展类功能" class="headerlink" title="拓展类功能"></a>拓展类功能</h2><p>上面这段就是元类的基本用法了，其实本质上和我们之前介绍的<code>type</code>的动态类创建是一样的，只不过展现的形式不同。那么我们就有一个问题要问了，我们使用元类究竟能够做什么呢？</p><p>这里有一个经典的例子，我们都知道Python原生的list是没有<code>add</code>这个方法的。假设我们习惯了Java当中list的使用，习惯用add来为它添加元素。我们希望创建一个新的类，在这个新的类当中，我们可以通过add来添加函数。通过元类可以很方便地使用这一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 在类属性当中添加了add函数</span></span><br><span class="line">        <span class="comment"># 通过匿名函数映射到append函数上</span></span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attrs)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="built_in">list</span>, metaclass=ListMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>我们首先是定义了一个叫做<code>ListMeta</code>的元类，在这个元类当中我们给类添加了一个属性叫做<code>add</code>。它只是包装了一下而已，<strong>底层是通过<code>append</code>方法实现的</strong>。我们来实验一下：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt5gcc2j30q806yaa5.jpg" alt=""></p><p>从结果来看也没什么问题，我们成功通过调用<code>add</code>方法往list当中插入了元素。这里藏着一个小细节，我们在<code>ListMeta</code>当中为<code>attrs</code>添加了一个名叫<code>add</code>的属性。<strong>这个属性是添加给类的</strong>，而不是类初始化出来的实例的。所以如果我们print出<code>MyList</code>这个类当中的所有属性，也能看到<code>add</code>的存在。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt4y8okj31cc07g0ts.jpg" alt=""></p><p>如果我们直接去通过<code>MyList</code>去访问<code>add</code>方法的话会引起报错，因为我们实现<code>add</code>这个方法逻辑的匿名函数<strong>限制了需要传入两个参数</strong>。第一个参数是实例的对象<code>self</code>，第二个参数才是添加的元素<code>value</code>。如果我们通过<code>MyList</code>的类属性去访问它的话会触发一个错误，因为缺少了一个参数。因为类当中的属性实例也是可以调用的，并且Python会在参数前面自动添加self这个参数，就刚好满足了要求。</p><p>搞明白了这些我们只是解决了可能性问题，我们明白了元类可以实现这样的操作，但没有解决我们为什么必须要使用元类呢？就拿刚才的例子来说，我们完全可以继承list这个类，然后在其中再开发我们想要的方法，为什么一定要使用元类呢？</p><p>就刚才这个场景来说，的确，我们是找不出任何理由的。完全没有理由不使用继承，而非要用元类。但是在有些场景和有些问题当中，我们必须要使用元类不可。就是<strong>涉及类属性变更和类创建的时候</strong>，我们来看下面这个例子。</p><h2 id="控制实例的创建"><a href="#控制实例的创建" class="headerlink" title="控制实例的创建"></a>控制实例的创建</h2><p>还记得我们上篇文章介绍的工厂设计模式的例子吗？就是我们可以通过参数来得到不同类的实例。</p><p>我们创建了三种游戏的类和一个工厂类，我们重载了工厂类的<code>__new__</code>函数。使得我们可以根据实例化时传入的参数返回不同类型的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Last_of_us</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Last Of Us is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uncharted</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Uncharted is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;PS has many games&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameFactory</span>:</span><br><span class="line">    games = &#123;<span class="string">&#x27;last_of_us&#x27;</span>: Last_of_us, <span class="string">&#x27;uncharted&#x27;</span>: Uncharted&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.games:</span><br><span class="line">            <span class="keyword">return</span> cls.games[name]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> PSGame()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">uncharted = GameFactory(<span class="string">&#x27;uncharted&#x27;</span>)</span><br><span class="line">last_of_us = GameFactory(<span class="string">&#x27;last_of_us&#x27;</span>)</span><br></pre></td></tr></table></figure><p>假设这个需求完成得很好顺利上线了，但是运行了一段时间之后我们<strong>发现下游有的时候为了偷懒会不通过工厂类来创建实例</strong>，而是直接对需要的类做实例化。原本这没有问题，但是现在产品想要在工厂类当中加上一些埋点，统计出访问我们工厂的访问量。所以我们需要<strong>限制这些游戏类不能直接实例化，必须要通过工厂返回实例</strong>。</p><p>那么这个功能我们怎么实现呢？</p><p>我们分析一下问题就会发现，这一次不是需要我们在创建实例的时候做动态的添加，而是直接限制一些类不允许直接调用进行创建。限制的方法比较常用的一种就是抛出异常，所以我们希望可以给这些类加上一个逻辑，<strong>实例化类的时候传入一个参数，表明是否是通过工厂类进行的，如果不是，则抛出异常</strong>。</p><p>这里，我们需要用到另外一个默认函数，叫做<code>__call__</code>，它是<strong>允许将类实例当做函数调用</strong>。我们通过类名来实例化，其实也是一个调用逻辑。这个<code>__call__</code>的逻辑并不难写，我们随手就来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> <span class="keyword">or</span> args[<span class="number">0</span>] != <span class="string">&#x27;factory&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;Can&#x27;t instantiate directly&quot;</span>)</span><br></pre></td></tr></table></figure><p>但问题是这个<code>__call__</code>函数<strong>并不能直接加在类当中，因为它的应用范围是实例</strong>，而不是类。而我们希望的是在创建实例的时候进行限制，而不是对调用实例的时候进行限制，所以这段逻辑<strong>只能通过元类实现</strong>。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt7e4pkj310q09igna.jpg" alt=""></p><p>我们直接创建类的时候就会触发异常，因为不是通过工厂创建的。我们这里判断是否是工厂创建的逻辑简化掉了，只是通过一个简单的字符串来进行的判断，实际上会用一些更加复杂的逻辑，这不是本文的重点，我们了解即可。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfxdt6j702j314i0hqacv.jpg" alt=""></p><p>整体运行的逻辑和我们设想的一样，说明这样实现是正确的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们日常开发当中用到元类的情况非常罕见，一般都是在一些<strong>高端开发的场景</strong>当中。比如说开发一些框架或者是中间件，为了方便下游的使用，需要创建一些关于类属性的动态逻辑，才会用到元类。对于普通开发者而言，如果你无法理解元类的含义以及应用，也没有关系，使用频率非常低。</p><p>另外，<strong>元类的概念和动态类、动态语言的概念有关</strong>，Python语言的动态特性很多正是通过这一点体现的。所以随着我们对于Python动态特性理解的加深，理解元类也会变得越来越容易，同样也会理解越来越深刻。如果我们把Python的元类和装饰器做一个类比的话，会发现<strong>两者的核心逻辑是很类似的</strong>。本质上都是在原有的逻辑之外封装新的逻辑，只不过装饰器针对的是一段逻辑，而元类针对的是类的属性和创建过程。</p><p>仔细思考，我相信一定会有灵光乍现的感觉。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 元类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python构造函数__new__</title>
      <link href="/2023/04/17/python-new/"/>
      <url>/2023/04/17/python-new/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来聊聊Python当中一个新的默认函数<code>__new__</code>。</p><p>上一篇当中我们讲了如何使用type函数来动态创建Python当中的类，除了type可以完成这一点之外，还有另外一种用法叫做<code>metaclass</code>。原本这一篇应该是继续元类的内容，讲解<code>metaclass</code>的使用。但是<code>metaclass</code>当中用到了一个<strong>新的默认函数<code>__new__</code></strong>，关于这个函数大家可能会比较陌生，所以在我们研究<code>metaclass</code>之前，我们先来看看<code>__new__</code>这个函数的用法。</p><h2 id="真假构造函数"><a href="#真假构造函数" class="headerlink" title="真假构造函数"></a>真假构造函数</h2><p>如果你去面试Python工程师的岗位，面试官问你，请问Python当中的类的<strong>构造函数</strong>是什么？</p><p>你不假思索，当然是<code>__init__</code>啦！如果你这么回答，很有可能你就和offer无缘了。因为在Python当中<code>__init__</code>并不是构造函数，<code>__new__</code>才是。是不是有点蒙，多西得（日语：为什么）？我们不是一直将<code>__init__</code>方法当做构造函数来用的吗？怎么又冒出来一个<code>__new__，</code>如果<code>__new__</code>才是构造函数，那么<strong>为什么我们创建类的时候从来不用它呢？</strong></p><p>别着急，我们慢慢来看。首先我们回顾一下<code>__init__</code>的用法，我们随便写一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br></pre></td></tr></table></figure><p>我们一直都是这么用的，对不对，毫无问题。但是我们换一个问题，我们在Python当中怎么实现单例(Singleton)的设计模式呢？怎么样实现工厂呢？</p><p>从这个问题出发，你会发现只使用<code>__init__</code>函数是不可能完成的，因为<code>__init__</code>并不是构造函数，它只是<strong>初始化方法</strong>。也就是说在调用<code>__init__</code>之前，我们的实例就已经被创建好了，<code>__init__</code>只是为这个实例赋上了一些值。如果我们把创建实例的过程比喻成做一个蛋糕，<code>__init__</code>方法并不是烘焙蛋糕的，只是点缀蛋糕的。那么显然，在点缀之前必须先烘焙出一个蛋糕来才行，那么这个烘焙蛋糕的函数就是<code>__new__</code>。</p><h2 id="new-函数"><a href="#new-函数" class="headerlink" title="__new__函数"></a><code>__new__</code>函数</h2><p>我们来看下<code>__new__</code>这个函数的定义，我们在使用Python面向对象的时候，<strong>一般都不会重构这个函数</strong>，而是使用Python提供的默认构造函数，Python默认构造函数的逻辑大概是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br></pre></td></tr></table></figure><p>从代码可以看得出来，函数当中基本上什么也没做，就原封不动地调用了父类的构造函数。这里隐藏着Python当中类的创建逻辑，是根据继承关系一级一级创建的。根据逻辑关系，我们可以知道，当我们创建一个实例的时候，实际上是<strong>先调用的<code>__new__</code>函数创建实例，然后再调用<code>__init__</code>对实例进行的初始化</strong>。我们可以简单做个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__new__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>().__new__(cls)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们创建Test这个类的时候，通过输出的顺序就可以知道Python内部的调用顺序。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfl6w59vwkj30b8028jr7.jpg" alt=""></p><p>从结果上来看，和我们的推测完全一样。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>那么我们重载<code>__new__</code>函数可以做什么呢？一般都是用来完成<code>__init__</code>无法完成的事情，比如前面说的<strong>单例模式</strong>，通过<code>__new__</code>函数就可以实现。我们来简单实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(SingletonObject, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            SingletonObject._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> SingletonObject._instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当然，如果是在并发场景当中使用，还需要加上线程锁防止并发问题，但逻辑是一样的。</p><p>除了可以实现一些功能之外，还可以<strong>控制实例的创建</strong>。因为Python当中是先调用的<code>__new__</code>再调用的<code>__init__</code>，所以如果当调用<code>__new__</code>的时候返回了<code>None</code>，那么最后得到的结果也是<code>None</code>。通过这个特性，我们可以控制类的创建。比如设置条件，只有在满足条件的时候才能正确创建实例，否则会返回一个<code>None</code>。</p><p>比如我们想要创建一个类，它是一个<code>int</code>，但是不能为0值，我们就可以利用<code>__new__</code>的这个特性来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonZero</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, value</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, value) <span class="keyword">if</span> value != <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>那么当我们用0值来创建它的时候就会得到一个<code>None</code>，而不是一个实例。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>理解了<code>__new__</code>函数的特性之后，我们就可以灵活运用了。我们可以用它来实现许多其他的设计模式，比如大名鼎鼎经常使用的<strong>工厂模式</strong>。</p><p>所谓的工厂模式是指通过一个接口，<strong>根据参数的取值来创建不同的实例</strong>。创建过程的逻辑对外封闭，用户不必关系实现的逻辑。就好比一个工厂可以生产多种零件，用户并不关心生产的过程，只需要告知需要零件的种类。也因此称为工厂模式。</p><p>比如说我们来创建一系列游戏的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Last_of_us</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Last Of Us is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uncharted</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the Uncharted is really funny&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;PS has many games&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后这个时候我们希望可以通过一个接口根据参数的不同返回不同的游戏，如果不通过<strong>new</strong>，这段逻辑就只能写成函数而不能通过面向对象来实现。通过重载<code>__new__</code>我们就可以很方便地用参数来获取不同类的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameFactory</span>:</span><br><span class="line">    games = &#123;<span class="string">&#x27;last_of_us&#x27;</span>: Last_Of_us, <span class="string">&#x27;uncharted&#x27;</span>: Uncharted&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.games:</span><br><span class="line">            <span class="keyword">return</span> cls.games[name]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> PSGame()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">uncharted = GameFactory(<span class="string">&#x27;uncharted&#x27;</span>)</span><br><span class="line">last_of_us = GameFactory(<span class="string">&#x27;last_of_us&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信看到这里，关于<code>__new__</code>这个函数的用法应该都能理解了。一般情况下我们是用不到这个函数的，只会在一些特殊的场景下使用。虽然如此，我们学会它并不只是用来实现设计模式，更重要的是可以加深我们对于Python面向对象的理解。</p><p>除此之外，另一个经常使用<code>__new__</code>场景是元类。所以今天的这篇文章其实也是为了后面介绍元类的其他用法打基础。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python内存管理</title>
      <link href="/2023/04/17/memory-mana/"/>
      <url>/2023/04/17/memory-mana/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来聊聊Python中内存管理机制，以及循环引用的问题。</p><h2 id="Python的内存管理机制"><a href="#Python的内存管理机制" class="headerlink" title="Python的内存管理机制"></a>Python的内存管理机制</h2><p>对于工程师而言，<strong>内存管理机制非常重要</strong>，是绕不过去的一环。如果你是Java工程师，面试的时候一定会问JVM。C++工程师也一定会问内存泄漏，同样我们想要深入学习Python，内存管理机制也是绕不过去的一环。</p><p>不过好在Python的内存管理机制相对来说比较简单，我们也不用特别深入其中的细节，简单做个了解即可。</p><p>Python内存管理机制的核心就是引用计数，在Python当中一切都是对象，对象通过引用来使用。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gezrwvc60ij30hi08874u.jpg" alt=""></p><p>我们看到的是变量名，但是变量名指向了内存当中的一块对象。这种关系在Python当中称为<strong>引用</strong>，我们通过引用来操作对象。所以根据这点，引用计数很好理解，也就是说我们会对每一个对象进行统计所有指向它的指针的数量。如果一个对象引用计数为0，那么说明它没有任何引用指向它，也就是说它已经没有在使用了，这个时候，Python就会将这块内存收回。</p><p>简单来说引用计数原理就是这些，但我们稍微深入一点，来简单看看哪些场景会引起对象引用的变化。</p><p>引用计数的变化显然只有两种，一种是增加，一种是减少，这两种场景都只有4种情况。我们先来看下增加的情况：</p><ol><li>首先是初始化，最简单的就是我们用<strong>赋值操作</strong>给一个变量赋值。举个例子：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>这就是最简单的初始化操作，虽然123在我们来看是一个常数，但是在Python底层同样被认为是一个<strong>常数对象</strong>。n是它的一个引用。</p><ol><li>第二种情况是引用的传递，最简单的就是我们将一个变量的值赋值给了另外一个变量。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = n</span><br></pre></td></tr></table></figure><p>比如我们将n赋值给m，它的本质是我们创建了一个新的引用，指向了同样一块内存。如果我们用id操作去查看m和n的id，会发现它们的id是一样的。也就是说它们并不是存储了两份相同的值，而是指向了同一份值。<strong>并不是有两个叫做王小二的人，而是王小二有两个不同的账号</strong>。</p><ol><li>第三种情况是作为元素被存储进了容器当中，比如被存储进了list当中。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure><p>虽然我们用到了一个容器，但是容器并不会拷贝一份这些对象，还是只是<strong>存储这些对象的引用</strong>。</p><ol><li>最后一种情况就是作为参数传给函数，在Python当中，所有的传参都是引用传递。这也是为什么，我们经常看到有人会这样写代码的原因：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a</span>):</span><br><span class="line">  a.append(<span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line">a = []</span><br><span class="line">test(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>我们根据上面列举的这四种引用计数增加的情况，不难推导出引用减少的情况， 其实基本上是<strong>对称的操作</strong>。</p><ol><li>和初始化对应的操作是<strong>销毁</strong>，比如我们创建的对象被del操作给销毁了，那么同样引用计数会-1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> n</span><br></pre></td></tr></table></figure><ol><li>和赋值给其他变量名的操作相反的操作是<strong>覆盖</strong>，比如之前我们的<code>n=123</code>，也就是<code>n</code>这个变量指向<code>123</code>，现在我们将<code>n</code>赋值成其他值，那么<code>123</code>这个对象的引用计数同样会减少。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">124</span></span><br></pre></td></tr></table></figure><ol><li>既然元素存储在容器当中会带来引用计数，那么同样元素<strong>从容器当中移除</strong>也会减少引用计数。这个也很好理解，最简单的就是<code>list</code>调用<code>remove</code>方法移除一个元素：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.remove(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><ol><li>最后一个对应的就是作用域，也就是当变量<strong>离开了作用域</strong>，那么它对应的内存块的引用计数同样会减少。比如我们函数调用结束，那么作为参数的这些变量对应的引用计数都会减1。</li></ol><p>如果一个对象的引用计数减到0，也就是没有引用再指向它的时候，那么当Python进行gc的时候，这块内存就会被释放，也就是这个对象会被清除，腾出空间来。</p><p>注意一下，引用计数减到0与内存回收之间<strong>并不是立即发生的</strong>，而是有一段间隔的。根据Python的机制，内存回收只会在特定条件下执行。在占用内存比较小还有很多富裕的情况下，往往是不会执行内存回收的。因为Python在执行<code>gc（garbage collection）</code>的时候也会stop the world，也就是暂停其他所有的任务，所以这是影响性能的一件事情，只会在有必要的时候执行。</p><p>我们费这么大劲来介绍Python中的内存机制，除了向大家科普一下这一块内容之外，更重要的一点是为了引出我们开发的时候经常遇见的一种情况——<strong>循环引用</strong>。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果熟悉了Python的引用，来理解循环引用是非常容易的。说白了也很简单，就是你的一个变量引用我，我的一个变量引用你。</p><p>我们来写一段简单的代码，来看看循环引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = Test()</span><br><span class="line">    b = Test()</span><br><span class="line">    a.t = b</span><br><span class="line">    b.t = a</span><br></pre></td></tr></table></figure><p>如果你打个断点来看的话，会看到a和b之间的循环引用：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gezrwx33tbj30ho05kmxh.jpg" alt=""></p><p>这里是<strong>无限展开</strong>的，因为这是一个无限循环。无限循环并不会导致程序崩溃， 也不会带来太大的问题，它的问题只有一个，就是根据前面介绍的引用计数法，a和b的引用永远不可能为0。</p><p>也就是说根据引用计数的原则，<strong>这两个变量永远不会被回收</strong>，这显然是不合理的。虽然Python当中专门建立了机制来解决引用循环的问题，但是我们并不知道它什么时候会被触发。</p><p>这个问题在Python当中非常普遍，尤其在我们实现一些数据结构的时候。举个最简单的例子就是树中的节点，就是引用循环的。因为父节点会存储所有的孩子，往往孩子节点也会存储父节点的信息。那么这就构成了引用循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, father</span>):</span><br><span class="line">    self.val = val</span><br><span class="line">    self.father = father</span><br><span class="line">    self.childs = []</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>为了解决这个问题，Python中提供了一个叫做弱引用的概念。弱引用本质也是一种引用，但是它不会增加对象的引用计数。也就是说它不能保证它引用的对象一定不会被销毁，只要没有销毁，弱引用就可以返回预期的结果。</p><p>弱引用不用我们自己开发，这是Python当中集成的一个现成的模块<strong>weakref</strong>。</p><p>这个模块当中的方法很多，用法也很多，但是我们基本上用不到，一般来说最常用的就是<code>ref</code>方法。通过<code>weakref</code>库中的<code>ref</code>方法，可以返回对象的一个弱引用。我们还是来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = Test(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = Test(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    a.t = weakref.ref(b)</span><br><span class="line">    b.t = weakref.ref(a)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a.t())</span><br></pre></td></tr></table></figure><p>其实还是之前的代码，只是做了一点简单的改动。一个是我们给<code>Test</code>加上了<code>name</code>这个属性，以及<code>str</code>方法。另一个是我们把直接赋值改成了使用<code>weakref</code>。</p><p>这一次我们再打断点进来看的话，就<strong>看不到无限循环的情况</strong>了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gezrww3zxqj30iz03xaa2.jpg" alt=""></p><p><code>ref</code>返回的是一个获取引用对象的方法，而不是对象本身。所以我们想要获取这个对象的话，需要再把它当成函数调用一下。</p><p>当然这样很麻烦，我们还有更好的办法，就是使用<strong><code>property</code>注解</strong>。通过<code>property</code>注解，我们可以把<code>weakref</code>封装掉，这样在使用的时候就没有感知了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">node</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> <span class="keyword">if</span> self._node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> self._node()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @node.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">node</span>(<span class="params">self, node</span>):</span><br><span class="line">        self._node = weakref.ref(node)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引用和循环引用都是基于Python本身的机制，如果对这块机制不了解，很容易采坑。因为可能会出现逻辑是对的，但是有一些意想不到的bug的情况。这种时候，往往很难通过review代码或者是测试发现，这也是我们学习的瓶颈所在。很容易发现代码已经写得很熟练了，但是一些进阶的代码还是看不懂或者是写不出来，本质上就是因为缺少了对于底层的了解和认知。</p><p>循环引用的问题在我们开发代码的时候还蛮常见的，尤其是涉及到<strong>树和图的数据结构</strong>的时候。由于循环引用的关系，很有可能出现被删除的树仍然占用着空间，内存不足的情况发生。这个时候使用weakref就很有必要了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 通过type动态创建类</title>
      <link href="/2023/04/17/python-dynamic-class/"/>
      <url>/2023/04/17/python-dynamic-class/</url>
      
        <content type="html"><![CDATA[<p>今天我们来聊聊Python当中的元类。</p><p>元类是Python当中的<strong>高级用法</strong>，如果你之前从来没见过这个术语或者是没听说过这个概念，这是非常正常的，因为一方面它的<strong>使用频率不高</strong>，另外一方面就是它相对<strong>不太容易理解</strong>。以至于很多Python开发者都理解得不是很深入，导致了市面上相关的资料也并不太多。我也是读了一些大牛的代码才开启了这扇新世界的大门。</p><h2 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h2><p>我们之前的时候曾经介绍过，在Python当中<strong>一切都是对象</strong>，注意，是一切都是对象。我们都知道对象是类实例化之后的结果，可以简单地将类和对象类比成模具和成品的关系。模具是类，而根据模具做出来的产品是对象。</p><p>这个比喻思想比较接近，但是不完美。因为实际当中一个模具可以做出多个产品，一个产品只有一个模具。但编程语言当中不同，由于类之间可以继承以及<strong>多继承</strong>，也就是说一个对象可以对应多个类。所以这个比喻不是特别合适，但是类和对象的关系是没错的。</p><p>但是这就有了一个问题，既然Python当中一切都是对象，那么是不是说类其实也是一个对象呢？也就是说一个模具其实也是另外一个模具的产品？同样，这个模具的模具其实也是另外一个模具的产品，那么我们一直追问下去会怎么样呢？</p><p>很简单，我们做个实验就知道了，我们可以用<code>__class__</code>关键字来查看一个变量的类型，那么我们反复调用就可以查看其中的关系了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfdoybc1fmj30sa0cujs8.jpg" alt=""></p><p>从上面的图中我们可以发现，<code>num</code>是<code>int</code>类型的变量。我们继续查看<code>int</code>这个类型的类型，<strong>得到了<code>type</code>类型</strong>。而当我们去查看<code>type</code>的类型的时候，会发现我们得到的还是一个<code>type</code>的类型。</p><p>所以我们可以明白了，<code>type</code>是Python中用来创建所有类的元类，是所有模具的模具。在Python当中，我们把一个类的类叫做元类（<code>metaclass</code>）。所以<code>type</code>就是Python当中内置的元类，我们也可以自己创建我们需要的元类。通过元类，我们创建的对象也是一个类，而不是一个实例。</p><h2 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h2><p>理解了type是一切类基础之后，再来看动态类就简单了。<strong>动态类是动态语言最大的特性之一</strong>，作为典型的动态语言，Python自然也是支持类型的动态创建的。</p><p>在Python当中，创建动态类型的一种方式就是通过<code>type</code>关键字。说起来有些意想不到，<code>type</code>函数不是用来查询对象所属的类型的吗，怎么还可以创建类呢？</p><p>这其实是<code>type</code>的<strong>另外一种用法</strong>，作为元类来创建一个类。在这种用法，<code>type</code>函数接收3个参数，分别是类型的名称，父类的元组，以及一个字典。除了第一个参数之外，后面两个参数都可以为空。比如我们来看一个例子：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfdoyavkiqj30sa05s3yq.jpg" alt=""></p><p>注意，<code>type</code>返回的结果是一个类，而不是一个实例。所以我们还可以通过它创建实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello = Hello()</span><br></pre></td></tr></table></figure><p>这样创建出来的是最简单的空类，它什么也没有，和下面的代码等价。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>我们也可以在type的参数当中为这个类填充属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">Hello = <span class="built_in">type</span>(<span class="string">&#x27;Hello&#x27;</span>, (), &#123;<span class="string">&#x27;hello&#x27;</span>:hello_world, <span class="string">&#x27;num&#x27;</span>: <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就为<code>Hello</code>这个类创建了一个方法叫做<code>hello</code>，一个属性<code>num</code>等于3。我们可以来调用一下试试：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfdoya9tqnj30to070aa8.jpg" alt=""></p><p>也就是说我们可以使用type来根据我们的需要自行定义类，只不过type既可以获取对象的类型又可以创建新的类，<strong>看起来可能觉得有些不太直观</strong>，但是其实这也是说得通的。我们在Python当中通过调用<code>str</code>创建一个<code>string</code>对象，通过<code>int</code>来创建一个<code>integer</code>对象，那么通过<code>type</code>则是创建一个类的对象。</p><h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><p>我们之前说了，当我们使用<code>type</code>来创建类的时候，还可以传入父类的元组从而实现类的继承。</p><p>比如我们再创建一个叫做<code>World</code>的类继承刚才通过<code>type</code>创建出来的<code>Hello</code>类，然后在为它加上额外的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_world</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">World = <span class="built_in">type</span>(<span class="string">&#x27;World&#x27;</span>, (Hello, ), &#123;<span class="string">&#x27;world&#x27;</span>: say_world&#125;)</span><br></pre></td></tr></table></figure><p>注意这里传入第二个参数是<strong>父类的元组</strong>，既然是元组，那么当元素只有一个的时候，需要加上逗号，表示这是一个元组。这样创建出来的类和我们通过class定义的静态类效果是一样的：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfdoycdt44j30vu06c74g.jpg" alt=""></p><p>也就是说，我们可以先把函数实现，然后再根据任务的需要把这些函数组装成新的类。显然，这和传统的C++以及Java这些静态类型的语言相比，要灵活得多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们固然可以通过<code>type</code>来创建动态创建类，但是从上面的使用过程也应该看得出来，这样使用起来并不太方便，并且<strong>很多进阶的功能很难实现</strong>。举个简单的例子，比如我们想要动态地为一个已有的类添加一些动态的方法，生成新的类。我们使用<code>type</code>就很难实现。<code>type</code>也的确不是Python元类的主要运用，<code>metaclass</code>才是王道，但由于篇幅限制，这部分将放在下一篇文章当中。</p><p>当然，元类是一个非常高级的用法，以至于Python的创始人说<strong>99%的Python程序员并不需要用到它</strong>。所以如果你觉得理解起来非常费劲的话也没有关系，知道这么个概念就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器进阶</title>
      <link href="/2023/04/17/python-decro-pro/"/>
      <url>/2023/04/17/python-decro-pro/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章当中我们介绍了Python装饰器的定义和基本的用法，这篇文章我们一起来学习一下Python装饰器的一些进阶使用方法。对装饰器不太熟悉，可以回顾一下上一篇文章。</p><p>之前的文章当中我们从前到后仔细推到了一下装饰器的本质和用途，也学会了它的基本用法，已经足够<strong>应付80%的场景</strong>了。但是总有20%的场景使用基本的方法解决不了，这个时候就需要我们学习更多、更全的其他用法。</p><p>比如我想要<strong>通过一个参数控制装饰器的功能</strong>，这个问题其实很常见。就拿记录时间来说，我们都知道时间可以记录成很多种格式，比如可以记成<code>2020-05-04</code>也可以记录成<code>20200504</code>，还可以记录成<code>04/05/2020</code>，如果是后端还会记录时间的时间戳。比如说我们现在实现了一个记录日志的装饰器，用来给我们的方法打上日志，现在我们想要控制记录日志的时候打印出来的时间格式，这个需求使用最简单的装饰器就没有办法解决了。</p><p>这个时候，如果想要解决问题，就必须引入参数，也就是说我们必须要在装饰器当中加入参数才行。但问题来了，这个参数怎么加，加在哪里呢？</p><h2 id="定义装饰器参数"><a href="#定义装饰器参数" class="headerlink" title="定义装饰器参数"></a>定义装饰器参数</h2><p>在我们介绍具体的用法之前，我们先来回顾一下装饰器的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mydec</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mywrap</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello this is decorator1&#x27;</span>)</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> mywrap</span><br><span class="line">    </span><br><span class="line"><span class="meta">@mydec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helloWorld</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个就是我们上次讲的最简单的那种装饰器，假如说我们这个时候希望传入一个参数type，可以控制装饰器的输出结果。就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mydec(<span class="params">type_=<span class="string">&#x27;test&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helloWorld</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们可能会想是不是应该在mydec这个方法的参数里面加上一个type_，但是如果你试一下就好发现这样是不行的，会得到一个error：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gegpjq8jryj313808gdhf.jpg" alt=""></p><p>Error错误的字面意思很好理解，但是原因却令人费解。这个Error是说函数<code>mydec</code><strong>少了一个必选参数func</strong>，这个<code>func</code>就是我们要包装的函数，但是这个不是自动传入的吗，怎么会提示我们少了这个参数呢？</p><p>如果这个问题的本质不能理解的话，那么装饰器就很难大成了，因为只有理解清楚了这一点，才能理解后面装饰器各种稀奇古怪的进阶用法。但是很坑爹的是，很多资料当中都只是简单地介绍了怎么用，很少会探究其中背后的原因，这会让初学者在学习的时候陷入费解。我在学习的时候也花了很多心思，才终于搞明白，说穿了很简单，但是想通不容易。</p><p>其实这样会报错的主要原因是注解当中有参数和没有参数的装饰器是完全不同的。</p><p>我们来回顾一下不加参数的装饰器的用法，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mydec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>我们执行hello_world()的时候，等价于执行<code>mydec(hello\_world)()</code>。看明白了吗，我们把这行代码展开，它其实是下面这两行代码共同执行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur = mydec(hello_world)</span><br><span class="line">cur()</span><br></pre></td></tr></table></figure><p>如果<code>hello_world</code>这个函数带上参数呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mydec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么执行的时候它其实是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur = mydec(hello_world)</span><br><span class="line">cur(*args, **kw)</span><br></pre></td></tr></table></figure><p>这个理解了之后，我们继续往下，现在我们想要将一个参数传给装饰器，按照我们的想法下面这两段代码应该是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mydec(<span class="params">type_=<span class="string">&#x27;test&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helloWorld</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cur = mydec(hello_world, type_)</span><br><span class="line">cur()</span><br></pre></td></tr></table></figure><p>但是很遗憾的是，Python解释器当中并不是这么设计的。它对加上了参数的装饰器<strong>多做了一层封装</strong>，也就是说上面传入参数的<code>hello_world</code>函数执行的时候等价于下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur1 = mydec(type_)</span><br><span class="line">cur2 = cur1(hello_world)</span><br><span class="line">cur2()</span><br></pre></td></tr></table></figure><p>正是因为额外多封装了一层，所以函数和装饰器的参数传入装饰器的顺序是不同的，顺序也是不一样的。明白了这点之后就简单很多了，既然Python解释器在解释装饰器参数的时候多增加了一层，那么如果我们想要实现带参数的装饰器，只需要也在装饰器当中多封装一层就可以了。比如可以写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mydec</span>(<span class="params">type_=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mywrap</span>():</span><br><span class="line">            <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(type_)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">return</span> mywrap</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure><p>这样我们再执行就可以了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gegplhtdsej30uo07sjrz.jpg" alt=""></p><h2 id="默认参数怎么办"><a href="#默认参数怎么办" class="headerlink" title="默认参数怎么办"></a>默认参数怎么办</h2><p>到这里看似一切都很完美，但其实<strong>有一个很大的问题</strong>被我们忽略了。</p><p>这个问题就是默认参数问题，在前面我们定义装饰器的时候，将<code>type_</code>这个参数设置成了可选的。这也很符合我们实际情况，如非必要，参数能省略就省略。但是这就导致了一个问题，对于不用加上参数的装饰器，有些人习惯写成<code>mydec()</code>，有些人习惯写成<code>mydec</code>。如果我们试一下<code>mydec</code>，就会发现这样写会报错：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gegplrsfozj313206qq47.jpg" alt=""></p><p>这个报错和上面的报错一模一样，出现的原因也是一样的，都是少了<code>func</code>参数。但是很奇怪啊，为什么会少了<code>func</code>呢？</p><p>原因很简单，因为我们把括号去掉，装饰器又回到了之前的两层结构！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur = mydec(hello_world)</span><br><span class="line">cur(*args, **kw)</span><br></pre></td></tr></table></figure><p>这就很坑爹了，我们装饰器的结构肯定是不能改变的，如果使用两层结构就没办法传入参数了，但是如果不传参的时候怎么办，难道就只能强制程序员统一风格全部加上括号吗？这当然也是一个办法，那还有没有更好的办法呢？有没有办法统一这两种逻辑呢？</p><p>当然是有的，为了解决这个问题，我们需要用到一个新的工具，叫做<strong>偏函数</strong>。</p><p>偏函数很好理解，它本意也是一个高阶函数，其实就是<strong>闭包</strong>。偏函数的使用场景针对多参数的函数，通过使用偏函数，可以固定若干个参数的传值，从而起到简化函数传参的作用。我们来看一个例子，我们创建一个pow函数，用来计算x的n次方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pow</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="keyword">return</span> math.<span class="built_in">pow</span>(x, n)</span><br></pre></td></tr></table></figure><p>这个函数需要传入x和n两个参数，如果我们当前只需要计算平方，我们可以使用闭包，<strong>固定其中的参数n</strong>，生成一个新的函数来做到这点。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mypow</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, n) </span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gegpqwiym0j30os04caa9.jpg" alt=""></p><p>偏函数的本质就是这样一个闭包，只不过它简化了我们的代码而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">pow2 = partial(<span class="built_in">pow</span>, n=<span class="number">2</span>)</span><br><span class="line">pow2(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>使用偏函数我们只需要传入待加工的原函数，以及固定的参数值即可。我们把偏函数用在装饰器当中，就可以解决刚才的问题。回忆一下，不带参数的装饰器是两层函数嵌套，而带上参数的是三层嵌套。那么我们使用<code>partial</code>，专门为带上参数的情况额外增加一层嵌套即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mydec</span>(<span class="params">func=<span class="literal">None</span>, type_=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 不带参数的话，func会是None，这时候我们固定参数即可</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(mydec, type_=type_)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mywrap</span>():</span><br><span class="line">        <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(type_)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> mywrap</span><br></pre></td></tr></table></figure><p>我们来看下这其中的细节，当我们不传入参数的时候，我们其实执行的是<code>cur = mydec(func)</code>，这个时候<code>func</code>不为空，那么不会触发<code>if</code>中的语句，所以会直接返回<code>mywrap</code>。如果传入参数，这时候<code>func</code>是<code>None</code>，会触发<code>if</code>中的<code>partial</code>。注意这里我们在<strong>partial当中传入的函数依然是mydec</strong>，也就是说我们固定了type_这个参数，调用的话依然返回的是<code>mywrap</code>，相当于我们通过<code>partial</code>额外在两层结构当中专门为带参数的情况增加了一层，统一了逻辑。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>今天的概念比之前的装饰器要复杂很多，<strong>一时可能并不好理解</strong>，其实这是非常正常的。这不仅仅是装饰器的问题，也不仅是Python的问题，归根结底这是函数式编程的特性导致的。函数式编程的优点就是高度灵活，使用非常方便，但缺点也很明显，<strong>代码难以维护，阅读难度高，理解起来也不简单</strong>。典型的初学简单，精深非常难的典型。所以如果大家觉得一时理解不了，这并不是你们的问题，一方面我们需要培养自己函数传编程的思维，另一方面我们也需要熟悉Python中装饰器的使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器入门</title>
      <link href="/2023/04/16/python-decro/"/>
      <url>/2023/04/16/python-decro/</url>
      
        <content type="html"><![CDATA[<p>今天这篇文章我们来聊聊Python中一个高端技巧——装饰器。</p><h2 id="装饰器本质"><a href="#装饰器本质" class="headerlink" title="装饰器本质"></a>装饰器本质</h2><p>装饰器在很多面试中出镜率很高，当初我也被问过，但很遗憾当初水平太次没能答出来。如今如果再有面试官问我Python中的装饰器是什么，我一句话就能给回答了，倒不是我装逼，实际上也的确只需要一句话。Python中的装饰器，本质上就是一个<strong>高阶函数</strong>。</p><p>你可能不太清楚高阶函数的定义，没关系，我们可以类比一下。在数学当中高阶导数，比如二次导数，表示导数的导数。那么这里高阶函数自然就是<strong>函数的函数</strong>，结合我们之前介绍过的函数式编程，也就是说是一个返回值是函数的函数。但是这个定义是充分不必要的，也就是说装饰器是高阶函数，但是<strong>高阶函数并不都是装饰器</strong>。装饰器是高阶函数一种特殊的用法。</p><h3 id="任意参数"><a href="#任意参数" class="headerlink" title="任意参数"></a>任意参数</h3><p>在介绍装饰器的具体使用之前，我们先来了解和熟悉一下Python当中的任意参数。</p><p>Python当中支持任意参数，它写成<code>*args, **kw</code>。表示的含义是接受任何形式的参数。</p><p>举个例子，比如我们定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">a, b, c=<span class="string">&#x27;3&#x27;</span>, d=<span class="string">&#x27;f&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br></pre></td></tr></table></figure><p>我们可以这样调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">dt = &#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">exp(*args, **dt)</span><br></pre></td></tr></table></figure><p>最后输出的结果是1， 3， 4， 5。也就是说我们用一个<strong>list和dict可以表示任何参数</strong>。因为Python当中规定必选参数一定写在可选参数的前面，而必选参数是可以不用加上名称标识的，也就是可以不用写a=1，直接传入1即可。那么这些没有名称标识的<strong>必选参数就可以用一个list来表示</strong>，而可选参数是必须要加上名称标识的，这些参数可以用<code>dict</code>来表示，这两者相加可以表示任何形式的参数。</p><p>注意我们传入<code>list</code>和<code>dict</code>的时候前面加上了<code>*</code>和<code>**</code>，它表示<strong>将list和dict当中的所有值展开</strong>。如果不加的话，<code>list</code>和<code>dict</code>会被当成是整体传入。</p><p>所以如果一个函数写成这样，它表示可以接受任何形式的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="定义装饰器"><a href="#定义装饰器" class="headerlink" title="定义装饰器"></a>定义装饰器</h3><p>明白了任意参数的写法之后，装饰器就不难了。</p><p>既然我们可以用<code>*args, **kw</code>接受任何参数。并且Python当中支持一个函数作为参数传入另外一个函数，如果我们把函数和这个函数的所有参数全部传入另外一个函数，那么不就可以<strong>实现代理</strong>了吗？</p><p>还是刚才的例子，我们额外增加一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">a, b, c=<span class="string">&#x27;3&#x27;</span>, d=<span class="string">&#x27;f&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">agent</span>(<span class="params">func, *args, **kwargs</span>):</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">args = [<span class="number">1</span>]</span><br><span class="line">dt = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">agent(exp, *args, **dt)</span><br></pre></td></tr></table></figure><p><strong>装饰器的本质其实就是这样一个agent的函数</strong>，但是如果使用的时候需要手动传入会非常麻烦，使用起来不太方便。所以Python当中提供了特定的库，我们可以让装饰器以注解的方式使用，大大简化操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapexp</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is a wrapper&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapexp</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">a, b, c=<span class="string">&#x27;3&#x27;</span>, d=<span class="string">&#x27;f&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">dt = &#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">exp(*args, **dt)</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们定义了一个<code>wrapexp</code>的装饰器。我们在其中的<code>wrapper</code>方法当中实现了装饰器的逻辑<strong>，<code>wrapexp</code>当中传入的参数<code>func</code>是一个函数，<code>wrapper</code>当中的参数则是<code>func</code>的参数。所以我们在<code>wrapper</code>当中调用`func(*args, </strong>kw)`，就是调用打上了这个注解的函数本身。比如在这个例子当中，我们没有做任何事情，只是在原样调用之前多输出了一行’<strong>this is a wrapper</strong>‘，表示我们的装饰器调用成功了。</p><h2 id="装饰器用途"><a href="#装饰器用途" class="headerlink" title="装饰器用途"></a>装饰器用途</h2><p>我们理解了装饰器的基本使用方法之后，自然而然地会问一个天然的问题，学会了它<strong>究竟有什么用</strong>呢？</p><p>如果你从上面的例子当中没有领会到装饰器的强大，不如让我用一个例子再来暗示一下。比如说你是一个程序员，辛辛苦苦做出了一个功能，写了好几千行代码，<strong>上百个函数</strong>，终于通过了审核上线了。这个时候，你的产品经理找到了你说，经过分析我们发现上线的功能运行速度不达标，经常有请求超时，你能不能计算一下<strong>每个函数运行的耗时</strong>，方便我们找到需要优化的地方？</p><p>这是一个非常合理的请求，但想想看你写了上百个函数，如果每一个函数都要手动添加时间计算，这要写多少代码？万一哪个函数不小心改错了，你又得一一检查，并且如果要求严格的话你还得为每一个函数专门写一个单元测试……</p><p>我想，正常的程序员应该都会抗拒这个需求。</p><p>但是有了装饰器就很简单了，我们可以实现一个计算函数耗时的装饰器，然后我们只需要给每一个函数<strong>加上注解</strong>就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timethis</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(func.__name__, end-start)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>这也是装饰器最大的用途，可以<strong>在不修改函数内部代码的前提下，为它包装一些额外的功能</strong>。</p><h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><p>我们之前说过装饰器的本质是高阶函数，所以我们也可以和高阶函数一样来调用装饰器，比如下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">a, b, c=<span class="string">&#x27;3&#x27;</span>, d=<span class="string">&#x27;f&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">dt = &#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">f = wrapexp(exp)</span><br><span class="line">f(*args, **dt)</span><br></pre></td></tr></table></figure><p>这样的方式得到的结果和使用注解是一样的，也就是说我们加上注解的本质其实就是调用装饰器返回一个新的函数。</p><p>既然和高阶函数是一样的，那么就带来了一个问题，<strong>我们使用的其实已经不再是原函数了</strong>，而是一个由装饰器返回的新函数，虽然这个函数的功能和原函数一样，但是一些基础的信息其实已经丢失了。</p><p>比如我们可以打印出函数的name来做个实验：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230417081914252.png" alt=""></p><p>正常的函数调用<strong>name</strong>返回的都是函数的名称，但是当我们加上了装饰器的注解之后，就会发生变化，同样，我们输出加上了装饰器注解之后的结果：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230417081945161.png" alt=""></p><p>我们会发现输出的结果变成了wrapper，这是因为我们实现的装饰器内部的函数叫做wrapper。不仅仅是<strong>name</strong>，函数内部还有很多其他的基本信息，比如记录函数内描述的<strong>doc</strong>，<strong>annotations</strong>等等，这些基本信息被称为是<strong>元信息</strong>，这些元信息由于我们使用注解发生了丢失。</p><p>有没有什么办法可以保留这些函数的元信息呢？</p><p>其实很简单，Python当中为我们提供了一个专门的装饰器器用来保留函数的元信息，我们只需要在实现装饰器的wrapper函数当中<strong>加上一个注解wraps</strong>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrapexp</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is a wrapper&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>加上了这个注解之后，我们再来检查函数的元信息，会发现它和我们预期一致了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230417082002185.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了Python中的装饰器之后，再来看之前我们用过的<code>@property, @staticmethod</code>等注解，想必都能明白，<strong>它们背后的实现其实也是装饰器</strong>。灵活使用装饰器可以大大简化我们的代码， 让我们的代码更加规范简洁，还能灵活地实现一些特殊的功能。</p><p>装饰器的用法很多，今天介绍的只是其中最基本的，在后续的文章当中，还会继续和大家分享它更多其他的用法。在文章开始的时候我也说了，装饰器是<strong>Python进阶必学的技能之一</strong>。想要熟练掌握这门语言，灵活运用，看懂大佬的源码，装饰器是必须会的东西。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象常用规范</title>
      <link href="/2023/04/16/python-stand/"/>
      <url>/2023/04/16/python-stand/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊面向对象的一些进阶使用。</p><h2 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h2><p>如果你看过github当中一些大牛的代码，你会发现很多大牛经常在类的顶部加上<code>__slots__</code>关键字。如果你足够好奇，你可能会试着把这个关键字去掉再运行试试，你会发现去掉了之后什么也没有发生，一切依然运行得很好。</p><p>那么这个<code>__slots__</code>关键字究竟是做什么的呢？</p><p>它主要有两个功能，我们先来说第一个功能，就是<strong>限制用户的使用</strong>。</p><p>我们都知道Python是一门非常灵活的<strong>动态语言</strong>，很多在其他语言看起来完全不能容忍的事情在Python当中是可行的，这也是Python的设计理念，为了灵活和代码方便牺牲了效率。比如我们来看一个很简单的例子，由于Python是动态语言，所以类的成员甚至可以在类创建好了之后动态创建。这在静态语言当中是绝对不行的，我们只能调用类当中已有的属性，是<strong>不能或者很难</strong>添加新属性的。</p><p>比如这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = <span class="literal">None</span></span><br><span class="line">        self.b = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp = Exp()</span><br><span class="line">    exp.c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(exp.c)</span><br></pre></td></tr></table></figure><p>我们定义了一个类叫做<code>Exp</code>，我们为它创建了a和b两个成员。但是我们在使用的时候，<strong>对c成员进行了赋值</strong>。要知道<code>Exp</code>类当中是没有成员c的，但是程序并不会报错，我们这么运行了之后它会将c添加进这个实例当中。</p><p>从一方面来看，这当然非常灵活，但是另一方面，这也留下了<strong>隐患</strong>。如果用户随意添加属性，可能会导致未知的问题，尤其在复杂的系统当中。所以有些时候为了严谨，我们会不希望用户做这种动态的修改。<code>__slots__</code>正是用来做这个的。</p><p>我们把这个关键字加上，再来运行结果就不一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>:</span><br><span class="line"></span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = <span class="literal">None</span></span><br><span class="line">        self.b = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp = Exp()</span><br><span class="line">    exp.c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(exp.c)</span><br></pre></td></tr></table></figure><p>如果你运行这段代码的话，你会得到一个报错，<strong>提示你<code>Exp</code>这个对象当中并没有c这个成员</strong>，也就是说我们只能运用<code>__slots__</code>这个关键字当中定义的成员，对于没有定义的成员不能随意创建，这样就限制了用户的使用。</p><p>虽然现在大部分人使用这个关键字都是报着这个目的，但是很遗憾的是，Python创建者的初衷其实并不是这个。这就谈到了<code>__slots__</code>关键字的第二个作用，就是<strong>节省内存</strong>。</p><p>如果了解过Python底层的实现原理，你会发现在Python当中<strong>为每一个实例都创建了一个字典</strong>，就是大名鼎鼎的<code>__dict__</code>字典。正是因为背后有一个字典，所以我们才可以创造出原本不存在的成员，也才支持这样动态的效果。我们可以人工地调用这个字典输出其中的内容，我们在加上<code>__slots__</code>关键字之前，输出的结果是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;b&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure><p>但是加上了这个关键字之后，会<strong>得到一个报错</strong>，会告诉你<code>Exp</code>这个对象当中没有<code>__dict__</code>这个成员。原因很简单，因为使用<code>dict</code>来维护实例，会消耗大量的内存，额外存储了许多数据，而使用<code>__slots__</code>之后，Python内部将不再为实例创建一个字典来维护，而是会使用一个固定大小的数组，这样就节省了大量的空间。这个节省可不是一点半点，一般可以<strong>节省一半以上</strong>。也就是说牺牲了一定的灵活性，保证了性能。这一点也是<code>__slots__</code>这个关键字设计的初衷，但是现在很多人都用错了地方。</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>这个关键字在的文章当中曾经提到过，不过很不好意思的是，由于之前写文章的时候对它的了解还很有限，导致一些阐述存在一些谬误，所以这里再提一下这个关键字的运用作为弥补。</p><p><code>property</code>可以帮我们<strong>绑定类当中一些属性的赋值和获取</strong>，也就是<code>get</code>和<code>set</code>。我们来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, param</span>):</span><br><span class="line">        self.param = param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @param.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._param = value</span><br></pre></td></tr></table></figure><p>这里的<code>property</code>注解会在我们调用<code>.param</code>的时候被执行，而<code>param.setter</code>会在我们为<code>param</code>这个属性赋值的时候被执行。所以你可能会奇怪，为什么我们在<code>__init__</code>方法当中初始化的时候用的是<code>self.param = param</code>而不是<code>self._param = param</code>，这是因为我们在执行前者的时候，Python<strong>一样会调用<code>@param.setter</code></strong>这个注解，所以我们没有必要写成后者的形式。当然你也可以这么写，不过两者是完全等价的。</p><p>作为一个前Java程序员<strong>为类当中所有变量加上get和set方法</strong>几乎成了政治正确，所以我特别喜欢为类当中所有的属性加上<code>property</code>。但是<strong>这是不对的</strong>，加上property是非常耗时的，所以如非必要不要这么做，我们直接调用来进行赋值就好了，如果有必要，我们可以手动写上<code>get</code>和<code>set</code>方法。那么问题来了，既然不是为了规范，那么我们又为什么要用到<code>property</code>呢？</p><p>答案很简单，为了<strong>校验变量类型</strong>。</p><p>由于Python是动态语言，并且是隐式类型的，所以我们拿到变量的时候并不知道它究竟是什么类型，也不知道用户为给它赋值成什么类型。所以在一些情况下我们可能会希望做好限制，告诉用户只能将这个变量赋值成这个类型，否则就会报错。通过使用<code>property</code>，我们可以很方便地做到这点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, param</span>):</span><br><span class="line">        self.param = param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @param.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Want a string&#x27;</span>)</span><br><span class="line">        self._param = value</span><br></pre></td></tr></table></figure><p>除此之外，<code>property</code>还有一个用法是<strong>代替函数</strong>。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, param</span>):</span><br><span class="line">        self.param = param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._param</span><br><span class="line"></span><br><span class="line"><span class="meta">    @param.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Want a string&#x27;</span>)</span><br><span class="line">        self._param = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello &#x27;</span> + self.param</span><br></pre></td></tr></table></figure><p>这样我们就可以通过<code>.hello</code>来代替调用一个函数，这样做其实是一种<strong>动态计算</strong>。hello的结果并没有被存储起来，之后当我们调用的时候才会执行，在一些场景下这样做会非常方便。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>最后我们来看下Python对象当中的命名规范，在之前的文章当中我们曾经说过，在Python当中没有对<code>public</code>和<code>private</code>的字段做区分，<strong>所有的字段都是<code>public</code>的</strong>，也就是说用户可以拿到类当中所有的字段和方法。为了规范，程序员们约定俗成，决定所有<strong>加了下划线的方法和变量都看成是<code>private</code></strong>的，即使我们能调用，但是一般情况下我们也不这么干。</p><p>所以我们通常会写两个方法，一个是公开的接口，一个是内部的实现。我们调用的时候只调用公开的接口，公开的接口再去调用内部的实现。这在Python当中已经成了惯例，因为我们在调用内部方法的时候，往往还会传入一些内部的参数。</p><p>我们来看个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExpA</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_func</span>(<span class="params">self</span>):</span><br><span class="line">       self._private_func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_private_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;private ExpA&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp = ExpA()</span><br><span class="line">    exp.public_func()</span><br></pre></td></tr></table></figure><p>除了_之外我们经常还会看到一些<strong>两个下划线的变量和方法</strong>，那么它们之间又有什么区别呢？</p><p>为了回答这个问题，我们来看下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExpA</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_func</span>(<span class="params">self</span>):</span><br><span class="line">       self.__private_func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;private ExpA&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpB</span>(<span class="title class_ inherited__">ExpA</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_func</span>(<span class="params">self</span>):</span><br><span class="line">       self.__private_func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;private ExpB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp = ExpB()</span><br><span class="line">    exp.public_func()</span><br><span class="line">    exp._ExpB__private_func()</span><br><span class="line">    exp._ExpA__private_func()</span><br></pre></td></tr></table></figure><p>请问最后会输出什么？</p><p>我们试一下就知道，第一行输出的是<code>private ExpB</code>，这个没有问题。但是后面两个是什么？</p><p>后面两个就是<code>__private_func</code>，只不过<strong>系统自动将它重新命名</strong>了。重新命名的原因也很简单，因为Python<strong>禁止加了两个下划线的方法被子类覆盖</strong>。所以这两者的区别就在这里，它们都被认为是<code>private</code>的方法和属性，但是一个下划线允许子类覆盖，而两个下划线不行。所以如果我们在开发的时候希望我们某一个方法不会被子类覆盖，那么我们就需要加上两个下划线。</p><p>最后，我们来看一个小问题。在C++当中当我们的变量名和系统的关键字冲突的时候，我们往往会在变量前面加上一个_来作为区分。但是由于Python当中下划线被赋予了含义，所以我们不能这么干，那么当变量冲突的时候应该怎么办呢？答案也很简单，我们可以<strong>把下划线加在后面</strong>，比如<code>lambda_</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下今天的内容，主要是<code>__slots__</code>, <code>property</code>和下划线在类当中的使用。这三者都是Python面向对象当中<strong>经常用到</strong>的知识，了解它们不但可以让我们写出更规范的代码，也有助于帮助我们理解其他大牛的源码，因此是非常必要的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中对象的输入方法</title>
      <link href="/2023/04/16/python-class/"/>
      <url>/2023/04/16/python-class/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来聊聊Python当中的类。</p><h2 id="打印实例"><a href="#打印实例" class="headerlink" title="打印实例"></a>打印实例</h2><p>我们先从类和对象当中最简单的打印输出开始讲起，打印一个实例是一个非常不起眼的应用，但是在实际的编程当中却非常重要。原因也很简单，因为我们debug的时候往往会想看下某个类当中的内容是不是符合我们的预期。但是我们直接<code>print</code>输出的话，只会得到一个地址。</p><p>我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p>在这段代码当中我们定义了一个简单的类，它当中有x和y两个元素，但是如果我们直接运行的话，屏幕上会输出这样一个结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.point object at 0x10a18c210&gt;</span><br></pre></td></tr></table></figure><p>这个是解释器在执行的时候这个实例的一些相关信息，但是对于我们来说几乎没有参考意义，我们想要的是这个实例当中具体的值，而不是一个内存当中的地址。</p><p>想要实现这个功能，我们有很多方法，下面我们一一来看。</p><h2 id="str-方法"><a href="#str-方法" class="headerlink" title="__str__方法"></a>__str__方法</h2><p><code>__str__</code>方法大家应该都不陌生，它类似于Java当中的<code>toString</code>方法，可以根据我们的需要返回实例转化成字符串之后的结果。</p><p>比如，我们可以在类当中重载这个方法，就可以根据我们的需要输出结果了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br></pre></td></tr></table></figure><p>当我们运行它，得到的结果会是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: 3, y: 4</span><br></pre></td></tr></table></figure><p><code>__str__</code>和<code>__init__</code>, <code>__len__</code>很多函数一样是Python中的特殊函数，在我们创建类的时候，系统会我们隐式创造许多这样的特殊函数。我们可以根据需要重载其中的一部分完成我们想要的功能。比如如果我们写的是一棵二叉树的类，我们还可以在<code>__str__</code>函数当中进行递归遍历所有的节点，打印出完整的树来。</p><h2 id="repr-方法"><a href="#repr-方法" class="headerlink" title="__repr__方法"></a>__repr__方法</h2><p>你也许可能也听说过<code>__repr__</code>函数，它也可以实现根据我们的需要自定义输出的功能。比如我们把上面的代码改下函数名，也可以得到一样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br></pre></td></tr></table></figure><p>我们运行它，同样会得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: 3, y: 4</span><br></pre></td></tr></table></figure><p>这是为什么呢，难道<code>__repr__</code>和<code>__str__</code>是一样的吗？如果是一样的，Python的设计者干嘛要保留两个完全相同的函数呢，为什么不去掉其中一个呢？</p><p>在分析原因之前，我们先来做一个实验，如果我们两个函数都重载，那么当我们输出的时候，程序执行的是哪一个呢？为了做好区分，我们把<code>__repr__</code>当中的输出的格式稍微修改一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;point x: %s, y: %s&gt;&#x27;</span> % (self.x, self.y)</span><br></pre></td></tr></table></figure><p>我们运行之后，会发现输出的结果还是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: 3, y: 4</span><br></pre></td></tr></table></figure><p>先别着急下结论，我们再把这段代码拷贝到jupyter当中，我们这次不通过打印输出，而通过jupyter自带的交互框输出交互结果，我们再来看下：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/F0DF91A9085CFCBBF35109399138A91C.jpg" alt="IMAGE"></p><p>奇怪，怎么结果就变成了<code>__repr__</code>的结果了呢？</p><p>其实这正是反应了两者的区别，如果简单理解，这两个函数都是将一个实例转成字符串。但是不同的是，两者的使用场景不同，其中<code>__str__</code>更加侧重展示。所以当我们<code>print</code>输出给用户或者使用<code>str</code>函数进行类型转化的时候，Python都会默认优先调用<code>__str__</code>函数。而<code>__repr__</code>更侧重于这个实例的报告，除了实例当中的内容之外，我们往往还会附上它的类相关的信息，因为这些内容是给开发者看的。所以当我们在交互式窗口输出的时候，它会优先调用<code>__repr__</code>。</p><p>理论上来说，对于一个合格的<code>__repr__</code>函数要能够做到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="built_in">repr</span>(obj)) == obj</span><br></pre></td></tr></table></figure><p>也就是说我们通过<code>__repr__</code>输出的内容执行之后可以再还原得到这个实例本身，当然在一些场景下这个非常难以实现，所以我们退而求其次，保证<code>__repr__</code>当中输出类和对象足够多的信息，方便开发者调试和使用即可。</p><p>另外多说一句，repr是report的缩写，所以它有一个报告的意思在里面，而<code>str</code>就只是转化成字符串而已。这两者还是有一定区别的。</p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>Python当中最常用的输出函数除了上面两个之外，还有一个就是format。</p><p>比较简单的用法就是通过{}代表变量，然后按照顺序依次输入：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/259DE04CA4CD1C228F877AA839942A0F.jpg" alt="IMAGE"></p><p>除此之外，我们还可以进一步写明花括号里的变量名称，进一步增加可读性：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/4611B780C0BF25F39E2183CA7F83A7C5.jpg" alt="IMAGE"></p><p>format的功能远不止如此，它还支持许多参数，类似于C语言当中的<code>printf</code>，可以通过不同的参数做到各种各样的输出。比如控制小数点后面保留的位数，或者是转化成百分数、科学记数法、左右对齐等功能。这里不一一列举了，大家用到的时候再查询即可。</p><p>我们当然可以使用format重新<code>__repr__</code>和<code>__str__</code>当中的逻辑，但这并不能体现它的强大。因为在Python当中，也为类提供了<strong>format</strong>这个特殊函数，通过重写<code>__format__</code>和使用format，我们可以做到更牛的功能。</p><h2 id="format联合-format"><a href="#format联合-format" class="headerlink" title="format联合__format__"></a>format联合__format__</h2><p>我们可以在类当中重载<code>__format__</code>函数，这样我们就可以在外部直接通过format函数来调用对象，输出我们想要的结果。</p><p>我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, code</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: &#123;x&#125;, y: &#123;y&#125;&#x27;</span>.<span class="built_in">format</span>(x = self.x, y = self.y)</span><br></pre></td></tr></table></figure><p>我们把刚才的<strong>repr</strong>改成了<strong>format</strong>，但是需要注意一个细节，我们多加了一个参数<code>code</code>，这是由于format当中支持通过参数来对处理逻辑进行配置的功能，所以我们必须要在接口处多加一个参数。加好了以后，我们就可以直接调用<code>format(p)</code>了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1gfndypuhdpj30qi03ut95.jpg" alt="IMAGE"></p><p>到这里还没有结束，在有些场景当中，对于同一个对象我们可能有多种输出的格式。比如点，在有些场景下我们可能希望输出<code>(x, y)</code>，有时候我们又希望输出<code>x: 3, y: 4</code>，可能还有些场景当中，我们希望输出<code>&lt;x, y&gt;</code>。</p><p>我们针对这么多场景，如果各自实现不同的接口会非常麻烦。这个时候利用<code>__format__</code>当中的这个参数，就可以大大简化这个过程，我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">formats = &#123;</span><br><span class="line">    <span class="string">&#x27;normal&#x27;</span>: <span class="string">&#x27;x: &#123;p.x&#125;, y: &#123;p.y&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;point&#x27;</span> : <span class="string">&#x27;(&#123;p.x&#125;, &#123;p.y&#125;)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prot&#x27;</span>: <span class="string">&#x27;&lt;&#123;p.x&#125;, &#123;p.y&#125;&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, code</span>):</span><br><span class="line">        <span class="keyword">return</span> formats[code].<span class="built_in">format</span>(p=self)</span><br></pre></td></tr></table></figure><p>我们在调用的时候就可以通过参数来控制我们究竟使用哪一种格式来格式化对象了：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/C7FD3E3389121B55668BADE246513F51.jpg" alt="IMAGE"></p><p>也就是说通过重载<code>__format__</code>方法，我们把原本固定的格式化的逻辑做成了可配置的。这样大大增加了我们使用过程当中的灵活性，这种灵活性在一些问题场景当中可以大大简化和简洁我们的代码。对于Python这门语言来说，我个人感觉实现功能只是其中很小的一个部分，把代码写得简洁美观，才是其中的大头。这也是为什么很多人都说Python是一门易学难精的语言的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slack安装教程</title>
      <link href="/2023/04/06/slack-install/"/>
      <url>/2023/04/06/slack-install/</url>
      
        <content type="html"><![CDATA[<h1 id="Slack-安装教程"><a href="#Slack-安装教程" class="headerlink" title="Slack 安装教程"></a>Slack 安装教程</h1><p>包含Windows、MAC、IOS、android</p><h2 id="WINDOWS"><a href="#WINDOWS" class="headerlink" title="WINDOWS"></a>WINDOWS</h2><ol><li>打开电脑自带的<strong>应用商店</strong>（Microsoft Store）；</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134138036.png" alt=""></p><ol><li>搜索栏搜索<strong>slack</strong>并点击右侧“<strong>获取</strong>”</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134232251.png" alt=""></p><ol><li>下载完成后点击“<strong>打开</strong>”</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134252596.png" alt=""></p><ol><li>点击<strong>登录（Sign</strong> <strong>in），</strong>跳转到浏览器界面，选择<strong>邮箱登录（Sign</strong> <strong>in</strong> <strong>with</strong> <strong>Email）</strong></li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134345237.png" alt=""></p><ol><li>点击分享的邀请链接（<a href="https://aidialogue.slack.com/join/shared_invite/zt-1s8rkrclc-eumSRFQ7kxdlyY1VQ4S0BA#/shared-invite/email">注册链接</a>），<strong>使用电子邮件继续（Continue</strong> <strong>with Email</strong>）</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134412975.png" alt=""></p><ol><li>注册账户，设置密码，登录进入AI Dialogue slack社区</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134431159.png" alt=""></p><ol><li>访问<a href="https://www.ailinghang.club/2023/04/05/slack-guide/">ai-bot使用教程</a>，了解如何使用和付费</li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><ol><li>点击电脑桌面App Store</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134513295.png" alt=""></p><ol><li>搜索slack，点击GET，获取软件</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134526504.png" alt=""></p><ol><li>下载完成后点击打开</li><li>点击<strong>登录（Sign</strong> <strong>in），</strong>跳转到浏览器界面，选择<strong>邮箱登录（Sign</strong> <strong>in</strong> <strong>with</strong> <strong>Email）</strong></li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134559482.png" alt=""></p><ol><li>点击分享的邀请链接（<a href="https://aidialogue.slack.com/join/shared_invite/zt-1s8rkrclc-eumSRFQ7kxdlyY1VQ4S0BA#/shared-invite/email">注册链接</a>），<strong>使用电子邮件继续（Continue</strong> <strong>with Email</strong>）</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134622363.png" alt=""></p><ol><li>注册账户，设置密码，登录进入AI Dialogue 社区</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406134647620.png" alt=""></p><ol><li>访问<a href="https://www.ailinghang.club/2023/04/05/slack-guide/">ai-bot使用教程</a>，了解如何使用和付费</li></ol><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><ol><li>点击苹果应用商店（APP Store）</li><li>搜索slack、下载并打开</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps1.jpg" alt=""> </p><ol><li><p>如上windows第四步，用邮箱注册账号</p></li><li><p>点击分享的邀请链接（<a href="https://aidialogue.slack.com/join/shared_invite/zt-1s8rkrclc-eumSRFQ7kxdlyY1VQ4S0BA#/shared-invite/email">注册链接</a>），<strong>使用电子邮件继续（Continue</strong> <strong>with Email</strong>）</p></li><li><p>跳转slack，进入AI Dialogue社区</p></li><li>访问<a href="https://www.ailinghang.club/2023/04/05/slack-guide/">ai-bot使用教程</a>，了解如何使用和付费</li></ol><h2 id="ANDROID"><a href="#ANDROID" class="headerlink" title="ANDROID"></a>ANDROID</h2><p><strong>备注</strong>：各大品牌手机的应用商店里面可能没有上架slack应用，如果手机里已经安装过Google Play可以直接下载，如果没有的话，可以打开浏览器登录一下网址：</p><p><a href="https://apkpure.com/slack/com.Slack">https://apkpure.com/slack/com.Slack</a></p><p>（！！！！！！ <strong>下载的时候，务必小心广告</strong>！！！！！！）</p><p>下载完成之后，直接点击继续安装，由于不是应用商店的应用，需要输入一次锁屏密码，实现继续安装。</p><ol><li>输入上述网址，直接下载安装包</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps2.jpg" alt=""> </p><ol><li><p>点击slack应用，准备下载</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406135231921.png" alt=""></p></li><li><p>注意别点击广告，<strong>下滑</strong>选择正确的下载对象</p></li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps6.jpg" alt="">     <img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps7.jpg" alt="img"></p><ol><li>下载完成后，直接点击安装</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps8.jpg" alt=""> </p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps9.jpg" alt=""> </p><ol><li>点击分享的邀请链接（<a href="https://aidialogue.slack.com/join/shared_invite/zt-1s8rkrclc-eumSRFQ7kxdlyY1VQ4S0BA#/shared-invite/email">注册链接</a>），<strong>使用电子邮件继续（Continue</strong> <strong>with Email</strong>）</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps10.jpg" alt="">         <img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps11.jpg" alt=""></p><ol><li>切换到手机端slack，点击登录，选用工作区网址登录（aidialogue.slack.com）</li></ol><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps12.jpg" alt="">   <img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/wps13.jpg" alt=""></p><ol><li><p>输入创建的账户（邮箱地址）与密码，进入AI Dialogue之后尽情畅玩</p></li><li><p>访问<a href="https://www.ailinghang.club/2023/04/05/slack-guide/">ai-bot使用教程</a>，了解如何使用和付费</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无需科学上网，使用ChatGPT</title>
      <link href="/2023/04/05/slack-guide/"/>
      <url>/2023/04/05/slack-guide/</url>
      
        <content type="html"><![CDATA[<p>大家好，欢迎来到Ai Dialogue社区。</p><p>鉴于有些小伙伴对于如何使用slack以及ai-bot还不太清楚，所以写了本教程希望能帮助大家答疑解惑。</p><h2 id="ai-bot是什么？"><a href="#ai-bot是什么？" class="headerlink" title="ai-bot是什么？"></a>ai-bot是什么？</h2><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405171951752.png" alt=""></p><p>ai-bot是Ai Dialogue社区基于openai的api开发的人工智能聊天机器人，旨在帮助大家解决因为网络以及账号问题无法使用ChatGPT的困扰。</p><h2 id="如何使用ai-bot？"><a href="#如何使用ai-bot？" class="headerlink" title="如何使用ai-bot？"></a>如何使用ai-bot？</h2><p>在聊天框中输入@符号，再选中ai-bot，后面输入你的对话或问题即可。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172136492.png" alt=""></p><p>如：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172304254.png" alt=""></p><p>等待一小段时间之后，ai-bot会在同一个Thread中回复（方便查看），点击蓝色的<code>reply</code>即可看到ai-bot的回复。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172339634.png" alt=""></p><p>如有需要还可以在同一个聊天框中继续对话：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172603500.png" alt=""></p><p>普通用户可以在<code>general, random</code>群中与ai-bot自由对话。pro用户可以与ai-bot 1v1私聊对话，并且能开启ai-bot上下文记忆功能。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172826784.png" alt=""></p><p>新用户免费获得15条私聊服务，点开ai-bot之后，会自动返回当前会员以及当前免费额度使用情况：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230415212830605.png" alt=""></p><p>每邀请一名新同学加入社区，双方均可获得15次聊天额度以及10次绘画额度。</p><p>邀请方法：</p><ul><li>对方下载安装slack</li><li>通过邀请链接加入社区：<a href="https://aidialogue.slack.com/ssb/redirect#/shared-invite/email">邀请链接</a></li><li>加入之后，通过命令<code>/ticket + 邀请码</code>完成邀请</li></ul><p>邀请码在ai-bot主页查看，每人只能被邀请一次，邀请对象不限量</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230415215407930.png" alt=""></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>除了聊天之外，我们还为ai-bot开发了一些常用的命令功能。</p><p>要使用命令，需要先打开ai-bot的聊天框（私聊ai-bot）。搜索栏中搜索ai-bot：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230406195137559.png" alt=""></p><p>在聊天框中输入<code>/</code>，会弹出一个单独的输入框用来输入命令：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230415215631248.png" alt=""></p><p>我们选中我们想要执行的命令，加上合适的参数即可。</p><h3 id="ticket-命令"><a href="#ticket-命令" class="headerlink" title="/ticket 命令"></a>/ticket 命令</h3><p><code>/ticket</code>命令用来完成邀请，后面跟邀请人的邀请码</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230415220237681.png" alt=""></p><h3 id="chat-命令"><a href="#chat-命令" class="headerlink" title="/chat 命令"></a>/chat 命令</h3><p><code>/chat</code>用来延长或购买基础会员，后面跟上想要购买的月数。如：<code>/chat 3</code>表示购买三个月，三个月起购。</p><p>注意，<code>/chat</code>命令只能用来购买基础会员，如果已经是<code>pro</code>会员，需要使用<code>/chatpro</code>命令，或者可以等<code>pro</code>会员到期之后再购买。</p><p>命令输入之后，ai-bot会返回付款二维码，使用支付宝付款即可。</p><h3 id="chatpro-命令"><a href="#chatpro-命令" class="headerlink" title="/chatpro 命令"></a>/chatpro 命令</h3><p>用法和<code>/chat</code>命令一样，用来进行<code>pro</code>会员的购买和续费。</p><p>如果已经是基础会员且没有到期，那么收取的是升级的费用，<strong>会自动将剩余的日期升级成<code>pro</code>会员，会扣除基础会员的差价</strong>。</p><p>付款成功之后支付宝会自动跳转，<strong>不要着急退出！！！</strong>看到支付成功的文案就表示购买成功了。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405174225747.png" alt=""></p><h3 id="translator-tourist-dictionary-interviewer"><a href="#translator-tourist-dictionary-interviewer" class="headerlink" title="/translator, /tourist, /dictionary, /interviewer"></a>/translator, /tourist, /dictionary, /interviewer</h3><p>切换ai角色，目前仅对pro会员开放</p><p>其中translator为翻译官，可以翻译以及润色文案。</p><p>tourist是旅行家， 可以提供旅行线路建议</p><p>dictionary是词典，可以查询单词返回例句</p><p>interviewer是Java面试官，可以模拟Java面试</p><h3 id="英文聊天"><a href="#英文聊天" class="headerlink" title="英文聊天"></a>英文聊天</h3><p>直接发送语音消息，可以进行英文聊天，仅开放给pro会员。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230415221853711.png" alt=""></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="会有使用次数限制吗？"><a href="#会有使用次数限制吗？" class="headerlink" title="会有使用次数限制吗？"></a>会有使用次数限制吗？</h3><p>没有次数和条数限制，大家可以自由使用。</p><h3 id="ai-bot之后提示没有注册"><a href="#ai-bot之后提示没有注册" class="headerlink" title="@ai-bot之后提示没有注册"></a>@ai-bot之后提示没有注册</h3><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230405172423008.png" alt=""></p><p>这是因为没有购买会员功能，slack本身是工作聊天工具（类似钉钉），注册slack是免费的。而ai-bot是我们AI Dialogue搭建和研发的，并且还有服务器以及账号等支出，因此需要收取一定的费用。只是注册slack是不够的，需要购买ai-bot会员服务。</p><p>购买的方法见上文<code>/chat</code>和<code>/chatpro</code>命令的相关介绍。</p><h3 id="我可以私人建群并且邀请ai-bot进群吗？"><a href="#我可以私人建群并且邀请ai-bot进群吗？" class="headerlink" title="我可以私人建群并且邀请ai-bot进群吗？"></a>我可以私人建群并且邀请ai-bot进群吗？</h3><p>不可以，虽然使用slack是免费的，但我们建立slack圈子也是收费的，并且费用还不低。如果要允许私人建群的话，我们暂时无力承担这么高的成本，所以暂时不开放私人群的功能。</p><p>祝大家使用愉快，使用过程当中如果有任何问题，请与管理员@Lingo, @Liang, @atiyah联系，我们会尽我们所能回答你的问题。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程与闭包</title>
      <link href="/2023/04/01/python-8/"/>
      <url>/2023/04/01/python-8/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>函数式编程</strong>这个概念我们可能或多或少都听说过，刚听说的时候不明觉厉，觉得这是一个非常黑科技的概念。但是实际上它的含义很朴实，但是延伸出来许多丰富的用法。</p><p>在早期编程语言还不是很多的时候，我们会将语言分成<strong>高级语言与低级语言</strong>。比如汇编语言，就是低级语言，几乎什么封装也没有，做一个赋值运算还需要我们手动调用寄存器。而高级语言则从这些面向机器的指令当中抽身出来，转而面向过程或者是对象。也就是说我们写代码面向的是一段计算过程或者是一个计算机当中抽象出来的对象。如果你学过面向对象，你会发现和面向过程相比，面向对象的抽象程度更高了一些，做了更加完善的封装。</p><p>在面向对象之后呢，我们还可以做什么封装和抽象呢？这就轮到了函数式编程。</p><p>函数我们都了解，就是我们定义的一段程序，它的输入和输出都是确定的。我们把一段函数写好，它可以在任何地方进行调用。既然函数这么好用，那么能不能<strong>把函数也看成是一个变量进行返回和传参</strong>呢？</p><p>OK，这个就是函数式编程最直观的特点。也就是说我们写的一段函数也可以作为变量，既可以用来赋值，还可以用来传递，并且还能进行返回。这样一来，大大方便了我们的编码，但是这并不是有利无害的，相反它带来许多问题，最直观的问题就是由于函数传入的参数还可以是另一个函数，这会<strong>导致函数的计算过程变得不可确定</strong>，许多超出我们预期的事情都有可能发生。</p><p>所以函数式编程是有利有弊的，它的确简化了许多问题，但也产生了许多新的问题，我们在使用的过程当中需要谨慎。</p><h2 id="传入、返回函数"><a href="#传入、返回函数" class="headerlink" title="传入、返回函数"></a>传入、返回函数</h2><p>在我们之前介绍<code>filter</code>、<code>map</code>、<code>reduce</code>以及自定义排序的时候，其实我们已经用到了函数式编程的概念了。</p><p>比如在我们调用sorted进行排序的时候，如果我们传入的是一个对象数组，我们希望根据我们制定的字段排序，这个时候我们往往需要传入一个<strong>匿名函数</strong>，用来制定排序的字段。其实传入的匿名函数，其实就是函数式编程最直观的体现了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(kids, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure><p>除此之外，我们还可以返回一个函数，比如我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delay_sum</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s += i</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>如果这个时候我们调用<code>delay_sum</code>传入一串数字，我们会得到什么？</p><p>答案是一个函数，我们可以直接输出，从打印信息里看出这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>delay_sum([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">&lt;function delay_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x1018659e0</span>&gt;</span><br></pre></td></tr></table></figure><p>我们想获得这个运算结果应该怎么办呢？也很简单，我们用一个变量去接收它，然后执行这个新的变量即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = delay_sum([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>这样做有一个好处是我们可以<strong>延迟计算</strong>，如果不使用函数式编程，那么我们需要在调用<code>delay_sum</code>这个函数的时候就计算出结果。如果这个运算量很小还好，如果这个运算量很大，就会造成开销。并且当我们计算出结果来之后，这个结果也许不是立即使用的，可能到很晚才会用到。既然如此，我们返回一个函数代替了运算，当后面真正需要用到的时候再执行结果，从而延迟了运算。这也是很多计算框架的常用思路，比如<strong>spark</strong>。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我们再来回顾一下我们刚才举的例子，在刚才的<code>delay_sum</code>函数当中，我们内部实现了一个<code>sum</code>函数，我们在这个函数当中调用了<code>delay_sum</code>函数传入的参数。这种对<strong>外部作用域</strong>的变量进行引用的内部函数就称为<strong>闭包</strong>。</p><p>其实这个概念很形象，因为这个函数内部调用的数据对于调用方来说是封闭的，完全是一个黑盒，除非我们查看源码，否则我们是不知道它当中数据的来源的。除了不知道来源之外，更重要的是它引用的是外部函数的变量，既然是变量就说明是动态的。也就是说我们<strong>可以通过改变某些外部变量的值来改变闭包的运行效果</strong>。</p><p>这么说有点拗口，我们来看一个简单的例子。在Python当中有一个函数叫做<code>math.pow</code>其实就是计算次方的。比如我们要计算<code>x</code>的平方，那么我们应该这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.<span class="built_in">pow</span>(x, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>但是如果我们当前场景下只需要计算平方，我们每次都要传入额外再传入一个2会显得非常麻烦，这个时候我们使用闭包，可以简化操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mypow</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pw</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> math.<span class="built_in">pow</span>(x, num)</span><br><span class="line">    <span class="keyword">return</span> pw</span><br><span class="line">    </span><br><span class="line">pow2 = mypow(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(pow2(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>通过闭包，我们<strong>把第二个变量给固定了</strong>，这样我们只需要使用<code>pow2</code>就可以实现原来<code>math.pow(x, 2)</code>的功能了。如果我们突然需求变更需要计算3次方或者是4次方，我们只需要修改<code>mypow</code>的传入参数即可，完全不需要修改代码。</p><p>实际上这也是闭包最大的使用场景，我们可以<strong>通过闭包实现一些非常灵活的功能</strong>，以及通过配置修改一些功能等操作，而不再需要通过代码写死。要知道对于工业领域来说，线上的代码是不能随便变更的，尤其是客户端，比如apple store或者是安卓商店当中的软件包，只有用户手动更新才会拉取。如果出现问题了，几乎没有办法修改，只能等用户手动更新。所以常规操作就是使用一些类似闭包的灵活功能，<strong>通过修改配置的方式改变代码的逻辑</strong>。</p><p>除此之外闭包还有一个用处是可以<strong>暂存变量或者是运行时的环境</strong>。</p><p>举个例子，我们来看下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">x=<span class="number">0</span></span>):</span><br><span class="line">    x += <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>这是没有使用闭包的函数，不管我们调用多少次，答案都是5，执行完<code>x+=5</code>之后的结果并不会被保存起来，当函数返回了，这个暂存的值也就被抛弃了。那如果我<strong>希望每次调用都是依据上次调用的结果</strong>，也就是说我们每次修改的操作都能保存起来，而不是丢弃呢？</p><p>这个时候就需要使用闭包了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x += <span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">    </span><br><span class="line">t = test()</span><br><span class="line">t()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span></span><br><span class="line">t()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span></span><br></pre></td></tr></table></figure><p>也就是说我们的<code>x</code>的值被存储起来了，<strong>每次修改都会累计</strong>，而不是丢弃。这里需要注意一点，我们用到了一个新的关键字叫做<strong>nonlocal</strong>，这是Python3当中独有的关键字，用来申明当前的变量<code>x</code>不是局部变量，这样Python解释器就会去全局变量当中去寻找这个<code>x</code>，这样就能关联上<code>test</code>方法当中传入的参数x。Python2官方已经不更新了，不推荐使用。</p><p>由于在Python当中也是一切都是对象，如果我们<strong>把闭包外层的函数看成是一个类</strong>的话，其实闭包和类区别就不大了，我们甚至可以给闭包返回的函数关联函数，这样几乎就是一个对象了。来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>():</span><br><span class="line">    name = <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stu</span>():</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        name = value</span><br><span class="line">        </span><br><span class="line">    stu.set_name = set_name</span><br><span class="line">    <span class="keyword">return</span> stu</span><br><span class="line">    </span><br><span class="line">stu = student()</span><br><span class="line">stu.set_name(<span class="string">&#x27;xiaohong&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu())</span><br></pre></td></tr></table></figure><p>最后运算的结果是<code>xiaohong</code>，因为我们调用<code>set_name</code>改变了闭包外部的值。这样当然是可以的，但是一般情况下我们并不会用到它。和写一个<code>class</code>相比，通过闭包的方法<strong>运算速度会更快</strong>。原因比较隐蔽，是因为闭包当中没有<code>self</code>指针，从而节省了大量的变量的访问和运算，所以计算的速度要快上一些。但是闭包搞出来的伪对象是<strong>不能使用继承、派生</strong>等方法的，而且和正常的用法格格不入，所以我们知道有这样的方法就可以了，现实中并不会用到。</p><h2 id="闭包的坑"><a href="#闭包的坑" class="headerlink" title="闭包的坑"></a>闭包的坑</h2><p>闭包虽然好用，但是不小心的话也是很容易踩坑的，下面介绍几个常见的坑点。</p><h3 id="闭包不能直接访问外部变量"><a href="#闭包不能直接访问外部变量" class="headerlink" title="闭包不能直接访问外部变量"></a>闭包不能直接访问外部变量</h3><p>这一点我们刚才已经提到了，在闭包当中我们<strong>不能直接访问外部的变量</strong>的，必须要通过nonlocal关键字进行标注，否则的话是会报错的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t</span>():</span><br><span class="line">        n += <span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><p>比如这样的话，就会报错：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/4lVbQH4ShicUH5Q5NIVsAdDjMiaw795L44EwzeJicNRQu45vvgjCjCPiaHHhuudDK38YciaFDqzLHT90KBBdTWMw9YA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><h3 id="闭包当中不能使用循环变量"><a href="#闭包当中不能使用循环变量" class="headerlink" title="闭包当中不能使用循环变量"></a>闭包当中不能使用循环变量</h3><p>闭包有一个很大的问题就是<strong>不能使用循环变量</strong>，这个坑藏得很深，因为单纯从代码的逻辑上来看是发现不了的。也就是说逻辑上没问题的代码，运行的时候往往会出乎我们的意料，这需要我们对底层的原理有深刻地了解才能发现，比如我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">            <span class="keyword">return</span> x + i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs = test(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">    <span class="built_in">print</span>(f())</span><br></pre></td></tr></table></figure><p>在上面这个例子当中，我们使用了<code>for</code>循环来创建了3个闭包，我们使用<code>fs</code>存储这三个闭包并进行返回。然后我们通过调用<code>test</code>，来获得了这3个闭包，然后我们进行了调用。</p><p>这个逻辑看起来应该没有问题，按照道理，这3个闭包是通过for循环创建的，并且在闭包当中我们用到了循环变量<code>i</code>。那按照我们的想法，最终输出的结果应该是<code>[3, 4, 5]</code>，但是很遗憾，最后我们得到的<strong>结果是[5, 5, 5]</strong>。</p><p>看起来很奇怪吧，其实一点也不奇怪，因为<strong>循环变量<code>i</code>并不是在创建闭包的时候就set好的</strong>。而是当我们执行闭包的时候，我们再去寻找这个<code>i</code>对应的取值，显然当我们运行闭包的时候，循环已经执行完了，此时的<code>i</code>停在了2。所以这3个闭包的执行结果都是2+3也就是5。这个坑是由Python解释器当中对于闭包执行的逻辑导致的，我们编写的逻辑是对的，但是它并不按照我们的逻辑来，所以这一点要千万注意，如果忘记了，想要通过debug查找出来会很难。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然从表面上闭包存在一些问题和坑点，但是它依然是我们<strong>经常使用的Python高级特性</strong>，并且它也是很多其他高级用法的基础。所以我们理解和学会闭包是非常有必要的，千万不能因噎废食。</p><p>其实并不只是闭包，很多高度抽象的特性都或多或少的有这样的问题。因为当我们进行抽象的时候，我们固然简化了代码，增加了灵活度，但与此同时我们也让<strong>学习曲线变得陡峭</strong>，带来了更多我们需要理解和记住的内容。本质上这也是一个trade-off，好用的特性需要付出代码，易学易用的往往意味着比较死板不够灵活。对于这个问题，我们需要保持心态，不过好在初看时也许有些难以理解，但总体来说闭包还是比较简单的，我相信对你们来说一定不成问题。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器进阶用法</title>
      <link href="/2023/04/01/python-iterator/"/>
      <url>/2023/04/01/python-iterator/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们依然介绍的是迭代器，不过介绍的是几个比较常用的<strong>高级用法</strong>，在实际场景当中非常实用，可以帮助我们大大简化代码的复杂度。</p><h2 id="跳过开头"><a href="#跳过开头" class="headerlink" title="跳过开头"></a>跳过开头</h2><p>首先是跳过开始部分，这个在我们读取文本的时候最常用。在实际的应用当中，比如记录的日志或者是代码等等，一般来说<strong>头部都会附上一段说明</strong>，或者用注释标注或者是用特殊的符号标记。这些信息是给用到数据的程序员看的，当我们通过代码获取数据的时候，显然是希望可以过滤掉这些信息的。</p><p>比如我们有一段数据，它的开头用#做了一些注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a data for student</span></span><br><span class="line"><span class="comment"># Rows 100</span></span><br><span class="line"></span><br><span class="line">xiaoming, <span class="number">17</span>, <span class="number">99</span>;</span><br><span class="line">xiaoli, <span class="number">18</span>, <span class="number">98</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>常规操作当中，我们会创建一个打开文件的迭代器，我们通过遍历这个迭代器去获取文件当中的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxxx.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p>如果只是用来输出还好，如果我们需要加工文件当中的数据，那么头部的注释信息就会干扰我们代码的运行。我们当然可以手动加入一些判断，但是这会比较麻烦，代码也不够美观。针对这个问题，一个比较好的解决方案是<strong>dropwhile</strong>。</p><p><code>dropwhile</code>是<code>itemtools</code>当中的一个函数，它可以<strong>接收一个我们自定义的过滤函数和迭代器重新生成一个新的迭代器</strong>，这个新的迭代器当中会过滤掉之前迭代器头部不符合我们要求的数据：</p><p>在刚才的例子当中我们想要过滤掉头部加了#注释的部分，我们可以这么操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxxx.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> line: line.startswith(<span class="string">&#x27;#&#x27;</span>), f):</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p>这样出来的结果就没有头部我们不需要的内容了。</p><p>当我们知道头部不符合情况的数据的格式的时候，可以使用<code>dropwhile</code>来规定过滤的格式。如果我们<strong>知道需要过滤的条数</strong>，则可以使用另外一个工具，叫做<code>islice</code>，它的本质是一个切片函数，就像是Python当中数组的切片功能一样，可以切出迭代器当中指定片段的数据。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxxx.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> islice(f, <span class="number">3</span>, <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p>这样我们就会从第三行开始获取，之前的数据会被过滤掉。它其实就代表着数组当中[3: ]的切片操作。</p><h2 id="迭代排列组合"><a href="#迭代排列组合" class="headerlink" title="迭代排列组合"></a>迭代排列组合</h2><p>我们都知道在C++当中有一个叫做<code>next_permutation</code>的函数，可以传入一个数组，返回下一个字典序的排列。在Python当中也有同样的功能，但是是以迭代器的形式使用的。</p><p>举个简单的例子，比如我们有a, b, c三个元素，我们希望求出它的所有排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items):</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p><code>permutations</code>还支持多传一个参数，比如上述的排列当中我们希望只保留前两个元素，除了切片之外，我们只需要多传一个参数就好了，like this：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p>除了排列之外，<code>itertools</code>当中还支持组合，用法还是一样，只是把函数名称换成是<code>combinations</code>而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combindations</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>在一般的组合当中，一个元素一旦被选中那么它接下来就会从候选集当中移除，再也不会被选中。如果我们希望获得有放回的组合，我们可以再换一个函数，这个函数名称有点长，但是名字倒也直观叫做<code>combinations_with_replacement</code>。但既然是有放回的抽样，我们<strong>需要设定元素的数量</strong>，否则抽样可以无限进行下去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combinations_with_replacement(items, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h2 id="迭代合并后的序列"><a href="#迭代合并后的序列" class="headerlink" title="迭代合并后的序列"></a>迭代合并后的序列</h2><p>上一篇文章当中我们介绍了zip可以同时迭代多个迭代器，除此之外还有一种情况是我们需要<strong>把多个迭代器串起来迭代</strong>。比如系统的日志打在了多个文件当中，我们希望找出其中有error的日志来分析。这个时候，我们希望的不是同时读取多个迭代器，而是希望能够有办法将多个迭代器的内容串联起来。这个功能就是<code>itertools</code>当中的<strong>chain</strong>方法，它接受多个迭代器，当我们遍历的时候，会自动将多个迭代器的内容串联起来，我们可以无缝迭代。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">chars = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain(nums, chars):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>这样我们会把<code>nums</code>和<code>chars</code>当中的内容一起输出出来，<strong>就好像从头到尾只执行了一个迭代器一样</strong>。</p><p>你可能会说我们不用<code>chain</code>也可以实现啊，我们可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums + chars:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>的确，从结果上来看这样也是行得通的。但是如果我们分析一下内部执行的时候的中间变量，会发现当我们执行<code>nums</code>+<code>chars</code>的时候，实际上是<strong>先创建了一个新的临时list</strong>。然后在这个list当中存储<code>nums</code>和<code>chars</code>的数据，也就是说我们迭代的其实是这个新的list。这带来的结果是我们<strong>额外开辟了一段内存</strong>，并且花费了一些时间。如果我们使用<code>chain</code>，它并不会有这样的中间变量，完全是通过迭代器来执行的迭代，非常节省内存，这也是<code>chain</code>的优点。</p><h2 id="归并迭代的内容"><a href="#归并迭代的内容" class="headerlink" title="归并迭代的内容"></a>归并迭代的内容</h2><p>对于归并操作我们应该都不陌生，在之前的归并排序以及一些题解的文章当中我们见过很多次。同样，我们在使用工具合并多个迭代器内容的时候，如果迭代器当中的内容有序，我们也可以<strong>对多个迭代器当中的元素进行归并</strong>，而不再需要我们自己手动操作。</p><p>使用我们之前介绍的<code>heapq</code>的库可以非常轻松地做到这一点，我们一起来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a, b):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>执行之后，我们会得到[1, 2, 3, 4, 5, 6]的结果。也就是说通过<code>heapq.merge</code>操作，我们把多个有序的迭代器合并到了一起。当然我们也可以自己合并，但如果我们只是需要利用当中的数据的话，使用<code>merge</code>操作可以节省内存空间。</p><p>到这里内容就结束了，本文和之前的文章基本上列举完了常用的迭代器用法。当然，除了上述讲到的内容之外，Python当中的迭代器还有一些其他的用法，不过相对不太常用，感兴趣的同学可以私下了解。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterator </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python enumerate和zip用法</title>
      <link href="/2023/03/25/python-enumerate/"/>
      <url>/2023/03/25/python-enumerate/</url>
      
        <content type="html"><![CDATA[<p>本文我们继续介绍迭代相关。</p><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><p>首先介绍的是enumerate函数。</p><p>在我们日常编程的过程当中，经常会遇到一个问题。</p><p>在C语言以及一些古老的语言当中是没有迭代器这个概念的，所以我们要遍历数组或者是容器的时候，往往只能通过下标。有了迭代器之后，我们遍历的过程方便了很多，我们可以直接用一个变量去迭代一个容器当中的值。最简单的例子就是数组的遍历，比如我们要遍历items这个数组。我们可以直接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br></pre></td></tr></table></figure><p>通过迭代器的方式我们可以很轻松地遍历数组，而不再需要下标，也不需要计算数组的长度了。但是如果我们在循环体当中需要知道元素的下标该怎么办？比较笨的办法就是我们在循环外创建一个变量来记录位置，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    idx += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样可以解决问题，但是很麻烦，一点也不简洁，用专业的话来说一点也不<code>pythonic</code>（符合Python标准的代码）。为了追求<code>pythonic</code>，于是有了<code>enumerate</code>函数，来解决了我们又想直接迭代又需要知道元素下标的情形。</p><p>它的用法也很简单，我们把需要迭代的对象或者迭代器传入<code>enumerate</code>函数当中，它会为我们创建一个新的迭代器，同时返回下标以及迭代的内容。我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(items):</span><br></pre></td></tr></table></figure><p>除此之外，<code>enumerate</code>还支持传入参数。比如在某些场景当中，我们希望下标从1开始，而不再是0开始，我们可以额外多传入一个参数实现这点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(items, <span class="number">1</span>):</span><br></pre></td></tr></table></figure><p>循环是我们编程的时候必不可少的操作，也正因此，<code>enumerate</code>函数使用非常广泛。但是有一点需要注意，如果我们迭代的是一个多参数的数组，我们需要注意要将index和value区分开。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><p>在不用<code>enumerate</code>的时候，我们有两种迭代方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> data:</span><br></pre></td></tr></table></figure><p>但是如果我们使用<code>enumerate</code>的话，由于引入了一个index，我们必须要做区分，否则会报错，所以我们只有一种迭代方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>接下来要介绍的另一个函数同样是方便我们迭代的，不过它针对的是另一个场景——多对象迭代。</p><p>它的应用场景非常简单，就是我们同时想迭代多份数据，比如用户的名字和用户的职业数据是分开的，我们希望同时遍历一个用户的职业和名字。如果不使用<code>zip</code>，我们可能只能放弃迭代器回到传统的下标遍历的模式了。这样当然是可以的，不过有两个小问题，第一个小问题当然是代码的可读性变差了，不够pythonic，第二个问题是我们需要维护两个容器长度不一样的情况，会增加额外的代码。而使用<code>zip</code>，可以同时解决以上两个问题。</p><p>我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;xiaohua&#x27;</span>, <span class="string">&#x27;xiaohei&#x27;</span>, <span class="string">&#x27;xiaoli&#x27;</span>]</span><br><span class="line">jobs = [<span class="string">&#x27;coach&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;professor&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, job <span class="keyword">in</span> <span class="built_in">zip</span>(names, jobs):</span><br><span class="line">  <span class="built_in">print</span>(name, job)</span><br></pre></td></tr></table></figure><p>最后输出的结果是人名和职业的tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming coach</span><br><span class="line">xiaohua student</span><br><span class="line">xiaohei student</span><br><span class="line">xiaoli student</span><br></pre></td></tr></table></figure><p>上面举的例子当中，<code>names</code>和<code>jobs</code>的长度其实是不一致的，在使用了<code>zip</code>的情况下，会自动替我们按照其中较短的那个进行截断。如果我们不希望截断，我们也可以使用<code>itertools</code>下的<code>zip_longest</code>来代替<code>zip</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="keyword">for</span> name, job <span class="keyword">in</span> zip_longest(names, jobs):</span><br></pre></td></tr></table></figure><p>这样的话长度不够的元素会以<code>None</code>来填充，<code>zip_longest</code>提供了一个参数<code>fillvalue</code>，可以填充成我们指定的值。</p><p>无论是<code>zip</code>还是<code>zip_longest</code>，都可以支持多迭代器的遍历。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;xiaohua&#x27;</span>, <span class="string">&#x27;xiaohei&#x27;</span>, <span class="string">&#x27;xiaoli&#x27;</span>]</span><br><span class="line">jobs = [<span class="string">&#x27;coach&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;professor&#x27;</span>]</span><br><span class="line">hobbies = [<span class="string">&#x27;footbal&#x27;</span>, <span class="string">&#x27;tennis&#x27;</span>, <span class="string">&#x27;badminton&#x27;</span>, <span class="string">&#x27;basketbal&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, job, hobby <span class="keyword">in</span> <span class="built_in">zip</span>(names, jobs, hobbies):</span><br><span class="line">  <span class="built_in">print</span>(name, job, hobby)</span><br></pre></td></tr></table></figure><p><code>zip</code>除了方便我们迭代遍历之外，另一个很大的用处是可以很方便地生成<code>dict</code>。比如刚才的例子当中，我们想生成一个名称和职业的<code>dict</code>，一般的办法当然是先定义一个<code>dict</code>，然后遍历所有的<code>key</code>和<code>value</code>，来生成<code>dict</code>。然而使用<code>zip</code>，我们可以将这个操作简化到一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobDict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(names, jobs))</span><br></pre></td></tr></table></figure><p>需要注意的是，我们调用<code>zip</code>返回的结果其实是一个迭代器，我们在转化成<code>dict</code>的时候自动遍历了迭代器当中的内容。比如我们如果直接打印出<code>zip</code>调用结果的话，就会发现屏幕上输出的是一个迭代器的地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span>(names, jobs))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x10ec93b40</span>&gt;</span><br></pre></td></tr></table></figure><p>我们想要获得它的内容，需要将它手动转成<code>list</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(names, jobs)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;coach&#x27;</span>), (<span class="string">&#x27;xiaohua&#x27;</span>, <span class="string">&#x27;student&#x27;</span>), (<span class="string">&#x27;xiaohei&#x27;</span>, <span class="string">&#x27;student&#x27;</span>), (<span class="string">&#x27;xiaoli&#x27;</span>, <span class="string">&#x27;student&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>无论是<code>enumerate</code>还是<code>zip</code>其实底层都是基于迭代器实现的，从原理上来说并没有什么太深奥的内容，而且我们不使用它们也不影响我们写代码。但是Python之所以是Python，之所以很多人称道它简洁的语言和逻辑，离不开我们广泛地使用这些简化代码逻辑的工具和方法。因此我们加以了解是非常有必要的，希望大家都能写出pythonic的代码，不仅写代码能力强，而且代码本身也漂亮。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> enumerate </tag>
            
            <tag> zip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的MapReduce</title>
      <link href="/2023/03/25/python-map-reduce/"/>
      <url>/2023/03/25/python-map-reduce/</url>
      
        <content type="html"><![CDATA[<p>本文给大家介绍的是Python当中三个非常神奇的方法：<code>map</code>、<code>reduce</code>和<code>filter</code>。</p><p>不知道大家看到<code>map</code>和<code>reduce</code>的时候有没有什么感觉，如果看过之前我们大数据系列介绍MapReduce文章的同学，想必有些印象。这个<code>MapReduce</code>不是一个分布式的计算方法么，怎么又变成Python中的方法了？其实原因很简单，因为Python是一门很年轻的语言，它在发展的过程当中吸收了很多其他领域的精华，MapReduce就是其中之一。</p><p>对之前文章感兴趣的同学可以点击下方的链接，回顾一下之前MapReduce的内容。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247488987&amp;idx=1&amp;sn=f6796f56028c70aa3447157cc2c0501b&amp;source=41#wechat_redirect">大数据基石——Hadoop与MapReduce (qq.com)</a></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>除了地图之外，另一个英文本意是映射。在C++和Java一些语言当中，将<code>map</code>进一步引申成了存储<code>key</code>和<code>value</code>映射结构的容器。Python对这点做了区分，KV结构的容器命名成了<code>dict</code>，即字典，而<code>map</code>则回到了它的本意，也就是映射。</p><p>我们都知道，在数学领域，映射也是函数的领域。一个自变量通过某种映射，对应到一个因变量。同样，在Python当中，<code>map</code>操作本质也是函数，不过它作用的范围不再是单个变量，而是一个序列。换句话说，通过<code>map</code>我们可以省去循环操作，可以自动将一个函数作用在容器中的每一个元素上。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/0AEE43DC7CB1C1FC891FBAEBB25B5FCC.jpg" alt=""></p><p>举个简单的例子，比如我们有一个坐标，我们希望知道它距离原点的距离。这个问题很简单，我们写一个计算距离的函数就可以解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dis</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(point[<span class="number">0</span>]**<span class="number">2</span> + point[<span class="number">1</span>]**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>那如果我有多个点需要计算距离，在<code>map</code>出现之前，我们只能用循环来解决问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">points = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    <span class="built_in">print</span>(dis(point))</span><br></pre></td></tr></table></figure><p>但是有了map之后， 我们可以省去循环的操作，整个代码简化成了一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(dis, points)</span><br></pre></td></tr></table></figure><p>但是要注意，我们调用完map之后得到的结果不是一个<code>list</code>而是一个迭代器。我们直接将<code>map</code>返回的内容print出来，可以得到这样一个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">map</span>(dis, points))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x107aad1d0</span>&gt;</span><br></pre></td></tr></table></figure><p>这是一个类的标准输出，其实它返回的不是最后的结果，而是一个迭代器。我们在之前的文章当中已经介绍过了迭代器和生成器的相关概念，这里不多做赘述了。</p><p>我们想要获得完整的内容也很容易，我们只需要将它转化成list类型即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(dis, points)))</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">4.47213595499958</span>, <span class="number">3.605551275463989</span>]</span><br></pre></td></tr></table></figure><p>以上过程还可以进一步简化，还记得我们之前介绍过的匿名函数吗？由于dis函数在我们的程序当中只会在map中用到，我们完全没有必要单独创建一个函数，我们可以直接传入一个匿名函数搞定运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: math.sqrt(x[<span class="number">0</span>]**<span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span>), points)</span><br></pre></td></tr></table></figure><p>简单总结一下，<code>map</code>操作其实执行的是一个映射。它可以自动地将一个序列当中的内容通过制定的函数映射成另一个结果，从而避免显示地使用循环来调用，在很多场景下可以大大地简化代码的编写，可以很方便地将一个序列整体转变成另一个结果。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>相比于<code>map</code>，<code>reduce</code>的操作稍稍难理解一点点。它也是规定一个映射，不过不是将一个元素映射成一个结果。而是将两个元素归并成一个结果。并且它并不是调用一次，而是依次调用，直到最后只剩下一个结果为止。</p><p>比如说我们有一个数组<code>[a, b, c, d]</code>和一个函数f，我们计算<code>reduce(f, [a, b, c, d])</code>其实就等价于<code>f(f(f(a, b), c), d)</code>。和<code>map</code>不同的是，<code>reduce</code>最后得到一个结果，而不是一个迭代器或者是<code>list</code>。</p><p>我们光说有些抽象，不妨来看一个例子，就看最简单的一个例子：<code>reduce</code>函数接收两个数，返回两个数的和。那么显然，我们依次调用<code>reduce</code>，得到的就是整个数组的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(reduce(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>最终得到的结果当然是10，同样，我们也可以将reduce中的方法定义成匿名函数，一样不影响最终的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>既然我们<code>map</code>和<code>reduce</code>都有了，显然我们可以将它们串联起来使用，也就是分布式系统当中MapReduce的做法。虽然如果不手动使用线程池的话，Python并不会起多个线程来加速运算，但是至少可以简化我们实现的代码。我们还是举经典的<code>wordCount</code>的例子，也就是文本计算词频。</p><p>套用<code>map</code>和<code>reduce</code>的功能，整个流程非常清晰，我们只需要在<code>map</code>阶段对文本进行分词，在<code>reduce</code>阶段对分词之后的结果进行汇总即可。</p><p>听着好像非常容易，但是你实际去上手是写不出来的。原因也很简单，因为hadoop当中的Map和Reduce中间还有一层shuffle（重排）的操作，会自动地将key值相同的结果放到同一个reducer当中。在这个问题当中，key自然就是我们的word，由于相同的word被放到同一个reducer当中，我们只需要累加就行了。但是如果我们自己编写mapreduce的话，由于缺少了中间数据重排的步骤，所以导致不能实现。</p><p>要解决也简单，我们可以人为增加一个map阶段代替hadoop当中的重排。相当于做了一个MapMapReduce，我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"></span><br><span class="line">texts = [<span class="string">&#x27;apple bear peach grape&#x27;</span>, <span class="string">&#x27;grape orange pear&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次map，将字符串转成数组，每个单词对应1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mp1</span>(<span class="params">text</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    words = text.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        ret.append((word, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次map，将数组转成dict</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mp2</span>(<span class="params">arr</span>):</span><br><span class="line">    d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> arr:</span><br><span class="line">        d[k] += v</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce，合并dict</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rd</span>(<span class="params">x, y</span>):</span><br><span class="line">    x.update(y)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reduce(rd, <span class="built_in">map</span>(mp2, <span class="built_in">map</span>(mp1, texts))))</span><br></pre></td></tr></table></figure><p>那如果我们不用多次MapReduce呢？也不是没有办法，需要取点巧，方法也简单只要使用之前我们讲解过的<code>Counter</code>类，就可以完美解决这个问题。我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">texts = [<span class="string">&#x27;apple bear peach grape&#x27;</span>, <span class="string">&#x27;grape orange pear&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mp</span>(<span class="params">text</span>):</span><br><span class="line">    words = text.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> Counter(words)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x + y, <span class="built_in">map</span>(mp, texts)))</span><br></pre></td></tr></table></figure><p>由于我们使用了<code>Counter</code>，所以我们在map阶段返回的结果就已经是词频的<code>dict</code>了，而在<code>reduce</code>阶段我们只需要将它们全部累加起来就OK了。</p><p>最后，我们来看下<code>filter</code></p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>的英文是过滤，所以它的使用就很明显了。它的用法和map有些类似，我们编写一个函数来判断元素是否合法。通过调用<code>filter</code>，会自动将这个函数应用到容器当中所有的元素上，最后只会保留运行结果是<code>True</code>的元素，而过滤掉那些是<code>False</code>的元素。</p><p>举个例子，假设我们想要保留list当中的奇数而过滤掉偶数，我们当然可以直接操作，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> arr <span class="keyword">if</span> i % <span class="number">2</span> &gt; <span class="number">0</span> ]</span><br></pre></td></tr></table></figure><p>而使用<code>filter</code>会非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> &gt; <span class="number">0</span>, arr))</span><br></pre></td></tr></table></figure><p>从这个例子当中可能看不出便捷，但是有的时候判断的条件可能非常复杂，我们判断的逻辑不能简单地在<code>list</code>定义当中表达出来，这个时候使用<code>filter</code>则会容易得多。</p><p>最后， 我们再看一个类似的用法。在<code>itertools</code>当中有一个方法叫做 <code>compress</code>，通过<code>compress</code>我们可以实现根据一个序列的条件过滤另一个序列。</p><p>举个简单的例子，假设，我们有两个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student = [<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;xiaohong&#x27;</span>, <span class="string">&#x27;xiaoli&#x27;</span>, <span class="string">&#x27;emily&#x27;</span>]</span><br><span class="line">scores = [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure><p>我们想要获取所有考试及格的同学的<code>list</code>，如果用常规做法基本上免不了使用循环，但是使用<code>compress</code>可以很方便地通过一行代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itemtools <span class="keyword">import</span> compress</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">pass</span> = [i &gt; <span class="number">60</span> <span class="keyword">for</span> i <span class="keyword">in</span> scores]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="keyword">pass</span>)</span><br><span class="line">[<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(compress(student, <span class="keyword">pass</span>))</span><br><span class="line">[<span class="string">&#x27;xiaohong&#x27;</span>, <span class="string">&#x27;xiaoli&#x27;</span>]</span><br></pre></td></tr></table></figure><p>需要注意的是<code>filter</code>和<code>compress</code>返回的都是一个迭代器，我们要获取它们的值，需要手动转换成list。</p><p>虽然在日常的开发当中不使用这三样神器同样可以工作，但是用上它们之后，会提升很多代码的可读性，节省很多无用的代码。尤其是在面试的时候，很有可能就会给面试官留下不一样的印象，也许结果也会不同。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map/reduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python迭代器与生成器</title>
      <link href="/2023/03/18/python-generator/"/>
      <url>/2023/03/18/python-generator/</url>
      
        <content type="html"><![CDATA[<p>我们来介绍一下Python中的迭代器和生成器。</p><p>我当初第一次学到迭代器和生成器的时候，并没有太在意，只是觉得这是一种新的获取数据的方法。对于获取数据的方法而言，我们会一种就足够了。但是在我后来Python的使用以及TensorFlow等学习使用当中，我发现很多地方都用到了迭代器和生成器，或者是直接使用，或者是借鉴了思路。所以我们不能掉以轻心，今天就让我们仔细来看看，它们到底是怎么回事。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们先从<a href="&quot;https://www.programiz.com/python-programming/iterator&quot;" title="programiz">迭代器</a>开始入手，迭代器并不是Python独有的概念，在C++和Java当中都有<code>iterator</code>的概念，两者的使用也都差不多。迭代器主要解决了一个问题，在一个复杂场景下，获取数据怎么尽可能简便。</p><p>我们来假设一个场景，假设我们从某个数据源获取了一批数据。然后我们需要调用前一万条生成一个结果，得到结果之后，我们要将剩下的数据交给另一个调用方去处理。这个过程看起来非常平常，但是隐藏了两个问题，第一个问题是如果我们能保证第一次处理的时候，每次都是使用一万条还好说，如果我们使用的条数是一个动态的值呢？显然，我们需要一个变量来记录我们究竟用了多少条数据，和这批数据的状态。其次，如果这个数据量很大会存在一个数据传输的问题。我们每次都要将一大批数据传来传去，显然会消耗很多资源。</p><p>还有一个场景是如果我们开发的是一个比较复杂的数据结构，比如一棵多叉树，下游想要遍历它的时候，必须要了解它的实现原理才行。这显然也不太友好。</p><p>迭代器的出现正是针对以上这些问题，它的含义也很简单，有点像是我们遍历链表的时候用到的<code>cur</code>的指针。永远指向当前的位置，永远知道下一个位置在哪里。</p><h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>我们先从简单的元素迭代器开始了解它的用途，我们都知道Python当中经典的几个容器：<code>list, tuple</code>和<code>dict</code>。它们都是一个可迭代对象，我们可以直接使用关键字<code>iter</code>获取一个对应的迭代器。</p><p>我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure><p>这是一个非常经典的例子，我们首先定义了一个数组，然后通过<code>iter</code>关键字获取了一个读取它的迭代器。有了迭代器之后我们可以通过<code>next</code>关键字获取迭代器当中的下一个元素，我们一共调用了两次<code>next</code>，第一次输出的结果是1，第二次的结果是3。和我们刚才说的一样，我们每一次调用，它会自动往后移动一格，获取后面一位的数据。</p><p>这里有一点需要注意，因为我们创建的数组当中一共只有5个元素，如果我们调用<code>it</code>的次数超过5次，那么会引发超界，Python的解释器会抛出<code>StopIteration</code>的<code>error</code>。</p><p>除了使用<code>next</code>，我们也可以使用<code>for</code>循环来迭代它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>这种用法就和我们用<code>for</code>循环遍历元素是一样的。</p><h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>官方的迭代器的用法就这么多，这也不是它的主要用法，它最主要的用法是我们自己创建迭代器。和之前介绍Python自定义排序的时候的思路一样，我们为类添加上<code>__iter__</code>方法和<code>__next__</code>方法即可。</p><p>其中<code>__iter__</code>方法用来初始化并返回迭代器，关于它的解释比较复杂。在Python当中迭代有两个概念一个是<code>iterable</code>，一个是<code>iterator</code>。协议规定<code>iteratble</code>的<code>__iter__</code>方法会返回一个<code>iterator</code>。而<code>iterator</code>本身也是一个<code>iterable</code>对象，自然也需要实现<code>__iter__</code>方法。</p><p>我知道这么说可能听不太明白，我举个例子，比如说员工和老板，员工没有审批权限，只能转达给老板。我们把员工比喻成<code>iterable</code>对象，老板比喻成<code>iterator</code>。</p><p>员工面临一个问题的时候没有权限处理，只能找来老板决定。也就是最终决定的是老板，但如果是老板自己发现的问题，他完全可以自己就解决了，不需要再去找其他人。所以说我们用<code>iter</code>调用<code>iterable</code>对象的<code>__iter__</code>的时候，会得到一个<code>iterator</code>，也就是调用员工返回老板，然后通过调用<code>iterator</code>的<code>__next__</code>来进行迭代。</p><p>到这里也就清楚了，只有<code>iterator</code>有<code>__next__</code>方法，而<code>iterable</code>没有，并且<code>__iter__</code>调用之后返回的是一个iterator。然而我们定义的已经是<code>iterator</code>了，它同时也是一个<code>iterable</code>对象，所以调用<code>__iter__</code>时只需要返回<code>self</code>就好了。<code>__next__</code>方法很简单，对应迭代器的<code>next</code>方法，用来返回下一个迭代的元素。</p><p>我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PowTwo</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Class to implement an iterator</span></span><br><span class="line"><span class="string">    of powers of two&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span> = <span class="number">0</span></span>):</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.n &lt;= self.<span class="built_in">max</span>:</span><br><span class="line">            result = <span class="number">2</span> ** self.n</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure><p>这是一个简单的生成2的幂的迭代器，我们在<code>__iter__</code>里为self.n初始化为0，然后返回自身。在<code>__next__</code>里判断有没有迭代结束，如果结束的话抛出一个异常。</p><p>我们来看使用它的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = PowTwo(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="built_in">iter</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>我们也可以用for循环来迭代它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> PowTwo(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><p>迭代器除了可以迭代一个容器或者是像上面这样自定义迭代方法之外，还可以用来迭代生成器。下面就让我们一起来看下生成器的概念。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器的概念和迭代器相辅相成，迭代器是生成一个遍历数据的迭代工具，而生成器则是数据生成工具。</p><p>举个很简单的例子，比如说斐波那契数列我们都知道，从第三个数开始等于前面两个数的和。比如我们想获取100万个斐波那契数列，按照传统的方法我们需要开辟一个长度是一百万的数组，然后按照斐波那契数列的定义一个一个地计算。显然这样会消耗大量的空间，有没有办法我们和迭代器那样构建一个生成数据的方法，我们每次调用获取下一个结果呢？这样我们要多少数据就调用多少次就可以了，从根本上解决了存储的问题。</p><p>下面我们来看怎么定义一个生成器。</p><h3 id="括号创建法"><a href="#括号创建法" class="headerlink" title="括号创建法"></a>括号创建法</h3><p>最简单的方法真的很简单，和我们创建list基本上一模一样。</p><p>在Python当中，我们经常这样初始化一个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [i * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>也就是说我们把循环放在list的定义当中，这样Python会自动执行里面的循环，然后将所有循环的结果进行二次计算后写入到list当中去。我们稍微变形一下，就得到了一个最简单的生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (i * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><p>看清楚了吗，其实和<code>list</code>没什么差别，只是我们将最外层的括号从<code>[]</code>换成了<code>()</code>。</p><p>这种方法大家应该都能看懂，但是可能会有一个疑惑。我们这样做的意义是什么呢？这样和上面用<code>[]</code>定义有什么区别呢？</p><p>其实是有区别的，如果没有区别，那么我们用生成器也就没有意义了。它的区别也就是生成器的意义，简单来说，我们前文中已经说过了当定义一个<code>list</code>的时候，Python会自动将<code>for</code>循环执行一遍，然后将结果写入进<code>list</code>当中。但是生成器不会，虽然我们也用到了<code>for</code>循环，但是它只是定义了运算逻辑，在执行完这一步之后，Python并不会将<code>for</code>循环执行结束。只有我们每次调用<code>next</code>，才会触发它进行一次循环。</p><p>不相信的同学可以试试，看看运行一下下面两个语句的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>))</span><br><span class="line">g = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>)]</span><br></pre></td></tr></table></figure><p>如果奇怪的事情发生了，不妨再回到文章来思考一下。</p><h3 id="函数创建法"><a href="#函数创建法" class="headerlink" title="函数创建法"></a>函数创建法</h3><p>上面介绍的方法虽然简单，但是不太实用，因为很多时候我们想要的数据构造方法会比较复杂，很难用这种形式展现出来。</p><p>所以Python当中还为我们提供了一种构造生成器的方法，相比起来要稍微复杂一点点，但是也很好用。我们来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gtr</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure><p>从代码上来看，我们好像定义了一个函数，某种程度上可以这么理解，但是它返回的结果并不是一个值，而是一个<a href="&quot;https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640&quot;" title="廖雪峰的Python教程">生成器</a>。</p><p>如果你真的去试了，你会得到一个<code>generator</code>类型的实例，这也是Python自带的生成器的实例。</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/007S8ZIlgy1ggcqdz7u21j30ds04nt8r.jpg" alt="IMAGE"></p><p>再仔细观察一下，你会发现这个函数当中的关键字和一般的不太一样，它没有使用<code>return</code>，而是使用了<code>yield</code>。<code>yield</code>和<code>return</code>在很大程度上很接近，但是又有些不同。</p><p>相同点是当我们执行到<code>yield</code>时，和<code>return</code>一样会将<code>yield</code>之后的内容返回给调用方。比如上面代码当中写到<code>yield i</code>，那么我们运行<code>next</code>的时候就会获取到这个<code>i</code>。</p><p>不同的地方是，当我们下一次再次执行的时候，会继续从<code>yield</code>处开始往下执行。有些类似于递归的时候，底层的递归执行结束回到上层的情况。因此如果我们要获取多个值，需要在生成器当中使用循环。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = test()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(t))</span><br></pre></td></tr></table></figure><p>我们如果执行上面这段代码，前三个数是0，1和2，从第四个数开始一直是10。如果你能看懂这个例子，一定能明白<code>yield</code>的含义。</p><h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>接下来要介绍的<code>yield from</code>和<code>yield</code>用法差不多，也是从生成器返回一个结果，并且下次执行的时候从返回的位置开始继续执行。</p><p>但是它有一点和<code>yield</code>不同，我们来看一个经典的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">g1</span>():     </span><br><span class="line">     <span class="keyword">yield</span>  <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g2</span>():</span><br><span class="line">     <span class="keyword">yield</span>  <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">it1 = g1()</span><br><span class="line">it2 = g2()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it1:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it2:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>这两者打印出来的结果是一样的，但是逻辑完全不同。在第一个生成器<code>g1</code>当中，直接通过<code>yield</code>返回了一个迭代器。也就是说我们<code>for</code>循环执行的其实是<code>range(5)</code>，而第二个生成器<code>g2</code>则通过<code>yield from</code>获取了<code>range(5)</code>这个迭代器当中的值进行的返回。</p><p>也就是说<code>yield from</code>可以返回一个迭代器或者是生成器执行<code>next</code>之后的结果。</p><p>最后，我们来看一个<code>yield from</code>使用的一个经典场景：二叉树的遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line">        self.iterated = <span class="literal">False</span></span><br><span class="line">        self.father = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.lchild.iterate()</span><br><span class="line">        <span class="keyword">yield</span> self.key</span><br><span class="line">        <span class="keyword">if</span> self.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.rchild.iterate()</span><br></pre></td></tr></table></figure><p>在这个代码当中我们定义了二叉树当中的一个节点，以及它对应的迭代方法。由于我们用到了<code>yield</code>来返回结果，所以<code>iterate</code>方法本质是一个生成器。再来看<code>iterate</code>方法内部，我们通过<code>yield from</code>调用了<code>iterate</code>，所以我们在执行的时候，它会自动继续解析<code>node.lchild</code>的<code>iterate</code>，也就是说我们通过<code>yield from</code>实现了递归。</p><p>当我们建好树之后，可以直接使用<code>root.iterate</code>来遍历整棵树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#建树过程</span></span><br><span class="line">        self.root = Node(<span class="number">4</span>)</span><br><span class="line">        self.root.lchild = Node(<span class="number">3</span>)</span><br><span class="line">        self.root.lchild.father = self.root</span><br><span class="line">        self.root.rchild = Node(<span class="number">5</span>)</span><br><span class="line">        self.root.rchild.father = self.root</span><br><span class="line">        self.root.lchild.lchild = Node(<span class="number">1</span>)</span><br><span class="line">        self.root.lchild.lchild.father = self.root.lchild</span><br><span class="line">        self.root.rchild.rchild = Node(<span class="number">7</span>)</span><br><span class="line">        self.root.rchild.rchild.father = self.root.rchild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.root.iterate()</span><br></pre></td></tr></table></figure><p>通过<code>yield from</code>，我们可以很轻松地利用递归的思路来实现树上的生成器。从而可以很方便地以生成器的思路来遍历树上所有的元素。</p><p>到这里，关于Python当中迭代器和生成器的知识就算是讲完了，这两者的概念有些接近，但是又不完全一样，很多初学者容易搞混淆。</p><p>其实可以这么理解，迭代器和生成器遍历元素的方式是一样的，都是通过调用<code>next</code>来获取下一个元素。我们通过<code>yield</code>创建函数，返回的结果其实就是生成器生成的数据的迭代器。也就是说迭代器只是迭代和获取数据的，但是并不能无中生有地创造数据。而生成器的主要作用是创造数据，它生成出来的数据是以迭代器的形式返回的。</p><p>举个例子，你开了一个奶茶店，通过奶茶店每个月可以在银行账户里获得一笔收入。迭代器就是这个账户，通过它你可以获得一笔一笔的收入。而奶茶店则是一个生成器，它产出数据，但是是以迭代器的形式返回给你的，也就是以银行账户的方式给你收入。我们拿到银行卡并不知道它里面的钱是怎么赚来的，只能看到钱，也就是说我们并不知道迭代器背后数据的逻辑。但是生成器我们是清楚的，因为钱（生产逻辑）是我们亲自赚来的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> generator </tag>
            
            <tag> 生成器 </tag>
            
            <tag> iterator </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python collections工具库</title>
      <link href="/2023/03/18/python-collections/"/>
      <url>/2023/03/18/python-collections/</url>
      
        <content type="html"><![CDATA[<p>这篇文章为大家介绍Python当中一个很好用也是很基础的工具库，叫做<code>collections</code>。</p><p>collection在英文当中有容器的意思，所以顾名思义，这是一个容器的集合。这个库当中的容器很多，有一些不是很常用，本篇文章选择了其中最常用的几个，一起介绍给大家。</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p><code>defaultdict</code>可以说是这个库当中使用最简单的一个，并且它的定义也很简单，我们从名称基本上就能看得出来。它解决的是我们使用<code>dict</code>当中最常见的问题，就是<code>key</code>为空的情况。</p><p>在正常情况下，我们在<code>dict</code>中获取元素的时候，都需要考虑<code>key</code>为空的情况。如果不考虑这点，那么当我们获取了一个不存在的<code>key</code>，会导致系统抛出异常。我们当然可以在每次get之前写一个if判断，但是这很麻烦，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>当然，这是最笨的方法，<code>dict</code>当中为我们提供了带默认值的get方法。比如，我们可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">dict</span>.get(key, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这样，当<code>key</code>不在<code>dict</code>当中的时候，会自动返回我们设置的默认值。这个省去了很多麻烦的判断，但是在一些特殊情况下仍然存在一点问题。举个例子，比如当<code>key</code>存在重复，我们希望将<code>key</code>相同的<code>value</code>存进一个<code>list</code>当中，而不是只保留一个。这种情况下写成代码就会比较复杂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">in</span> d:</span><br><span class="line">        d[k].append(v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[k] = [v]</span><br></pre></td></tr></table></figure><p>由于<code>dict</code>的<code>value</code>是一个list，所以我们还是需要判断是否为空，不能直接使用默认值，间接操作当然可以，但是还是不够简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    cur = d.get(k, [])</span><br><span class="line">    cur.append(v)</span><br><span class="line">    d[k] = v</span><br></pre></td></tr></table></figure><p>这和使用<code>if</code>区别并不大，为了完美解决这个问题，我们可以使用<code>collections</code>当中的<code>defaultdict</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k].append(v)</span><br></pre></td></tr></table></figure><p>使用<code>defaultdict</code>之后，如果<code>key</code>不存在，容器会自动返回我们预先设置的默认值。需要注意的是<code>defaultdict</code>传入的默认值可以是一个类型也可以是一个方法。如果我们传入<code>int</code>，那么默认值会被设置成<code>int()</code>的结果，也就是0，如果我们想要自定义或者修改，我们可以传入一个方法，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k] += v</span><br></pre></td></tr></table></figure><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>这是一个非常常用和非常强大的工具，我们经常用到。</p><p>在我们实际的编程当中，我们经常遇到一个问题，就是数数和排序。比如说我们在分析文本的时候，会得到一堆单词。其中可能有大量的长尾词，在整个文本当中可能只出现过寥寥几次。于是我们希望计算一下这些单词出现过的数量，只保留出现次数最高的若干个。</p><p>这个需求让我们自己实现当然也不困难，我们完全可以创建一个<code>dict</code>，然后对这些单词一个一个遍历。原本我们还需要考虑单词之前没有出现过的情况，如果我们上面说的<code>defaultdict</code>，又要简单许多。但是我们还是少不了计数然后排序的步骤，如果使用Counter这个步骤会缩减成一行代码。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;watermelon&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">counter = Counter(words)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(counter)</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;watermelon&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;peach&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们直接将一个<code>list</code>传入<code>Counter</code>中作为参数，它会自动为我们替当中的每个元素计数。</p><p>如果我们要筛选<code>topK</code>，也非常简单，它为我们提供了<code>most_common</code>方法，我们只需要传入需要求的K即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter.most_common(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">[(<span class="string">&#x27;apple&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>除此之外，它的构造函数还接收<code>dict</code>类型。我们可以直接通过一个<code>value</code>是<code>int</code>类型的<code>dict</code>来初始化一个<code>Counter</code>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">c = Counter(apple=<span class="number">4</span>, pear=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>并且，它还支持加减法的操作，比如我们可以将两个<code>Counter</code>相加，它会自动将两个<code>Counter</code>合并，相同的<code>key</code>对应的<code>value</code>累加。相减也是同理，会将能对应的<code>value</code>做减法，被减的<code>key</code>对应不上的会保留，而减数中对应不上的<code>key</code>则会被丢弃。并且需要注意，<code>Counter</code>支持<code>value</code>为负数。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>我们都知道<code>queue</code>是队列，<code>deque</code>也是队列，不过稍稍特殊一些，是双端队列。对于<code>queue</code>来说，只允许在队尾插入元素，在队首弹出元素。而<code>deque</code>既然称为双端队列，那么说明它的队首和队尾都支持元素的插入和弹出。相比于普通的队列，要更加灵活一些。</p><p>除了常用的<code>clear、copy、count、extend</code>等api之外，<code>deque</code>当中最常用也是最核心的api主要是<code>append、pop、appendleft</code>和<code>popleft</code>。从名字上我们就看得出来，<code>append</code>和<code>pop</code>和<code>list</code>的<code>append</code>和<code>pop</code>一样，而<code>appendleft</code>和<code>popleft</code>则是在队列左侧，也就是头部进行<code>pop</code>和<code>append</code>的操作。非常容易理解。</p><p>在日常的使用当中，真正用到双端队列的算法其实不太多。大多数情况下我们使用<code>deque</code>主要有两个原因，第一个原因是<code>deque</code>受到GIL的管理，它是线程安全的。而<code>list</code>则没有GIL锁，因此不是线程安全的。也就是说在并发场景下，<code>list</code>可能会导致一致性问题，而<code>deque</code>不会。另一个原因是<code>deque</code>支持固定长度，当长度满了之后，当我们继续<code>append</code>时，它会自动弹出最老插入的数据。</p><p>比如说当我们拥有海量的数据，我们不知道它的数量，但是想要保留最后出现的指定数量的数据的时候，就可以使用<code>deque</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dque = deque(maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 假设我们想要从文件当中获取最后10条数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.read():</span><br><span class="line">    dque.append(i)</span><br></pre></td></tr></table></figure><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p><code>namedtuple</code>很特殊，它涉及到元编程的概念。简单介绍一下元编程的概念，我们不做过多的深入。简而言之，就是在常见的面向对象当中。我们都是定义类，然后通过类的构造函数来创建实例。而元编程指的是我们定义元类，根据元类创建出来的并不是一个实例，而是一个类。如果用模具和成品来分别比喻类和实例的话，元类相当于是模具的模具。</p><p><code>namedtuple</code>是一个非常简单的元类，通过它我们可以非常方便地定义我们想要的类。</p><p>它的用法很简单，我们直接来看例子。比如如果我们想要定义一个学生类，这个类当中有name、score、age这三个字段，那么这个类会写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, score=<span class="literal">None</span>, age=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>这还只是粗略的写法，如果考虑规范，还需要定义<code>property</code>等注解，又需要很多代码。如果我们使用<code>namedtuple</code>可以简化这个工作，我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 这个是类，columns也可以写成&#x27;name score age&#x27;，即用空格分开</span></span><br><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是实例</span></span><br><span class="line">student = Student(name=<span class="string">&#x27;xiaoming&#x27;</span>, score=<span class="number">99</span>, age=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(student.name)</span><br></pre></td></tr></table></figure><p>通过使用<code>namedtuple</code>，我们只需要一行就定义了一个类，但是这样定义的类是没有缺失值的，但是<code>namedtuple</code>很强大，我们可以通过传入<code>defaults</code>参数来定义缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>], defaults=(<span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>可以注意到，虽然我们定义了三个字段，但是我们只设置了两个缺失值。在这种情况下，<code>namedtuple</code>会自动将缺失值匹配上<code>score</code>和<code>age</code>两个字段。因为在Python的规范当中，必选参数一定在可选参数前面。</p><p>细数一下，我们今天的文章当中介绍了<code>defaultdict、Counter、deque</code>和<code>namedtuple</code>这四种数据结构的用法。除了这四个之外，<code>collections</code>库当中还有一些其他的工具类，只是我们用的频率稍稍低一些，加上由于篇幅的原因，这里就不多做赘述了。感兴趣的同学可以自行查看相关的api和文档。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
            <tag> defaultdict </tag>
            
            <tag> counter </tag>
            
            <tag> deque </tag>
            
            <tag> namedtuple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python自定义排序</title>
      <link href="/2023/03/15/python-diy-sort/"/>
      <url>/2023/03/15/python-diy-sort/</url>
      
        <content type="html"><![CDATA[<p>今天的这篇文章和大家聊聊Python当中的排序，和很多高级语言一样，Python封装了成熟的排序函数。我们只需要调用内部的<code>sorted</code>函数，就可以完成排序。但是实际场景当中，排序的应用往往比较复杂，比如对象类型，当中有多个字段，我们希望按照指定字段排序，或者是希望按照多关键字排序，这个时候就不能简单的函数调用来解决了。</p><h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>我们先来看下最常见的字典排序的场景，假设我们有一个字典的数组，字典内有多个字段。我们希望能够根据字典当中的某一个字段来进行排序，我们用实际数据来举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kids = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">12</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaohong&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaowang&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">15</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里的<code>kids</code>是一个<code>dict</code>类型的数组，<code>dict</code>当中拥有<code>name</code>，<code>score</code>和<code>age</code>三个字段。假设我们当下希望能够按照<code>score</code>来排序，应该怎么办呢？</p><p>对于这个问题，解决的方案有很多，首先，我们可以使用上一篇文章当中提到的匿名函数来指定排序的。这里的用法和上篇文章优先队列的用法是一样的，我们直接来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(kids, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure><p>在匿名函数当中我们接收的<code>x</code>是<code>kids</code>当中的元素，也就是一个<code>dict</code>，所以我们想要指定我们希望的字段，需要用<code>dict</code>访问元素的方法，也就是用中括号来查找对应字段的值。</p><p>假如我们希望按照多关键字排序呢？</p><p>首先介绍一下多关键字排序，还是用上面的数据打比方。在上面的例子当中，各个<code>kid</code>的<code>score</code>都不一样，所以排序的结果是确定的。但如果存在两个人的<code>score</code>相等，我希望年龄小的排在前面，那么应该怎么办呢？我们分析一下可以发现，原本是按照分数从小到大排序，但有可能会出现分数相等的情况。这个时候，我们希望能够按照在分数相等的情况下来比较年龄，也就是说我们希望根据两个关键字来排序，第一个关键字是分数，第二个关键字是年龄。</p><p>由于Python当中支持<code>tuple</code>和<code>list</code>类型的排序，也就是说我们可以直接比较<code>[1, 3]</code>和<code>[1, 2]</code>的大小关系，Python会自动一次比较两个数组当中的元素的大小。如果相等就自动往后比较，直到出现不等或者结束为止。</p><p>明白了这点，其实就很好办了。我们只要在匿名函数当中稍稍修改，让它返回的结果增加一个字段即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(kids, key=<span class="keyword">lambda</span> x: (x[<span class="string">&#x27;score&#x27;</span>], x[<span class="string">&#x27;age&#x27;</span>]))</span><br></pre></td></tr></table></figure><h2 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h2><p>除了匿名函数，Python也有自带的库可以解决这个问题。用法和匿名函数非常接近，使用起来稍稍容易一些。</p><p>它就是<code>operator</code>库当中的<code>itemgetter</code>函数，我们直接来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(kids, key=itemgetter(<span class="string">&#x27;score&#x27;</span>))</span><br></pre></td></tr></table></figure><p>如果是多关键字也可以，传入多个key即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(kids, key=itemgetter(<span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="对象排序"><a href="#对象排序" class="headerlink" title="对象排序"></a>对象排序</h2><p>我们接下来看一下对象的自定义排序，我们首先把上面的<code>dict</code>写成对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Kid</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Kid, name: &#123;&#125;, score: &#123;&#125;, age:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, self.score, self.age)</span><br></pre></td></tr></table></figure><p>为了方便观察打印结果，我们重载了<code>__repr__</code>方法，可以简单地将它当做是Java当中的<code>toString</code>方法，这样我们可以指定在<code>print</code>它的时候的输出结果。</p><p>同样，<code>operator</code>当中也提供了对象的排序因子函数，用法上和<code>itemgetter</code>一样，只是名字不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"></span><br><span class="line">kids = [Kid(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">99</span>, <span class="number">12</span>), Kid(<span class="string">&#x27;xiaohong&#x27;</span>, <span class="number">75</span>, <span class="number">13</span>), Kid(<span class="string">&#x27;xiaowang&#x27;</span>, <span class="number">88</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(kids, key=attrgetter(<span class="string">&#x27;score&#x27;</span>))</span><br></pre></td></tr></table></figure><p>我们也可以使用匿名函数lambda来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(kids, key=<span class="keyword">lambda</span> x: x.score)</span><br></pre></td></tr></table></figure><h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>到这里还没有结束，因为仍然存在一些问题解决不了。虽然我们实现了多关键字排序，但是还有一个问题解决不了，就是排序的顺序问题。</p><p>我们可以在<code>sorted</code>函数的参数当中传入<code>reverse=True</code>来控制是正序还是倒叙，但是如果我使用多关键字，想要按照某个关键字升序，某个关键字降序怎么办？举个例子，比如说我们想要按照分数降序，年龄升序就没办法通过<code>reverse</code>来解决了，这就是当前解决不了的问题。</p><p>那应该怎么办呢？</p><p>这个时候就需要终极排序杀器上场了，也就是标题当中所说的自定义排序。也就是说我们自己实现一个定义元素大小的函数，然后让<code>sorted</code>来调用我们这个函数来完成排序。这也是C++和Java等语言的用法。</p><p>自定义的函数并不难写，我们随手就来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">kid1, kid2</span>):</span><br><span class="line">    <span class="keyword">return</span> kid1.age &lt; kid2.age <span class="keyword">if</span> kid1.score == kid2.score <span class="keyword">else</span> kid1.score &gt; kid2.score</span><br></pre></td></tr></table></figure><p>如果看不明白，也没关系，我写成完整版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">kid1, kid2</span>):</span><br><span class="line">    <span class="keyword">if</span> kid1.score == kid2.score:</span><br><span class="line">        <span class="keyword">return</span> kid1.age &lt; kid2.age</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> kid1.score &gt; kid2.score</span><br></pre></td></tr></table></figure><p>写完了之后，还没有结束，这个函数是不能直接投入使用的，他和我们之前提到的<code>lambda</code>匿名函数是不一样的。之前的匿名函数只是用来指定字段的，所以我们不能直接将这个函数传递给<code>key</code>，还需要在外面包一层加工处理才可以。不过这一层处理函数Python也已经有现成的工具了，我们可以直接调用，它在<code>functools</code>里，我们来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(kids, key=cmp_to_key(cmp))</span><br></pre></td></tr></table></figure><p>我们来看一下<code>cmp_to_key</code>函数里的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp_to_key</span>(<span class="params">mycmp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Convert a cmp= function into a key= function&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">K</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        __slots__ = [<span class="string">&#x27;obj&#x27;</span>]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        __hash__ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure><p>我们可以看到，在函数内部，它其实定义了一个类，然后在类当中重载了比较函数，最后返回的是一个重载了比较函数的新的对象。这些<code>__lt__,</code>_<code>_gt__</code>函数就是类当中重载的比较函数。比如<code>__lt__</code>是小于的判断函数，<code>__eq__</code>是相等的函数。那么问题来了，我们能不能直接在<code>Kid</code>类当中重载比较函数呢，这样就可以直接排序了。</p><p>答案是确定的，我们当然可以这么办，实际上这也是面向对象当中非常常用的做法。相比于自定义比较函数，我们往往更倾向于在类当中定义好优先级。Python当中实现的方法也很简单，就是我们手动实现一个<code>__lt__</code>函数，<code>sorted</code>默认会将小的元素排在前面，所以我们只用实现<code>__lt__</code>一个函数就够了。这个函数当中传入的参数是另一个对象，我们直接在函数里面写清楚比较逻辑就行了。返回<code>True</code>表示当前对象比<code>other</code>小，否则比<code>other</code>大。</p><p>我们附上完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Kid</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Kid, name: &#123;&#125;, score: &#123;&#125;, age:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, self.score, self.age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score &gt; other.score <span class="keyword">or</span> (self.score == other.score <span class="keyword">and</span> self.age &lt; other.age)</span><br></pre></td></tr></table></figure><p>实现了比较函数之后，我们直接调用<code>sorted</code>，不用任何其他传参就可以对它进行排序了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多变量处理</title>
      <link href="/2023/03/15/python-param/"/>
      <url>/2023/03/15/python-param/</url>
      
        <content type="html"><![CDATA[<p>我们都知道Python是一个非常灵活的语言，以至于如果它不是你的第一门语言，你会发现它总能给你各种各样的惊喜，让你忍不住惊叹：woc，还有这种操作。比如我在系统地学习Python之前是Java后端出身，所以对此感受尤其明显，每一阶段几乎都会让我觉得打开了新世界的大门。今天就和大家介绍一个最基础，非常好用，但是很多人不知道的操作。</p><h2 id="解压变量"><a href="#解压变量" class="headerlink" title="解压变量"></a>解压变量</h2><p>我们都知道，Python允许进行多个变量的赋值操作，比如著名的交换两个元素，如果是在C++或者Java语言当中，如果不通过函数实现，必须要引入第三个变量，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swap a, b</span></span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure><p>我们要交换a和b必须要引入c，这是因为当我们赋值b给a的时候，a原本的值会丢失，所以我们必须要先”缓存“下来。但是由于Python支持多变量赋值的操作，所以大可不必引入其他变量就可以完成，所以交换两个元素在Python当中只有一行就可以搞定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>Python的解释器会直接计算后边的值然后覆盖左边，赋值是同时进行的，所以不需要引入其他变量，而且看起来也非常geek。</p><p>除此之外，Python还支持<code>tuple</code>和<code>list</code>的解压。</p><p>举个例子，假设我们有一个二元数组：[1, 2]，我们希望用两个变量分别获取它的第0位和第一位，我们当然可以写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a, b = l[<span class="number">0</span>], l[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其实并不用这么麻烦，因为当Python检测到等号左边是多个变量，右边是<code>list</code>或者是<code>tuple</code>之后，会自动执行<code>list</code>和<code>tuple</code>的解压，将它依次赋值给对应的元素，所以上面的代码可以简化成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a, b = l</span><br></pre></td></tr></table></figure><p>那如果l是一个二维数组，我们希望遍历它呢？同样可以在循环当中使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure><p>即使是在变量的组合当中也可以生效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">3</span>, (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>当我们执行这段代码，屏幕上会输出什么呢？是会报错吗？还是会解压<code>(4, 5)</code>这个<code>tuple</code>然后将<code>4</code>赋值给<code>c</code>呢？</p><p>都不对，输出的结果是<code>(4, 5)</code>，也就是说Python发现变量数量对不上之后，会自动将<code>tuple</code>当做一个整体进行赋值。不但如此，即使是下面这种情况，Python也能自动识别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, (c, d), e = <span class="number">1</span>, <span class="number">3</span>, (<span class="number">4</span>, <span class="number">5</span>), <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(c, d)</span><br></pre></td></tr></table></figure><p>在下面的赋值当中，既有<code>tuple</code>又有普通元素，并且我们的变量也组合成了<code>tuple</code>，这时Python同样会识别出<code>(4, 5)</code>应该赋值给<code>(c, d)</code>这个整体，也就是说4和5分别赋值给<code>c</code>和<code>d</code>。</p><h2 id="缺省元素"><a href="#缺省元素" class="headerlink" title="缺省元素"></a>缺省元素</h2><p>在有的时候，我们在获取元素的时候，源数据当中有我们不需要的字段。虽然Python自动解压非常方便，但是我们还是要为我们不需要的数据设置变量。在一些情况下这会导致内存的浪费，并且这也不符合我们编程的规范，即所有变量都应该派上用场。为了解决这个问题，Python提供缺省元素的方法。我们可以使用_来代表一个缺省值，_对应的数据不会被存储下来，只是为了方便我们”凑齐“元素。</p><p>举个例子，还用上面的例子举例，假设源数据的格式是这样：<code>1, 3, (4, 5), 7</code>，但是我们只需要中间的元组，我们就可以这样去接收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, _, (c, d), _ = <span class="number">1</span>, <span class="number">3</span>, (<span class="number">4</span>, <span class="number">5</span>), <span class="number">7</span></span><br></pre></td></tr></table></figure><p>再比如，当我们遍历<code>dict</code>的时候，有可能我们并不关注<code>dict</code>的key，只希望获得它的<code>value</code>，这个时候也可以使用缺省符号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v <span class="keyword">in</span> a.items():</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure><h2 id="压缩变量"><a href="#压缩变量" class="headerlink" title="压缩变量"></a>压缩变量</h2><p>既然变量可以解压，那么自然也可以压缩。想象一个场景，比如有一批衡量工厂零件的数据，这个数据当中除了零件的尺寸之外还包含了零件的名称，生产日期和工厂名称等等其他的属性。假设我们当下希望解析这份数据，并且将零件的尺寸用数组存储，这个时候应该怎么办呢？</p><p>比如，零件的数据的规格长这样：<code>wheel, factory1, 3, 4, 5, 6, 2020-02-02</code></p><p>Python同样针对这个问题提供了解决方法，就是变量压缩符*，针对上面那个问题，我们可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">&#x27;wheel&#x27;</span>, <span class="string">&#x27;factory1&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;2020-02-02&#x27;</span>]</span><br><span class="line">name, factory, *inch, date = data</span><br><span class="line"><span class="built_in">print</span>(inch)</span><br></pre></td></tr></table></figure><p>最后我们打印出来的<code>inch</code>是<code>[3, 4, 5, 6]</code>，也就是说通过使用*，我们成功地将中间表示零件尺寸的数据赋值进了一个数组当中。这个操作非常重要，因为有可能不同零件尺寸的数量是不同的，如果我们自己写解析的话就很难处理这个问题。而使用Python当中的 *操作符，我们可以很好地解决这个问题。</p><h2 id="联合使用"><a href="#联合使用" class="headerlink" title="联合使用"></a>联合使用</h2><p>到这里，我们介绍了缺省符号的用法，介绍了压缩符号的用法，问题来了，我们能不能将这两个符号组合使用，获取数据当中任意个缺省值呢？</p><p>当然是可以的，还是刚才的问题，假设我们现在不关心零件的尺寸，想要过滤掉它们，我们只要对上面的代码稍作改动即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">&#x27;wheel&#x27;</span>, <span class="string">&#x27;factory1&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;2020-02-02&#x27;</span>]</span><br><span class="line">name, factory, *_, date = data</span><br></pre></td></tr></table></figure><p>如此我们就过滤掉了中间若干个尺寸信息，仅仅保留了头尾其他的信息。</p><h2 id="其他用途"><a href="#其他用途" class="headerlink" title="其他用途"></a>其他用途</h2><p>到这里还没结束，不知道大家在看到 <code>*</code> 这个操作符号的时候有没有什么联想，如果稍稍了解过Python的话，应该会想起Python当中，如果我们想让一个函数接收任何参数的话，我们可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>其中<code>args</code>其实代表一个数组，<code>kw</code>代表一个<code>dict</code>，这些我们都是知道的。但是前面的 <code>*</code> 和 <code>**</code> 呢，又代表什么呢？</p><p><code>*</code>代表解压数组，<code>**</code>自然就代表解压<code>dict</code>。我们来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>请问<code>print(a)</code>和<code>print(*a)</code>有什么区别？如果你试一下就会发现，直接打印<code>a</code>，出来的结果是<code>[1, 3, 5]</code>，如果你打印 <code>*a</code>，得到的结果是<code>1, 3, 5</code>。也就是说前者是将<code>a</code>当成一个数组输出，是一个变量，后者则是将<code>a</code>解压了，当成了3个变量输出。那么同样的道理，<code>**kw</code>，也是将作为<code>dict</code>的<code>kw</code>解压，以<code>key: value</code>的形式展开。不过如果你直接调用 <code>**kw</code>会得到一个报错，这个操作只能在函数传递参数的时候使用。</p><p>所以到这里，我们就明白了，<code>*args</code>和<code>**kw</code>为什么能够代表所有参数了。因为前者代表了直接传递的必选参数，后者呢，代表提供了默认值的默认参数。这也是为什么Python限定了默认参数必须放在必选参数后面的原因，一方面是为了消除歧义，另一方面也是为了能够用<code>*args</code>, <code>**kw</code>来统一表示。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python heapq用法</title>
      <link href="/2023/03/14/python-heapq/"/>
      <url>/2023/03/14/python-heapq/</url>
      
        <content type="html"><![CDATA[<p>今天的文章来介绍Python当中一个蛮有用的库——heapq。</p><p>heapq的全写是heap queue，是堆队列的意思。这里的堆和队列都是数据结构。我们先不关注原理，今天只介绍heapq的用法，如果不了解heap和queue原理的同学可以忽略。</p><p>在介绍用法之前，我们需要先知道优先队列的定义。队列大家应该都不陌生，也是非常基础简单的数据结构。我们可以想象成队列里的所有元素排成一排，新的元素只能从队尾加入队列，元素要出队列只能通过队首，不能中途从队列当中退出。而优先队列呢，是给队列当中的元素每一个都设置了优先级，使得队伍当中的元素会自动按照优先级排序，优先级高的排在前面。</p><p>也就是说Python当中的<code>heapq</code>就是一个维护优先队列的库，我们通过调用它可以轻松实现优先队列的功能。</p><h3 id="最大或最小的K个元素"><a href="#最大或最小的K个元素" class="headerlink" title="最大或最小的K个元素"></a>最大或最小的K个元素</h3><p>我们来看一个实际的问题，假设我们当下有N个杂乱无章的元素，但是我们只关心其中最大的K个或者是最小的K个元素。我们想从整个数组当中将这部分抽取出来，应该怎么办呢？</p><p>这个问题在实际当中非常常见，随便就可以举出例子来。比如用户输入了搜索词，我们根据用户的搜索词找到了大量的内容。我们想要根据算法筛选出用户最有可能点击的文本来，机器学习的模型可以给每一个文本一个预测的分数。之后，我们就需要选出分数最大的K个结果。这种类似的场景还有很多，利用<code>heapq</code>库里的<code>nlargest</code>和<code>nsmallest</code>接口可以非常方便地做到这点。</p><p>我们一起来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">14</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">1</span>, <span class="number">21</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">28</span>]</span><br><span class="line">heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="comment"># [28, 28, 22]</span></span><br><span class="line">heapq.nsmallest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="comment"># [1, 5, 14]</span></span><br></pre></td></tr></table></figure><p><code>heapq</code>的<code>nlargest</code>和<code>nsmallest</code>接受两个参数，第一个参数是<code>K</code>，也就是返回的元素的数量，第二个参数是传入的数组，<code>heapq</code>返回的正是传入的数组当中的前<code>K</code>大或者是前<code>K</code>小。</p><p>这里有一个问题，如果我们数组当中的元素是一个对象呢？应该怎么办？</p><p>其实也很简单，有了解过Python自定义关键词排序的同学应该知道，和排序一样，我们可以通过匿名函数实现。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>我们都知道，在Python当中通过<code>def</code>可以定义一个函数。通过<code>def</code>定义的函数都有函数名，所以称为有名函数。除了有名函数之外，Python还支持匿名函数。顾名思义，就是没有函数名的函数。也就是说它其他方面都和普通函数一样，只不过没有名字而已。</p><p>初学者可能会纳闷，函数没有名字应该怎么调用呢？</p><p>会有这个疑惑很正常，这是因为习惯了面向过程的编程，对面向对象理解不够深入导致的。在许多高级语言当中，一切皆对象，一个类，一个函数，一个<code>int</code>都是对象。既然函数也是对象，那么函数自然也可以用来传递，不仅可以用来传递，还可以用来返回。当然这是函数式编程的概念了，我们这里不多做深入。</p><p>当然，普通函数也一样可以传递，起到的效果一样。只不过在程序中，有些函数我们只会使用一次，没必要再单独定义一个函数，使用匿名函数会非常方便。</p><p>举个例子，比方说我有一个这样的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">operate</span>(<span class="params">x, func</span>):</span><br><span class="line">  <span class="keyword">return</span> func(x)</span><br></pre></td></tr></table></figure><p>这个operate函数它接受两个参数，第一个参数是变量<code>x</code>，第二个参数是一个函数。它会在函数内部调用<code>func</code>，返回<code>func</code>调用的结果。我现在要做这样一件事情，我希望根据<code>x</code>这个整数对4取余的余数来判断应该用什么样的<code>func</code>。如果对4的余数为0，我希望求一次方，如果余数是2，我希望求平方，以此类推。如果按照正常的方法，我们需要实现4个方法，然后依次传递。</p><p>这当然是可以的，不过非常麻烦，如果使用匿名函数，就可以大大简化代码量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_result</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">if</span> x % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> operate(x, <span class="keyword">lambda</span> x: x)</span><br><span class="line">  <span class="keyword">elif</span> x % <span class="number">4</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> operate(x, <span class="keyword">lambda</span> x: x ** <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">elif</span> x % <span class="number">4</span> == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> operate(x, <span class="keyword">lambda</span> x: x ** <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> operate(x, <span class="keyword">lambda</span> x: x ** <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码当中，我们通过<code>lambda</code>关键字定义了匿名函数，避免了定义四种函数用来传递的情况。当然，这个问题还有更简单的写法，可以只用一个函数解决。</p><p>我们来看<code>lambda</code>定义匿名函数的语法，首先是<code>lambda</code>关键字，表示我们当下定义的是一个匿名函数。之后跟的是这个匿名函数的参数，我们只用到一个变量<code>x</code>，所以只需要写一个<code>x</code>。如果我们需要用到多个参数，通过逗号分隔，当然也可以不用参数。写完参数之后，我们用冒号分开，冒号后面写的是返回的结果。</p><p>我们也可以把匿名函数赋值给一个变量，之后我们就可以和调用普通函数一样来调用了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(operate(<span class="number">3</span>, square))</span><br></pre></td></tr></table></figure><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><p>回到之前的内容，如果我们想要<code>heapq</code>排序的是一个对象。那么<code>heapq</code>并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。</p><p>比如说，我们现在有一批电脑，我们希望heapq能够根据电脑的价格排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">laptops = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ThinkPad&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mac&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Surface&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alienware&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">35</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lenovo&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">45</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Huawei&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;price&#x27;</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;price&#x27;</span>])</span><br></pre></td></tr></table></figure><p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><code>heapq</code>除了可以返回最大最小的<code>K</code>个数之外，还实现了优先队列的接口。我们可以直接调用<code>heapq.heapify</code>方法，输入一个数组，返回的结果是根据这个数组生成的堆（等价于优先队列）。当我们拥有了一个堆之后，我们可以通过调用<code>heapq</code>的<code>push</code>和<code>pop</code>来维护这个堆。接下来，我们就通过<code>heapq</code>来自己动手实现一个优先队列，代码非常的简单，我想大家应该可以瞬间学会。</p><p>首先是实现优先队列的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self._queue = []</span><br><span class="line">    self._index =<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">    <span class="comment"># 传入两个参数，一个是存放元素的数组，另一个是要存储的元素，这里是一个元组。</span></span><br><span class="line">    <span class="comment"># 由于heap内部默认有小到大排，所以对priority取负数</span></span><br><span class="line">    heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">    self._index += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其次我们来实际看一下运用的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">q = PriorityQueue()</span><br><span class="line"></span><br><span class="line">q.push(<span class="string">&#x27;lenovo&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">q.push(<span class="string">&#x27;Mac&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">q.push(<span class="string">&#x27;ThinkPad&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">q.push(<span class="string">&#x27;Surface&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">q.pop()</span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">q.pop()</span><br><span class="line"><span class="comment"># Surface</span></span><br></pre></td></tr></table></figure><p>到这里，关于<code>heapq</code>的应用方面就算是介绍完了，但是还没有真正的结束。</p><p>我们需要分析一下<code>heapq</code>当中操作的复杂度，关于堆的部分我们暂时跳过，我们先来看<code>nlargest</code>和<code>nsmallest</code>。我在github当中找到了这个库的源码，在方法的注释上，作者写下了这个方法的复杂度，和排序之后取前<code>K</code>个开销五五开：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nlargest</span>(<span class="params">n, iterable, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find the n largest elements in a dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>我们都知道排序的复杂度的期望是$O(nlogn)$，如果你了解堆的话，会知道堆一次插入元素的复杂度是$logn$。如果我们限定堆的长度是<code>K</code>，我们插入<code>n</code>次之后也只能保留<code>K</code>个元素。每次插入的复杂度是$logK$，一共插入<code>n</code>次，所以整体的复杂度是$nlogK$。如果<code>K</code>小一些，可能开销会比排序稍小，但是程度有限。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heapq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python30分钟入门指南</title>
      <link href="/2023/03/14/python%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/14/python%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>很多小伙伴向我反应过，他们想要学Python，但是没有一份很好的资料入门。一方面的确现在市面上Python的资料过多，导致新手会不知如何选择，另一个问题很多资料内容也很杂，从1+1到深度学习都包括，<strong>纯粹关注Python本身语法</strong>的优质教材并不太多。</p><p>刚好我最近看到一份不错的英文Python入门资料，我将它做了一些<strong>整理和翻译</strong>写下了本文。这份资料非常纯粹，只有Python的基础语法，专门针对想要学习Python的小白。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中用#表示单行注释，#之后的同行的内容都会被注释掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中单行注释用#表示，#之后同行字符全部认为被注释。</span></span><br></pre></td></tr></table></figure><p>使用三个连续的双引号表示多行注释，两个多行注释标识之间内容会被视作是注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 与之对应的是多行注释</span></span><br><span class="line"><span class="string">    用三个双引号表示，这两段双引号当中的内容都会被视作是注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="基础变量类型与操作符"><a href="#基础变量类型与操作符" class="headerlink" title="基础变量类型与操作符"></a>基础变量类型与操作符</h1><p>Python当中的数字定义和其他语言一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得一个整数</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 获得一个浮点数</span></span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure><p>我们分别使用+, -, *, /表示加减乘除四则运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span>   <span class="comment"># =&gt; 2</span></span><br><span class="line"><span class="number">8</span> - <span class="number">1</span>   <span class="comment"># =&gt; 7</span></span><br><span class="line"><span class="number">10</span> * <span class="number">2</span>  <span class="comment"># =&gt; 20</span></span><br><span class="line"><span class="number">35</span> / <span class="number">5</span>  <span class="comment"># =&gt; 7.0</span></span><br></pre></td></tr></table></figure><p>这里要注意的是，在Python2当中，10/3这个操作会得到3，而不是3.33333。因为除数和被除数都是整数，所以Python会自动执行整数的计算，帮我们把得到的商取整。如果是10.0 / 3，就会得到3.33333。目前Python2已经不再维护了，可以不用关心其中的细节。</p><p>但问题是Python是一个<strong>弱类型</strong>的语言，如果我们在一个函数当中得到两个变量，是无法直接判断它们的类型的。这就导致了同样的计算符可能会得到不同的结果，这非常蛋疼。以至于程序员在运算除法的时候，往往都需要手工加上类型转化符，将被除数转成浮点数。</p><p>在Python3当中拨乱反正，修正了这个问题，即使是两个整数相除，并且可以整除的情况下，得到的结果也一定是浮点数。</p><p>如果我们想要得到整数，我们可以这么操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> // <span class="number">3</span>       <span class="comment"># =&gt; 1</span></span><br><span class="line">-<span class="number">5</span> // <span class="number">3</span>      <span class="comment"># =&gt; -2</span></span><br><span class="line"><span class="number">5.0</span> // <span class="number">3.0</span>   <span class="comment"># =&gt; 1.0 # works on floats too</span></span><br><span class="line">-<span class="number">5.0</span> // <span class="number">3.0</span>  <span class="comment"># =&gt; -2.0</span></span><br></pre></td></tr></table></figure><p>两个除号表示<strong>取整除</strong>，Python会为我们保留去除余数的结果。</p><p>除了取整除操作之外还有取余数操作，数学上称为取模，Python中用%表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modulo operation</span></span><br><span class="line"><span class="number">7</span> % <span class="number">3</span>  <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><p>Python中支持<strong>乘方运算</strong>，我们可以不用调用额外的函数，而使用**符号来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Exponentiation (x**y, x to the yth power)</span></span><br><span class="line"><span class="number">2</span>**<span class="number">3</span>  <span class="comment"># =&gt; 8</span></span><br></pre></td></tr></table></figure><p>当运算比较复杂的时候，我们可以用括号来强制改变运算顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enforce precedence with parentheses</span></span><br><span class="line"><span class="number">1</span> + <span class="number">3</span> * <span class="number">2</span>  <span class="comment"># =&gt; 7</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">3</span>) * <span class="number">2</span>  <span class="comment"># =&gt; 8</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>Python中用首字母大写的True和False表示真和假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="literal">False</span>  <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure><p>用and表示与操作，or表示或操作，not表示非操作。而不是C++或者是Java当中的&amp;&amp;, || 和！。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># negate with not</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">True</span>   <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">False</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean Operators</span></span><br><span class="line"><span class="comment"># Note &quot;and&quot; and &quot;or&quot; are case-sensitive</span></span><br><span class="line"><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span>   <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>在Python底层，<strong>True和False其实是1和0</strong>，所以如果我们执行以下操作，是不会报错的，但是在逻辑上毫无意义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># True and False are actually 1 and 0 but with different keywords</span></span><br><span class="line"><span class="literal">True</span> + <span class="literal">True</span> <span class="comment"># =&gt; 2</span></span><br><span class="line"><span class="literal">True</span> * <span class="number">8</span>    <span class="comment"># =&gt; 8</span></span><br><span class="line"><span class="literal">False</span> - <span class="number">5</span>   <span class="comment"># =&gt; -5</span></span><br></pre></td></tr></table></figure><p>我们用==判断相等的操作，可以看出来True==1， False == 0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comparison operators look at the numerical value of True and False</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">False</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">True</span>   <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">True</span>   <span class="comment"># =&gt; False</span></span><br><span class="line">-<span class="number">5</span> != <span class="literal">False</span> <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>我们要小心Python当中的bool()这个函数，它并不是转成bool类型的意思。如果我们执行这个函数，那么<strong>只有0会被视作是False，其他所有数值都是True</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="number">0</span>)     <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="number">4</span>)     <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="built_in">bool</span>(-<span class="number">6</span>)    <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span>     <span class="comment"># =&gt; 0</span></span><br><span class="line">-<span class="number">5</span> <span class="keyword">or</span> <span class="number">0</span>     <span class="comment"># =&gt; -5</span></span><br></pre></td></tr></table></figure><p>Python中用==判断相等，&gt;表示大于，&gt;=表示大于等于， &lt;表示小于，&lt;=表示小于等于，!=表示不等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Equality is ==</span></span><br><span class="line"><span class="number">1</span> == <span class="number">1</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">2</span> == <span class="number">1</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Inequality is !=</span></span><br><span class="line"><span class="number">1</span> != <span class="number">1</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># More comparisons</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">10</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">10</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">2</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">2</span> &gt;= <span class="number">2</span>  <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>我们可以用and和or拼装各个逻辑运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Seeing whether a value is in a range</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> <span class="keyword">and</span> <span class="number">2</span> &lt; <span class="number">3</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span> &lt; <span class="number">2</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="comment"># Chaining makes this look nicer</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">3</span> &lt; <span class="number">2</span>  <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure><p>注意not，and，or之间的优先级，其中not &gt; and &gt; or。如果分不清楚的话，可以用括号强行改变运行顺序。</p><h2 id="list和字符串"><a href="#list和字符串" class="headerlink" title="list和字符串"></a>list和字符串</h2><p>关于list的判断，我们常用的判断有两种，一种是刚才介绍的==，还有一种是is。我们有时候也会简单实用is来判断，那么这两者有什么区别呢？我们来看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># Point a at a new list, [1, 2, 3, 4]</span></span><br><span class="line">b = a             <span class="comment"># Point b at what a is pointing to</span></span><br><span class="line">b <span class="keyword">is</span> a            <span class="comment"># =&gt; True, a and b refer to the same object</span></span><br><span class="line">b == a            <span class="comment"># =&gt; True, a&#x27;s and b&#x27;s objects are equal</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># Point b at a new list, [1, 2, 3, 4]</span></span><br><span class="line">b <span class="keyword">is</span> a            <span class="comment"># =&gt; False, a and b do not refer to the same object</span></span><br><span class="line">b == a            <span class="comment"># =&gt; True, a&#x27;s and b&#x27;s objects are equal</span></span><br></pre></td></tr></table></figure><p>Python是全引用的语言，其中的对象都使用引用来表示。is判断的就是<strong>两个引用是否指向同一个对象</strong>，而==则是判断两个引用指向的具体内容是否相等。举个例子，如果我们把引用比喻成地址的话，is就是判断两个变量的是否指向同一个地址，比如说都是沿河东路XX号。而==则是判断这两个地址的收件人是否都叫张三。</p><p>显然，住在同一个地址的人一定都叫张三，但是住在不同地址的两个人也可以都叫张三，也可以叫不同的名字。所以如果a is b，那么a == b一定成立，反之则不然。</p><p>Python当中对字符串的限制比较松，<strong>双引号和单引号都可以表示字符串</strong>，看个人喜好使用单引号或者是双引号。我个人比较喜欢单引号，因为写起来方便。</p><p>字符串也支持+操作，表示两个字符串相连。除此之外，我们把两个字符串写在一起，即使没有+，Python也会为我们拼接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strings are created with &quot; or &#x27;</span></span><br><span class="line"><span class="string">&quot;This is a string.&quot;</span></span><br><span class="line"><span class="string">&#x27;This is also a string.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Strings can be added too! But try not to do this.</span></span><br><span class="line"><span class="string">&quot;Hello &quot;</span> + <span class="string">&quot;world!&quot;</span>  <span class="comment"># =&gt; &quot;Hello world!&quot;</span></span><br><span class="line"><span class="comment"># String literals (but not variables) can be concatenated without using &#x27;+&#x27;</span></span><br><span class="line"><span class="string">&quot;Hello &quot;</span> <span class="string">&quot;world!&quot;</span>    <span class="comment"># =&gt; &quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure><p>我们可以使用[]来查找字符串当中某个位置的字符，用<strong>len</strong>来计算字符串的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A string can be treated like a list of characters</span></span><br><span class="line"><span class="string">&quot;This is a string&quot;</span>[<span class="number">0</span>]  <span class="comment"># =&gt; &#x27;T&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can find the length of a string</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;This is a string&quot;</span>)  <span class="comment"># =&gt; 16</span></span><br></pre></td></tr></table></figure><p>我们可以在字符串前面<strong>加上f表示格式操作</strong>，并且在格式操作当中也支持运算，比如可以嵌套上len函数等。不过要注意，只有Python3.6以上的版本支持f操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can also format using f-strings or formatted string literals (in Python 3.6+)</span></span><br><span class="line">name = <span class="string">&quot;Reiko&quot;</span></span><br><span class="line"><span class="string">f&quot;She said her name is <span class="subst">&#123;name&#125;</span>.&quot;</span> <span class="comment"># =&gt; &quot;She said her name is Reiko&quot;</span></span><br><span class="line"><span class="comment"># You can basically put any Python statement inside the braces and it will be output in the string.</span></span><br><span class="line"><span class="string">f&quot;<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;<span class="built_in">len</span>(name)&#125;</span> characters long.&quot;</span> <span class="comment"># =&gt; &quot;Reiko is 5 characters long.&quot;</span></span><br></pre></td></tr></table></figure><p>最后是None的判断，在Python当中None也是一个对象，<strong>所有为None的变量都会指向这个对象</strong>。根据我们前面所说的，既然所有的None都指向同一个地址，我们需要判断一个变量是否是None的时候，可以使用is来进行判断，当然用==也是可以的，不过我们通常使用is。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None is an object</span></span><br><span class="line"><span class="literal">None</span>  <span class="comment"># =&gt; None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t use the equality &quot;==&quot; symbol to compare objects to None</span></span><br><span class="line"><span class="comment"># Use &quot;is&quot; instead. This checks for equality of object identity.</span></span><br><span class="line"><span class="string">&quot;etc&quot;</span> <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="literal">None</span> <span class="keyword">is</span> <span class="literal">None</span>   <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>理解了None之后，我们再回到之前介绍过的bool()函数，它的用途其实就是判断值是否是空。所有类型的<strong>默认空值会被返回False</strong>，否则都是True。比如0，””，[], {}, ()等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None, 0, and empty strings/lists/dicts/tuples all evaluate to False.</span></span><br><span class="line"><span class="comment"># All other values are True</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="literal">None</span>)<span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="number">0</span>)   <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>)  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>([])  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>(&#123;&#125;)  <span class="comment"># =&gt; False</span></span><br><span class="line"><span class="built_in">bool</span>(())  <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure><p>除了上面这些值以外的所有值传入都会得到True。</p><h1 id="变量与集合"><a href="#变量与集合" class="headerlink" title="变量与集合"></a>变量与集合</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>Python当中的标准输入输出是<strong>input和print</strong>。</p><p>print会输出一个字符串，如果传入的不是字符串会自动调用<strong>str</strong>方法转成字符串进行输出。<strong>默认输出会自动换行</strong>，如果想要以不同的字符结尾代替换行，可以传入end参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python has a print function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I&#x27;m Python. Nice to meet you!&quot;</span>)  <span class="comment"># =&gt; I&#x27;m Python. Nice to meet you!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default the print function also prints out a newline at the end.</span></span><br><span class="line"><span class="comment"># Use the optional argument end to change the end string.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World&quot;</span>, end=<span class="string">&quot;!&quot;</span>)  <span class="comment"># =&gt; Hello, World!</span></span><br></pre></td></tr></table></figure><p>使用input时，Python会在命令行接收一行字符串作为输入。可以在input当中传入字符串，会被当成提示输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simple way to get input data from console</span></span><br><span class="line">input_string_var = <span class="built_in">input</span>(<span class="string">&quot;Enter some data: &quot;</span>) <span class="comment"># Returns the data as a string</span></span><br><span class="line"><span class="comment"># Note: In earlier versions of Python, input() method was named as raw_input()</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Python中声明对象<strong>不需要带上类型</strong>，直接赋值即可，Python会自动关联类型，如果我们使用之前没有声明过的变量则会出发NameError异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># There are no declarations, only assignments.</span></span><br><span class="line"><span class="comment"># Convention is to use lower_case_with_underscores</span></span><br><span class="line">some_var = <span class="number">5</span></span><br><span class="line">some_var  <span class="comment"># =&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Accessing a previously unassigned variable is an exception.</span></span><br><span class="line"><span class="comment"># See Control Flow to learn more about exception handling.</span></span><br><span class="line">some_unknown_var  <span class="comment"># Raises a NameError</span></span><br></pre></td></tr></table></figure><p>Python支持<strong>三元表达式</strong>，但是语法和C++不同，使用if else结构，写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if can be used as an expression</span></span><br><span class="line"><span class="comment"># Equivalent of C&#x27;s &#x27;?:&#x27; ternary operator</span></span><br><span class="line"><span class="string">&quot;yahoo!&quot;</span> <span class="keyword">if</span> <span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span>  <span class="comment"># =&gt; &quot;yahoo!&quot;</span></span><br></pre></td></tr></table></figure><p>上段代码等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;yahoo&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Python中用[]表示空的list，我们也可以直接在其中填充元素进行初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lists store sequences</span></span><br><span class="line">li = []</span><br><span class="line"><span class="comment"># You can start with a prefilled list</span></span><br><span class="line">other_li = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>使用append和pop可以在list的末尾插入或者删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add stuff to the end of a list with append</span></span><br><span class="line">li.append(<span class="number">1</span>)    <span class="comment"># li is now [1]</span></span><br><span class="line">li.append(<span class="number">2</span>)    <span class="comment"># li is now [1, 2]</span></span><br><span class="line">li.append(<span class="number">4</span>)    <span class="comment"># li is now [1, 2, 4]</span></span><br><span class="line">li.append(<span class="number">3</span>)    <span class="comment"># li is now [1, 2, 4, 3]</span></span><br><span class="line"><span class="comment"># Remove from the end with pop</span></span><br><span class="line">li.pop()        <span class="comment"># =&gt; 3 and li is now [1, 2, 4]</span></span><br><span class="line"><span class="comment"># Let&#x27;s put it back</span></span><br><span class="line">li.append(<span class="number">3</span>)    <span class="comment"># li is now [1, 2, 4, 3] again.</span></span><br></pre></td></tr></table></figure><p>list可以通过[]加上下标访问指定位置的元素，如果是负数，则表示<strong>倒序访问</strong>。-1表示最后一个元素，-2表示倒数第二个，以此类推。如果访问的元素超过数组长度，则会出发<strong>IndexError</strong>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Access a list like you would any array</span></span><br><span class="line">li[<span class="number">0</span>]   <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="comment"># Look at the last element</span></span><br><span class="line">li[-<span class="number">1</span>]  <span class="comment"># =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Looking out of bounds is an IndexError</span></span><br><span class="line">li[<span class="number">4</span>]  <span class="comment"># Raises an IndexError</span></span><br></pre></td></tr></table></figure><p>list支持切片操作，所谓的切片则是从原list当中<strong>拷贝</strong>出指定的一段。我们用start: end的格式来获取切片，注意，这是一个<strong>左闭右开区间</strong>。如果留空表示全部获取，我们也可以额外再加入一个参数表示步长，比如[1:5:2]表示从1号位置开始，步长为2获取元素。得到的结果为[1, 3]。如果步长设置成-1则代表反向遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can look at ranges with slice syntax.</span></span><br><span class="line"><span class="comment"># The start index is included, the end index is not</span></span><br><span class="line"><span class="comment"># (It&#x27;s a closed/open range for you mathy types.)</span></span><br><span class="line">li[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment"># Return list from index 1 to 3 =&gt; [2, 4]</span></span><br><span class="line">li[<span class="number">2</span>:]    <span class="comment"># Return list starting from index 2 =&gt; [4, 3]</span></span><br><span class="line">li[:<span class="number">3</span>]    <span class="comment"># Return list from beginning until index 3  =&gt; [1, 2, 4]</span></span><br><span class="line">li[::<span class="number">2</span>]   <span class="comment"># Return list selecting every second entry =&gt; [1, 4]</span></span><br><span class="line">li[::-<span class="number">1</span>]  <span class="comment"># Return list in reverse order =&gt; [3, 4, 2, 1]</span></span><br><span class="line"><span class="comment"># Use any combination of these to make advanced slices</span></span><br><span class="line"><span class="comment"># li[start:end:step]</span></span><br></pre></td></tr></table></figure><p>如果我们要指定一段区间倒序，则前面的start和end也需要反过来，例如我想要获取[3: 6]区间的倒序，应该写成[6:3:-1]。</p><p>只写一个:，表示全部拷贝，如果用is判断拷贝前后的list会得到False。可以使用del删除指定位置的元素，或者可以使用remove方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a one layer deep copy using slices</span></span><br><span class="line">li2 = li[:]  <span class="comment"># =&gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove arbitrary elements from a list with &quot;del&quot;</span></span><br><span class="line"><span class="keyword">del</span> li[<span class="number">2</span>]  <span class="comment"># li is now [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove first occurrence of a value</span></span><br><span class="line">li.remove(<span class="number">2</span>)  <span class="comment"># li is now [1, 3]</span></span><br><span class="line">li.remove(<span class="number">2</span>)  <span class="comment"># Raises a ValueError as 2 is not in the list</span></span><br></pre></td></tr></table></figure><p>insert方法可以<strong>指定位置插入元素</strong>，index方法可以查询某个元素第一次出现的下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Insert an element at a specific index</span></span><br><span class="line">li.insert(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># li is now [1, 2, 3] again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the index of the first item found matching the argument</span></span><br><span class="line">li.index(<span class="number">2</span>)  <span class="comment"># =&gt; 1</span></span><br><span class="line">li.index(<span class="number">4</span>)  <span class="comment"># Raises a ValueError as 4 is not in the list</span></span><br></pre></td></tr></table></figure><p>list可以进行加法运算，两个list相加表示list当中的元素合并。<strong>等价于使用extend</strong>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can add lists</span></span><br><span class="line"><span class="comment"># Note: values for li and for other_li are not modified.</span></span><br><span class="line">li + other_li  <span class="comment"># =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Concatenate lists with &quot;extend()&quot;</span></span><br><span class="line">li.extend(other_li)  <span class="comment"># Now li is [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>我们想要判断元素是否在list中出现，可以使用<strong>in关键字</strong>，通过使用len计算list的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check for existence in a list with &quot;in&quot;</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> li  <span class="comment"># =&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the length with &quot;len()&quot;</span></span><br><span class="line"><span class="built_in">len</span>(li)  <span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple和list非常接近，tuple通过()初始化。和list不同，<strong>tuple是不可变对象</strong>。也就是说tuple一旦生成不可以改变。如果我们修改tuple，会引发TypeError异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tuples are like lists but are immutable.</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tup[<span class="number">0</span>]      <span class="comment"># =&gt; 1</span></span><br><span class="line">tup[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># Raises a TypeError</span></span><br></pre></td></tr></table></figure><p>由于小括号是有改变优先级的含义，所以我们定义单个元素的tuple，<strong>末尾必须加上逗号</strong>，否则会被当成是单个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note that a tuple of length one has to have a comma after the last element but</span></span><br><span class="line"><span class="comment"># tuples of other lengths, even zero, do not.</span></span><br><span class="line"><span class="built_in">type</span>((<span class="number">1</span>))   <span class="comment"># =&gt; &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>((<span class="number">1</span>,))  <span class="comment"># =&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(())    <span class="comment"># =&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>tuple支持list当中绝大部分操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can do most of the list operations on tuples too</span></span><br><span class="line"><span class="built_in">len</span>(tup)         <span class="comment"># =&gt; 3</span></span><br><span class="line">tup + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  <span class="comment"># =&gt; (1, 2, 3, 4, 5, 6)</span></span><br><span class="line">tup[:<span class="number">2</span>]          <span class="comment"># =&gt; (1, 2)</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> tup         <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>我们可以用多个变量来解压一个tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can unpack tuples (or lists) into variables</span></span><br><span class="line">a, b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># a is now 1, b is now 2 and c is now 3</span></span><br><span class="line"><span class="comment"># You can also do extended unpacking</span></span><br><span class="line">a, *b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># a is now 1, b is now [2, 3] and c is now 4</span></span><br><span class="line"><span class="comment"># Tuples are created by default if you leave out the parentheses</span></span><br><span class="line">d, e, f = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>  <span class="comment"># tuple 4, 5, 6 is unpacked into variables d, e and f</span></span><br><span class="line"><span class="comment"># respectively such that d = 4, e = 5 and f = 6</span></span><br><span class="line"><span class="comment"># Now look how easy it is to swap two values</span></span><br><span class="line">e, d = d, e  <span class="comment"># d is now 5 and e is now 4</span></span><br></pre></td></tr></table></figure><p>解释一下这行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, *b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># a is now 1, b is now [2, 3] and c is now 4</span></span><br></pre></td></tr></table></figure><p>我们在b的前面加上了星号，<strong>表示这是一个list</strong>。所以Python会在将其他变量对应上值的情况下，将剩下的元素都赋值给b。</p><p>补充一点，tuple本身虽然是不可变的，但是<strong>tuple当中的可变元素是可以改变的</strong>。比如我们有这样一个tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">3</span>, [<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>我们虽然不能往a当中添加或者删除元素，但是a当中含有一个list，我们可以改变这个list类型的元素，这并不会触发tuple的异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>].append(<span class="number">0</span>) <span class="comment"># 这是合法的</span></span><br></pre></td></tr></table></figure><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>dict也是Python当中经常使用的容器，它等价于C++当中的map，即<strong>存储key和value的键值对</strong>。我们用{}表示一个dict，用:分隔key和value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionaries store mappings from keys to values</span></span><br><span class="line">empty_dict = &#123;&#125;</span><br><span class="line"><span class="comment"># Here is a prefilled dictionary</span></span><br><span class="line">filled_dict = &#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>dict的key必须为不可变对象，所以<strong>list、set和dict不可以作为另一个dict的key</strong>，否则会抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note keys for dictionaries have to be immutable types. This is to ensure that</span></span><br><span class="line"><span class="comment"># the key can be converted to a constant hash value for quick look-ups.</span></span><br><span class="line"><span class="comment"># Immutable types include ints, floats, strings, tuples.</span></span><br><span class="line">invalid_dict = &#123;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;123&quot;</span>&#125;  <span class="comment"># =&gt; Raises a TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line">valid_dict = &#123;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>):[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;   <span class="comment"># Values can be of any type, however.</span></span><br></pre></td></tr></table></figure><p>我们同样用[]查找dict当中的元素，我们传入key，获得value，等价于get方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Look up values with []</span></span><br><span class="line">filled_dict[<span class="string">&quot;one&quot;</span>]  <span class="comment"># =&gt; 1</span></span><br><span class="line">filled_dict.get(<span class="string">&#x27;one&#x27;</span>) <span class="comment">#=&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们可以call dict当中的keys和values方法，获取dict当中的所有key和value的集合，会得到一个list。在Python3.7以下版本当中，返回的结果的顺序可能和插入顺序不同，在Python3.7及以上版本中，Python会保证返回的顺序和插入顺序一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all keys as an iterable with &quot;keys()&quot;. We need to wrap the call in list()</span></span><br><span class="line"><span class="comment"># to turn it into a list. We&#x27;ll talk about those later.  Note - for Python</span></span><br><span class="line"><span class="comment"># versions &lt;3.7, dictionary key ordering is not guaranteed. Your results might</span></span><br><span class="line"><span class="comment"># not match the example below exactly. However, as of Python 3.7, dictionary</span></span><br><span class="line"><span class="comment"># items maintain the order at which they are inserted into the dictionary.</span></span><br><span class="line"><span class="built_in">list</span>(filled_dict.keys())  <span class="comment"># =&gt; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;] in Python &lt;3.7</span></span><br><span class="line"><span class="built_in">list</span>(filled_dict.keys())  <span class="comment"># =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] in Python 3.7+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all values as an iterable with &quot;values()&quot;. Once again we need to wrap it</span></span><br><span class="line"><span class="comment"># in list() to get it out of the iterable. Note - Same as above regarding key</span></span><br><span class="line"><span class="comment"># ordering.</span></span><br><span class="line"><span class="built_in">list</span>(filled_dict.values())  <span class="comment"># =&gt; [3, 2, 1]  in Python &lt;3.7</span></span><br><span class="line"><span class="built_in">list</span>(filled_dict.values())  <span class="comment"># =&gt; [1, 2, 3] in Python 3.7+</span></span><br></pre></td></tr></table></figure><p>我们也可以用in判断一个key是否在dict当中，注意只能判断key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check for existence of keys in a dictionary with &quot;in&quot;</span></span><br><span class="line"><span class="string">&quot;one&quot;</span> <span class="keyword">in</span> filled_dict  <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> filled_dict      <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure><p>如果使用[]查找不存在的key，会引发KeyError的异常。如果使用<strong>get方法则不会引起异常，只会得到一个None</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Looking up a non-existing key is a KeyError</span></span><br><span class="line">filled_dict[<span class="string">&quot;four&quot;</span>]  <span class="comment"># KeyError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use &quot;get()&quot; method to avoid the KeyError</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;one&quot;</span>)      <span class="comment"># =&gt; 1</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;four&quot;</span>)     <span class="comment"># =&gt; None</span></span><br><span class="line"><span class="comment"># The get method supports a default argument when the value is missing</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;one&quot;</span>, <span class="number">4</span>)   <span class="comment"># =&gt; 1</span></span><br><span class="line">filled_dict.get(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>)  <span class="comment"># =&gt; 4</span></span><br></pre></td></tr></table></figure><p>setdefault方法可以<strong>为不存在的key</strong>插入一个value，如果key已经存在，则不会覆盖它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;setdefault()&quot; inserts into a dictionary only if the given key isn&#x27;t present</span></span><br><span class="line">filled_dict.setdefault(<span class="string">&quot;five&quot;</span>, <span class="number">5</span>)  <span class="comment"># filled_dict[&quot;five&quot;] is set to 5</span></span><br><span class="line">filled_dict.setdefault(<span class="string">&quot;five&quot;</span>, <span class="number">6</span>)  <span class="comment"># filled_dict[&quot;five&quot;] is still 5</span></span><br></pre></td></tr></table></figure><p>我们可以使用update方法用另外一个dict来更新当前dict，比如a.update(b)。对于a和b交集的key会被b覆盖，a当中不存在的key会被插入进来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adding to a dictionary</span></span><br><span class="line">filled_dict.update(&#123;<span class="string">&quot;four&quot;</span>:<span class="number">4</span>&#125;)  <span class="comment"># =&gt; &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4&#125;</span></span><br><span class="line">filled_dict[<span class="string">&quot;four&quot;</span>] = <span class="number">4</span>         <span class="comment"># another way to add to dict</span></span><br></pre></td></tr></table></figure><p>我们一样可以使用del删除dict当中的元素，同样只能传入key。</p><p>Python3.5以上的版本支持使用**来解压一个dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, **&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;&#125;  <span class="comment"># =&gt; &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, **&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;&#125;  <span class="comment"># =&gt; &#123;&#x27;a&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set是用来存储<strong>不重复元素</strong>的容器，当中的元素都是不同的，相同的元素会被删除。我们可以通过set()，或者通过{}来进行初始化。注意当我们使用{}的时候，必须要传入数据，否则Python会将它和dict弄混。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sets store ... well sets</span></span><br><span class="line">empty_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># Initialize a set with a bunch of values. Yeah, it looks a bit like a dict. Sorry.</span></span><br><span class="line">some_set = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;  <span class="comment"># some_set is now &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>set当中的元素也必须是不可变对象，因此list不能传入set。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Similar to keys of a dictionary, elements of a set have to be immutable.</span></span><br><span class="line">invalid_set = &#123;[<span class="number">1</span>], <span class="number">1</span>&#125;  <span class="comment"># =&gt; Raises a TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line">valid_set = &#123;(<span class="number">1</span>,), <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>可以调用add方法为set插入元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add one more item to the set</span></span><br><span class="line">filled_set = some_set</span><br><span class="line">filled_set.add(<span class="number">5</span>)  <span class="comment"># filled_set is now &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># Sets do not have duplicate elements</span></span><br><span class="line">filled_set.add(<span class="number">5</span>)  <span class="comment"># it remains as before &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><p>set还可以被认为是集合，所以它还支持一些集合交叉并补的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do set intersection with &amp;</span></span><br><span class="line"><span class="comment"># 计算交集</span></span><br><span class="line">other_set = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">filled_set &amp; other_set  <span class="comment"># =&gt; &#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set union with |</span></span><br><span class="line"><span class="comment"># 计算并集</span></span><br><span class="line">filled_set | other_set  <span class="comment"># =&gt; &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set difference with -</span></span><br><span class="line"><span class="comment"># 计算差集</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; - &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;  <span class="comment"># =&gt; &#123;1, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do set symmetric difference with ^</span></span><br><span class="line"><span class="comment"># 这个有点特殊，计算对称集，也就是去掉重复元素剩下的内容</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ^ &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;  <span class="comment"># =&gt; &#123;1, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><p>set还支持<strong>超集和子集的判断</strong>，我们可以用大于等于和小于等于号判断一个set是不是另一个的超集或子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check if set on the left is a superset of set on the right</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125; &gt;= &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># =&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if set on the left is a subset of set on the right</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125; &lt;= &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>和dict一样，我们可以使用in判断元素在不在set当中。用copy可以拷贝一个set。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check for existence in a set with in</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> filled_set   <span class="comment"># =&gt; True</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">in</span> filled_set  <span class="comment"># =&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a one layer deep copy</span></span><br><span class="line">filled_set = some_set.copy()  <span class="comment"># filled_set is &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">filled_set <span class="keyword">is</span> some_set        <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure><h1 id="控制流和迭代"><a href="#控制流和迭代" class="headerlink" title="控制流和迭代"></a>控制流和迭代</h1><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>Python当中的判断语句非常简单，并且Python不支持switch，所以即使是多个条件，我们也只能<strong>罗列if-else</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let&#x27;s just make a variable</span></span><br><span class="line">some_var = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here is an if statement. Indentation is significant in Python!</span></span><br><span class="line"><span class="comment"># Convention is to use four spaces, not tabs.</span></span><br><span class="line"><span class="comment"># This prints &quot;some_var is smaller than 10&quot;</span></span><br><span class="line"><span class="keyword">if</span> some_var &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;some_var is totally bigger than 10.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> some_var &lt; <span class="number">10</span>:    <span class="comment"># This elif clause is optional.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;some_var is smaller than 10.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:                  <span class="comment"># This is optional too.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;some_var is indeed 10.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>我们可以用in来循环迭代一个list当中的内容，这也是Python当中基本的循环方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">For loops iterate over lists</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    dog is a mammal</span></span><br><span class="line"><span class="string">    cat is a mammal</span></span><br><span class="line"><span class="string">    mouse is a mammal</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;mouse&quot;</span>]:</span><br><span class="line">    <span class="comment"># You can use format() to interpolate formatted strings</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is a mammal&quot;</span>.<span class="built_in">format</span>(animal))</span><br></pre></td></tr></table></figure><p>如果我们要循环一个范围，可以使用range。range加上一个参数表示从0开始的序列，比如range(10)，表示[0, 10)区间内的所有整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;range(number)&quot; returns an iterable of numbers</span></span><br><span class="line"><span class="string">from zero to the given number</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>如果我们传入两个参数，则<strong>代表迭代区间的首尾</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;range(lower, upper)&quot; returns an iterable of numbers</span></span><br><span class="line"><span class="string">from the lower number to the upper number</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string">    7</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">8</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>如果我们传入第三个元素，表示每次<strong>循环变量自增的步长</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;range(lower, upper, step)&quot; returns an iterable of numbers</span></span><br><span class="line"><span class="string">from the lower number to the upper number, while incrementing</span></span><br><span class="line"><span class="string">by step. If step is not indicated, the default value is 1.</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>如果使用enumerate函数，可以<strong>同时迭代一个list的下标和元素</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">To loop over a list, and retrieve both the index and the value of each item in the list</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    0 dog</span></span><br><span class="line"><span class="string">    1 cat</span></span><br><span class="line"><span class="string">    2 mouse</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">animals = [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;mouse&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(i, value)</span><br></pre></td></tr></table></figure><p>while循环和C++类似，当条件为True时执行，为false时退出。并且判断条件不需要加上括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">While loops go until a condition is no longer met.</span></span><br><span class="line"><span class="string">prints:</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x += <span class="number">1</span>  <span class="comment"># Shorthand for x = x + 1</span></span><br></pre></td></tr></table></figure><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>Python当中使用<strong>try和except捕获异常</strong>，我们可以在except后面限制异常的类型。如果有多个类型可以写多个except，还可以使用else语句表示其他所有的类型。finally语句内的语法<strong>无论是否会触发异常都必定执行</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Handle exceptions with a try/except block</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Use &quot;raise&quot; to raise an error</span></span><br><span class="line">    <span class="keyword">raise</span> IndexError(<span class="string">&quot;This is an index error&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span>                 <span class="comment"># Pass is just a no-op. Usually you would do recovery here.</span></span><br><span class="line"><span class="keyword">except</span> (TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span>                 <span class="comment"># Multiple exceptions can be handled together, if required.</span></span><br><span class="line"><span class="keyword">else</span>:                    <span class="comment"># Optional clause to the try/except block. Must follow all except blocks</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All good!&quot;</span>)   <span class="comment"># Runs only if the code in try raises no exceptions</span></span><br><span class="line"><span class="keyword">finally</span>:                 <span class="comment">#  Execute under all circumstances</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We can clean up resources here&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="with操作"><a href="#with操作" class="headerlink" title="with操作"></a>with操作</h2><p>在Python当中我们经常会使用资源，最常见的就是open打开一个文件。我们<strong>打开了文件句柄就一定要关闭</strong>，但是如果我们手动来编码，经常会忘记执行close操作。并且如果文件异常，还会触发异常。这个时候我们可以使用with语句来代替这部分处理，使用with会<strong>自动在with块执行结束或者是触发异常时关闭打开的资源</strong>。</p><p>以下是with的几种用法和功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instead of try/finally to cleanup resources you can use a with statement</span></span><br><span class="line"><span class="comment"># 代替使用try/finally语句来关闭资源</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing to a file</span></span><br><span class="line"><span class="comment"># 使用with写入文件</span></span><br><span class="line">contents = &#123;<span class="string">&quot;aa&quot;</span>: <span class="number">12</span>, <span class="string">&quot;bb&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile1.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="built_in">str</span>(contents))        <span class="comment"># writes a string to a file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile2.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(json.dumps(contents)) <span class="comment"># writes an object to a file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading from a file</span></span><br><span class="line"><span class="comment"># 使用with读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile1.txt&#x27;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    contents = file.read()           <span class="comment"># reads a string from a file</span></span><br><span class="line"><span class="built_in">print</span>(contents)</span><br><span class="line"><span class="comment"># print: &#123;&quot;aa&quot;: 12, &quot;bb&quot;: 21&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile2.txt&#x27;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    contents = json.load(file)       <span class="comment"># reads a json object from a file</span></span><br><span class="line"><span class="built_in">print</span>(contents)     </span><br><span class="line"><span class="comment"># print: &#123;&quot;aa&quot;: 12, &quot;bb&quot;: 21&#125;</span></span><br></pre></td></tr></table></figure><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>凡是可以使用in语句来迭代的对象都叫做<strong>可迭代对象</strong>，它和迭代器不是一个含义。这里只有可迭代对象的介绍，想要了解迭代器的具体内容，请移步传送门：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247489056&amp;idx=1&amp;sn=b59ad4846c20b4203a3b653c0070257e&amp;source=41#wechat_redirect">Python——五分钟带你弄懂迭代器与生成器，夯实代码能力</a></p><p>当我们调用dict当中的keys方法的时候，返回的结果就是一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python offers a fundamental abstraction called the Iterable.</span></span><br><span class="line"><span class="comment"># An iterable is an object that can be treated as a sequence.</span></span><br><span class="line"><span class="comment"># The object returned by the range function, is an iterable.</span></span><br><span class="line"></span><br><span class="line">filled_dict = &#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">our_iterable = filled_dict.keys()</span><br><span class="line"><span class="built_in">print</span>(our_iterable)  <span class="comment"># =&gt; dict_keys([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]). This is an object that implements our Iterable interface.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can loop over it.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> our_iterable:</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># Prints one, two, three</span></span><br></pre></td></tr></table></figure><p>我们<strong>不能使用下标来访问</strong>可迭代对象，但我们可以用iter将它转化成迭代器，使用next关键字来获取下一个元素。也可以将它转化成list类型，变成一个list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># However we cannot address elements by index.</span></span><br><span class="line">our_iterable[<span class="number">1</span>]  <span class="comment"># Raises a TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># An iterable is an object that knows how to create an iterator.</span></span><br><span class="line">our_iterator = <span class="built_in">iter</span>(our_iterable)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Our iterator is an object that can remember the state as we traverse through it.</span></span><br><span class="line"><span class="comment"># We get the next object with &quot;next()&quot;.</span></span><br><span class="line"><span class="built_in">next</span>(our_iterator)  <span class="comment"># =&gt; &quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It maintains state as we iterate.</span></span><br><span class="line"><span class="built_in">next</span>(our_iterator)  <span class="comment"># =&gt; &quot;two&quot;</span></span><br><span class="line"><span class="built_in">next</span>(our_iterator)  <span class="comment"># =&gt; &quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After the iterator has returned all of its data, it raises a StopIteration exception</span></span><br><span class="line"><span class="built_in">next</span>(our_iterator)  <span class="comment"># Raises StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can also loop over it, in fact, &quot;for&quot; does this implicitly!</span></span><br><span class="line">our_iterator = <span class="built_in">iter</span>(our_iterable)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> our_iterator:</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># Prints one, two, three</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can grab all the elements of an iterable or iterator by calling list() on it.</span></span><br><span class="line"><span class="built_in">list</span>(our_iterable)  <span class="comment"># =&gt; Returns [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"><span class="built_in">list</span>(our_iterator)  <span class="comment"># =&gt; Returns [] because state is saved</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用def关键字来定义函数，我们在传参的时候如果指定函数内的参数名，<strong>可以不按照函数定义的顺序</strong>传参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use &quot;def&quot; to create new functions</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is &#123;&#125; and y is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(x, y))</span><br><span class="line">    <span class="keyword">return</span> x + y  <span class="comment"># Return values with a return statement</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling functions with parameters</span></span><br><span class="line">add(<span class="number">5</span>, <span class="number">6</span>)  <span class="comment"># =&gt; prints out &quot;x is 5 and y is 6&quot; and returns 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another way to call functions is with keyword arguments</span></span><br><span class="line">add(y=<span class="number">6</span>, x=<span class="number">5</span>)  <span class="comment"># Keyword arguments can arrive in any order.</span></span><br></pre></td></tr></table></figure><p>可以在参数名之前加上*表示任意长度的参数，参数会被转化成list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can define functions that take a variable number of</span></span><br><span class="line"><span class="comment"># positional arguments</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">varargs</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line">varargs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># =&gt; (1, 2, 3)</span></span><br></pre></td></tr></table></figure><p>也可以指定任意长度的关键字参数，在参数前加上**表示接受一个dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can define functions that take a variable number of</span></span><br><span class="line"><span class="comment"># keyword arguments, as well</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword_args</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s call it to see what happens</span></span><br><span class="line">keyword_args(big=<span class="string">&quot;foot&quot;</span>, loch=<span class="string">&quot;ness&quot;</span>)  <span class="comment"># =&gt; &#123;&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>当然我们也可以两个都用上，这样可以接受任何参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can do both at once, if you like</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_the_args</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">all_the_args(1, 2, a=3, b=4) prints:</span></span><br><span class="line"><span class="string">    (1, 2)</span></span><br><span class="line"><span class="string">    &#123;&quot;a&quot;: 3, &quot;b&quot;: 4&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>传入参数的时候我们也可以使用*和**来解压list或者是dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When calling functions, you can do the opposite of args/kwargs!</span></span><br><span class="line"><span class="comment"># Use * to expand tuples and use ** to expand kwargs.</span></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">3</span>, <span class="string">&quot;b&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">all_the_args(*args)            <span class="comment"># equivalent to all_the_args(1, 2, 3, 4)</span></span><br><span class="line">all_the_args(**kwargs)         <span class="comment"># equivalent to all_the_args(a=3, b=4)</span></span><br><span class="line">all_the_args(*args, **kwargs)  <span class="comment"># equivalent to all_the_args(1, 2, 3, 4, a=3, b=4)</span></span><br></pre></td></tr></table></figure><p>Python中的参数<strong>可以返回多个值</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Returning multiple values (with tuple assignments)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> y, x  <span class="comment"># Return multiple values as a tuple without the parenthesis.</span></span><br><span class="line">                 <span class="comment"># (Note: parenthesis have been excluded but can be included)</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">x, y = swap(x, y)     <span class="comment"># =&gt; x = 2, y = 1</span></span><br><span class="line"><span class="comment"># (x, y) = swap(x,y)  # Again parenthesis have been excluded but can be included.</span></span><br></pre></td></tr></table></figure><p>函数内部定义的变量即使和全局变量重名，也<strong>不会覆盖全局变量的值</strong>。想要在函数内部使用全局变量，需要加上<strong>global</strong>关键字，表示这是一个全局变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function Scope</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_x</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="comment"># Local var x not the same as global variable x</span></span><br><span class="line">    x = num    <span class="comment"># =&gt; 43</span></span><br><span class="line">    <span class="built_in">print</span>(x)   <span class="comment"># =&gt; 43</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_global_x</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    <span class="built_in">print</span>(x)   <span class="comment"># =&gt; 5</span></span><br><span class="line">    x = num    <span class="comment"># global var x is now set to 6</span></span><br><span class="line">    <span class="built_in">print</span>(x)   <span class="comment"># =&gt; 6</span></span><br><span class="line"></span><br><span class="line">set_x(<span class="number">43</span>)</span><br><span class="line">set_global_x(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>Python支持<strong>函数式编程</strong>，我们可以在一个函数内部返回一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python has first class functions</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> adder</span><br><span class="line"></span><br><span class="line">add_10 = create_adder(<span class="number">10</span>)</span><br><span class="line">add_10(<span class="number">3</span>)   <span class="comment"># =&gt; 13</span></span><br></pre></td></tr></table></figure><p>Python中可以使用lambda表示<strong>匿名函数</strong>，使用:作为分隔，:前面表示匿名函数的参数，:后面的是函数的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># There are also anonymous functions</span></span><br><span class="line">(<span class="keyword">lambda</span> x: x &gt; <span class="number">2</span>)(<span class="number">3</span>)                  <span class="comment"># =&gt; True</span></span><br><span class="line">(<span class="keyword">lambda</span> x, y: x ** <span class="number">2</span> + y ** <span class="number">2</span>)(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># =&gt; 5</span></span><br></pre></td></tr></table></figure><p>我们还可以将函数作为参数使用map和filter，实现元素的批量处理和过滤。关于Python中map、reduce和filter的使用，具体可以查看之前的文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247489063&amp;idx=1&amp;sn=c054922754f47dd017753acd79cbeb31&amp;source=41#wechat_redirect">五分钟带你了解map、reduce和filter</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># There are built-in higher order functions</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(add_10, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))          <span class="comment"># =&gt; [11, 12, 13]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">max</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]))  <span class="comment"># =&gt; [4, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))  <span class="comment"># =&gt; [6, 7]</span></span><br></pre></td></tr></table></figure><p>我们还可以结合循环和判断语来给list或者是dict进行初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We can use list comprehensions for nice maps and filters</span></span><br><span class="line"><span class="comment"># List comprehension stores the output as a list which can itself be a nested list</span></span><br><span class="line">[add_10(i) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]         <span class="comment"># =&gt; [11, 12, 13]</span></span><br><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="keyword">if</span> x &gt; <span class="number">5</span>]  <span class="comment"># =&gt; [6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can construct set and dict comprehensions as well.</span></span><br><span class="line">&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abcddeef&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;  <span class="comment"># =&gt; &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;</span></span><br><span class="line">&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;  <span class="comment"># =&gt; &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;</span></span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>使用<strong>import语句引入一个Python模块</strong>，我们可以用.来访问模块中的函数或者是类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can import modules</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">16</span>))  <span class="comment"># =&gt; 4.0</span></span><br></pre></td></tr></table></figure><p>我们也可以使用from import的语句，单独引入模块内的函数或者是类，而不再需要写出完整路径。使用from import *可以引入模块内所有内容（不推荐这么干）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can get specific functions from a module</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil, floor</span><br><span class="line"><span class="built_in">print</span>(ceil(<span class="number">3.7</span>))   <span class="comment"># =&gt; 4.0</span></span><br><span class="line"><span class="built_in">print</span>(floor(<span class="number">3.7</span>))  <span class="comment"># =&gt; 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can import all functions from a module.</span></span><br><span class="line"><span class="comment"># Warning: this is not recommended</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>可以使用as给模块内的方法或者类起别名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can shorten module names</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line">math.sqrt(<span class="number">16</span>) == m.sqrt(<span class="number">16</span>)  <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure><p>我们可以使用dir查看我们用的模块的路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can find out which functions and attributes</span></span><br><span class="line"><span class="comment"># are defined in a module.</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">dir</span>(math)</span><br></pre></td></tr></table></figure><p>这么做的原因是如果我们当前的路径下也有一个叫做math的Python文件，那么<strong>会覆盖系统自带的math的模块</strong>。这是尤其需要注意的，不小心会导致很多奇怪的bug。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>我们来看一个完整的类，相关的介绍都在注释当中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We use the &quot;class&quot; statement to create a class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A class attribute. It is shared by all instances of this class</span></span><br><span class="line">    <span class="comment"># 类属性，可以直接通过Human.species调用，而不需要通过实例</span></span><br><span class="line">    species = <span class="string">&quot;H. sapiens&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Basic initializer, this is called when this class is instantiated.</span></span><br><span class="line">    <span class="comment"># Note that the double leading and trailing underscores denote objects</span></span><br><span class="line">    <span class="comment"># or attributes that are used by Python but that live in user-controlled</span></span><br><span class="line">    <span class="comment"># namespaces. Methods(or objects or attributes) like: __init__, __str__,</span></span><br><span class="line">    <span class="comment"># __repr__ etc. are called special methods (or sometimes called dunder methods)</span></span><br><span class="line">    <span class="comment"># You should not invent such names on your own.</span></span><br><span class="line">    <span class="comment"># 最基础的构造函数</span></span><br><span class="line">    <span class="comment"># 加了下划线的函数和变量表示不应该被用户使用，其中双下划线的函数或者是变量将不会被子类覆盖</span></span><br><span class="line">    <span class="comment"># 前后都有双下划线的函数和属性是类当中的特殊属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># Assign the argument to the instance&#x27;s name attribute</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize property</span></span><br><span class="line">        self._age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># An instance method. All methods take &quot;self&quot; as the first argument</span></span><br><span class="line">    <span class="comment"># 类中的函数，所有实例可以调用，第一个参数必须是self</span></span><br><span class="line">    <span class="comment"># self表示实例的引用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125;: &#123;message&#125;&quot;</span>.<span class="built_in">format</span>(name=self.name, message=msg))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Another instance method</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;yo... yo... microphone check... one two... one two...&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A class method is shared among all instances</span></span><br><span class="line">    <span class="comment"># They are called with the calling class as the first argument</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="comment"># 加上了注解，表示是类函数</span></span><br><span class="line">    <span class="comment"># 通过Human.get_species来调用，所有实例共享</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_species</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.species</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A static method is called without a class or instance reference</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="comment"># 静态函数，通过类名或者是实例都可以调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grunt</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*grunt*&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A property is just like a getter.</span></span><br><span class="line">    <span class="comment"># It turns the method age() into an read-only attribute of the same name.</span></span><br><span class="line">    <span class="comment"># There&#x27;s no need to write trivial getters and setters in Python, though.</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="comment"># property注解，类似于get，set方法</span></span><br><span class="line">    <span class="comment"># 效率很低，除非必要，不要使用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This allows the property to be set</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, age</span>):</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This allows the property to be deleted</span></span><br><span class="line"><span class="meta">    @age.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._age</span><br></pre></td></tr></table></figure><p>以上内容的详细介绍之前也有过相关文章，可以查看：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247489098&amp;idx=1&amp;sn=218b3307260c214939f8f4d236f68595&amp;source=41#wechat_redirect">Python——<strong>slots</strong>，property和对象命名规范</a></p><p>下面我们来看看Python当中类的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When a Python interpreter reads a source file it executes all its code.</span></span><br><span class="line"><span class="comment"># This __name__ check makes sure this code block is only executed when this</span></span><br><span class="line"><span class="comment"># module is the main program.</span></span><br><span class="line"><span class="comment"># 这个是main函数也是整个程序入口的惯用写法</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Instantiate a class</span></span><br><span class="line">    <span class="comment"># 实例化一个类，获取类的对象</span></span><br><span class="line">    i = Human(name=<span class="string">&quot;Ian&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行say方法</span></span><br><span class="line">    i.say(<span class="string">&quot;hi&quot;</span>)                     <span class="comment"># &quot;Ian: hi&quot;</span></span><br><span class="line">    j = Human(<span class="string">&quot;Joel&quot;</span>)</span><br><span class="line">    j.say(<span class="string">&quot;hello&quot;</span>)                  <span class="comment"># &quot;Joel: hello&quot;</span></span><br><span class="line">    <span class="comment"># i和j都是Human的实例，都称作是Human类的对象</span></span><br><span class="line">    <span class="comment"># i and j are instances of type Human, or in other words: they are Human objects</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call our class method</span></span><br><span class="line">    <span class="comment"># 类属性被所有实例共享，一旦修改全部生效</span></span><br><span class="line">    i.say(i.get_species())          <span class="comment"># &quot;Ian: H. sapiens&quot;</span></span><br><span class="line">    <span class="comment"># Change the shared attribute</span></span><br><span class="line">    Human.species = <span class="string">&quot;H. neanderthalensis&quot;</span></span><br><span class="line">    i.say(i.get_species())          <span class="comment"># =&gt; &quot;Ian: H. neanderthalensis&quot;</span></span><br><span class="line">    j.say(j.get_species())          <span class="comment"># =&gt; &quot;Joel: H. neanderthalensis&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过类名调用静态方法</span></span><br><span class="line">    <span class="comment"># Call the static method</span></span><br><span class="line">    <span class="built_in">print</span>(Human.grunt())            <span class="comment"># =&gt; &quot;*grunt*&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cannot call static method with instance of object </span></span><br><span class="line">    <span class="comment"># because i.grunt() will automatically put &quot;self&quot; (the object i) as an argument</span></span><br><span class="line">    <span class="comment"># 不能通过对象调用静态方法，因为对象会传入self实例，会导致不匹配</span></span><br><span class="line">    <span class="built_in">print</span>(i.grunt())                <span class="comment"># =&gt; TypeError: grunt() takes 0 positional arguments but 1 was given</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the property for this instance</span></span><br><span class="line">    <span class="comment"># 实例级别的属性是独立的，各个对象各自拥有，修改不会影响其他对象内的值</span></span><br><span class="line">    i.age = <span class="number">42</span></span><br><span class="line">    <span class="comment"># Get the property</span></span><br><span class="line">    i.say(i.age)                    <span class="comment"># =&gt; &quot;Ian: 42&quot;</span></span><br><span class="line">    j.say(j.age)                    <span class="comment"># =&gt; &quot;Joel: 0&quot;</span></span><br><span class="line">    <span class="comment"># Delete the property</span></span><br><span class="line">    <span class="keyword">del</span> i.age</span><br><span class="line">    <span class="comment"># i.age                         # =&gt; this would raise an AttributeError</span></span><br></pre></td></tr></table></figure><p>这里解释一下，实例和对象可以理解成一个概念，实例的英文是instance，对象的英文是object。都是指类经过实例化之后得到的对象。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以让子类<strong>继承父类的变量以及方法</strong>，并且我们还可以在子类当中指定一些属于自己的特性，并且还可以重写父类的一些方法。一般我们会将不同的类放在不同的文件当中，使用import引入，一样可以实现继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> human <span class="keyword">import</span> Human</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the parent class(es) as parameters to the class definition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superhero</span>(<span class="title class_ inherited__">Human</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the child class should inherit all of the parent&#x27;s definitions without</span></span><br><span class="line">    <span class="comment"># any modifications, you can just use the &quot;pass&quot; keyword (and nothing else)</span></span><br><span class="line">    <span class="comment"># but in this case it is commented out to allow for a unique child class:</span></span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    <span class="comment"># 如果要完全继承父类的所有的实现，我们可以使用关键字pass，表示跳过。这样不会修改父类当中的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Child classes can override their parents&#x27; attributes</span></span><br><span class="line">    species = <span class="string">&#x27;Superhuman&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Children automatically inherit their parent class&#x27;s constructor including</span></span><br><span class="line">    <span class="comment"># its arguments, but can also define additional arguments or definitions</span></span><br><span class="line">    <span class="comment"># and override its methods such as the class constructor.</span></span><br><span class="line">    <span class="comment"># This constructor inherits the &quot;name&quot; argument from the &quot;Human&quot; class and</span></span><br><span class="line">    <span class="comment"># adds the &quot;superpower&quot; and &quot;movie&quot; arguments:</span></span><br><span class="line">    <span class="comment"># 子类会完全继承父类的构造方法，我们也可以进行改造，比如额外增加一些参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, movie=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 superpowers=[<span class="string">&quot;super strength&quot;</span>, <span class="string">&quot;bulletproofing&quot;</span>]</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add additional class attributes:</span></span><br><span class="line">        <span class="comment"># 额外新增的参数</span></span><br><span class="line">        self.fictional = <span class="literal">True</span></span><br><span class="line">        self.movie = movie</span><br><span class="line">        <span class="comment"># be aware of mutable default values, since defaults are shared</span></span><br><span class="line">        self.superpowers = superpowers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The &quot;super&quot; function lets you access the parent class&#x27;s methods</span></span><br><span class="line">        <span class="comment"># that are overridden by the child, in this case, the __init__ method.</span></span><br><span class="line">        <span class="comment"># This calls the parent class constructor:</span></span><br><span class="line">        <span class="comment"># 子类可以通过super关键字调用父类的方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># override the sing method</span></span><br><span class="line">    <span class="comment"># 重写父类的sing方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Dun, dun, DUN!&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># add an additional instance method</span></span><br><span class="line">    <span class="comment"># 新增方法，只属于子类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">boast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> power <span class="keyword">in</span> self.superpowers:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I wield the power of &#123;pow&#125;!&quot;</span>.<span class="built_in">format</span>(<span class="built_in">pow</span>=power))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sup = Superhero(name=<span class="string">&quot;Tick&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance type checks</span></span><br><span class="line">    <span class="comment"># 检查继承关系</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(sup, Human):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am human&#x27;</span>)</span><br><span class="line">    <span class="comment"># 检查类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(sup) <span class="keyword">is</span> Superhero:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am a superhero&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the Method Resolution search Order used by both getattr() and super()</span></span><br><span class="line">    <span class="comment"># This attribute is dynamic and can be updated</span></span><br><span class="line">    <span class="comment"># 查看方法查询的顺序</span></span><br><span class="line">    <span class="comment"># 先是自身，然后沿着继承顺序往上，最后到object</span></span><br><span class="line">    <span class="built_in">print</span>(Superhero.__mro__)    <span class="comment"># =&gt; (&lt;class &#x27;__main__.Superhero&#x27;&gt;,</span></span><br><span class="line">                                <span class="comment"># =&gt; &lt;class &#x27;human.Human&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相同的属性子类覆盖了父类</span></span><br><span class="line">    <span class="comment"># Calls parent method but uses its own class attribute</span></span><br><span class="line">    <span class="built_in">print</span>(sup.get_species())    <span class="comment"># =&gt; Superhuman</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls overridden method</span></span><br><span class="line">    <span class="comment"># 相同的方法也覆盖了父类</span></span><br><span class="line">    <span class="built_in">print</span>(sup.sing())           <span class="comment"># =&gt; Dun, dun, DUN!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls method from Human</span></span><br><span class="line">    <span class="comment"># 继承了父类的方法</span></span><br><span class="line">    sup.say(<span class="string">&#x27;Spoon&#x27;</span>)            <span class="comment"># =&gt; Tick: Spoon</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call method that exists only in Superhero</span></span><br><span class="line">    <span class="comment"># 子类特有的方法</span></span><br><span class="line">    sup.boast()                 <span class="comment"># =&gt; I wield the power of super strength!</span></span><br><span class="line">                                <span class="comment"># =&gt; I wield the power of bulletproofing!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Inherited class attribute</span></span><br><span class="line">    sup.age = <span class="number">31</span></span><br><span class="line">    <span class="built_in">print</span>(sup.age)              <span class="comment"># =&gt; 31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attribute that only exists within Superhero</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Am I Oscar eligible? &#x27;</span> + <span class="built_in">str</span>(sup.movie))</span><br></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>我们创建一个蝙蝠类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Another class definition</span></span><br><span class="line"><span class="comment"># bat.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span>:</span><br><span class="line"></span><br><span class="line">    species = <span class="string">&#x27;Baty&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, can_fly=<span class="literal">True</span></span>):</span><br><span class="line">        self.fly = can_fly</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This class also has a say method</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, msg</span>):</span><br><span class="line">        msg = <span class="string">&#x27;... ... ...&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="comment"># And its own method as well</span></span><br><span class="line">    <span class="comment"># 蝙蝠独有的声呐方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sonar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;))) ... (((&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    b = Bat()</span><br><span class="line">    <span class="built_in">print</span>(b.say(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(b.fly)</span><br></pre></td></tr></table></figure><p>我们再创建一个蝙蝠侠的类，同时继承Superhero和Bat：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># And yet another class definition that inherits from Superhero and Bat</span></span><br><span class="line"><span class="comment"># superhero.py</span></span><br><span class="line"><span class="keyword">from</span> superhero <span class="keyword">import</span> Superhero</span><br><span class="line"><span class="keyword">from</span> bat <span class="keyword">import</span> Bat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define Batman as a child that inherits from both Superhero and Bat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Batman</span>(Superhero, Bat):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># Typically to inherit attributes you have to call super:</span></span><br><span class="line">        <span class="comment"># super(Batman, self).__init__(*args, **kwargs)      </span></span><br><span class="line">        <span class="comment"># However we are dealing with multiple inheritance here, and super()</span></span><br><span class="line">        <span class="comment"># only works with the next base class in the MRO list.</span></span><br><span class="line">        <span class="comment"># So instead we explicitly call __init__ for all ancestors.</span></span><br><span class="line">        <span class="comment"># The use of *args and **kwargs allows for a clean way to pass arguments,</span></span><br><span class="line">        <span class="comment"># with each parent &quot;peeling a layer of the onion&quot;.</span></span><br><span class="line">        <span class="comment"># 通过类名调用两个父类各自的构造方法</span></span><br><span class="line">        Superhero.__init__(self, <span class="string">&#x27;anonymous&#x27;</span>, movie=<span class="literal">True</span>, </span><br><span class="line">                           superpowers=[<span class="string">&#x27;Wealthy&#x27;</span>], *args, **kwargs)</span><br><span class="line">        Bat.__init__(self, *args, can_fly=<span class="literal">False</span>, **kwargs)</span><br><span class="line">        <span class="comment"># override the value for the name attribute</span></span><br><span class="line">        self.name = <span class="string">&#x27;Sad Affleck&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写父类的sing方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nan nan nan nan nan batman!&#x27;</span></span><br></pre></td></tr></table></figure><p>执行这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sup = Batman()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the Method Resolution search Order used by both getattr() and super().</span></span><br><span class="line">    <span class="comment"># This attribute is dynamic and can be updated</span></span><br><span class="line">    <span class="comment"># 可以看到方法查询的顺序是先沿着superhero这条线到human，然后才是bat</span></span><br><span class="line">    <span class="built_in">print</span>(Batman.__mro__)       <span class="comment"># =&gt; (&lt;class &#x27;__main__.Batman&#x27;&gt;, </span></span><br><span class="line">                                <span class="comment"># =&gt; &lt;class &#x27;superhero.Superhero&#x27;&gt;, </span></span><br><span class="line">                                <span class="comment"># =&gt; &lt;class &#x27;human.Human&#x27;&gt;, </span></span><br><span class="line">                                <span class="comment"># =&gt; &lt;class &#x27;bat.Bat&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls parent method but uses its own class attribute</span></span><br><span class="line">    <span class="comment"># 只有superhero有get_species方法</span></span><br><span class="line">    <span class="built_in">print</span>(sup.get_species())    <span class="comment"># =&gt; Superhuman</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls overridden method</span></span><br><span class="line">    <span class="built_in">print</span>(sup.sing())           <span class="comment"># =&gt; nan nan nan nan nan batman!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls method from Human, because inheritance order matters</span></span><br><span class="line">    sup.say(<span class="string">&#x27;I agree&#x27;</span>)          <span class="comment"># =&gt; Sad Affleck: I agree</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call method that exists only in 2nd ancestor</span></span><br><span class="line">    <span class="comment"># 调用蝙蝠类的声呐方法</span></span><br><span class="line">    <span class="built_in">print</span>(sup.sonar())          <span class="comment"># =&gt; ))) ... (((</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Inherited class attribute</span></span><br><span class="line">    sup.age = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(sup.age)              <span class="comment"># =&gt; 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Inherited attribute from 2nd ancestor whose default value was overridden.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Can I fly? &#x27;</span> + <span class="built_in">str</span>(sup.fly)) <span class="comment"># =&gt; Can I fly? False</span></span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>我们可以通过yield关键字创建一个生成器，每次我们调用的时候执行到yield关键字处则停止。下次再次调用则还是从yield处开始往下执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generators help you make lazy code.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">double_numbers</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> i + i</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generators are memory-efficient because they only load the data needed to</span></span><br><span class="line"><span class="comment"># process the next value in the iterable. This allows them to perform</span></span><br><span class="line"><span class="comment"># operations on otherwise prohibitively large value ranges.</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> `range` replaces `xrange` in Python 3.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> double_numbers(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">900000000</span>)):  <span class="comment"># `range` is a generator.</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">30</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>除了yield之外，我们还可以使用()小括号来生成一个生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Just as you can create a list comprehension, you can create generator</span></span><br><span class="line"><span class="comment"># comprehensions as well.</span></span><br><span class="line">values = (-x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> values:</span><br><span class="line">    <span class="built_in">print</span>(x)  <span class="comment"># prints -1 -2 -3 -4 -5 to console/terminal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can also cast a generator comprehension directly to a list.</span></span><br><span class="line">values = (-x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">gen_to_list = <span class="built_in">list</span>(values)</span><br><span class="line"><span class="built_in">print</span>(gen_to_list)  <span class="comment"># =&gt; [-1, -2, -3, -4, -5]</span></span><br></pre></td></tr></table></figure><p>关于生成器和迭代器更多的内容，可以查看下面这篇文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247489056&amp;idx=1&amp;sn=b59ad4846c20b4203a3b653c0070257e&amp;source=41#wechat_redirect">五分钟带你弄懂迭代器与生成器，夯实代码能力</a></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>我们引入functools当中的wraps之后，可以创建一个装饰器。装饰器可以在不修改函数内部代码的前提下，在外面包装一层其他的逻辑:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decorators</span></span><br><span class="line"><span class="comment"># In this example `beg` wraps `say`. If say_please is True then it</span></span><br><span class="line"><span class="comment"># will change the returned message.</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">beg</span>(<span class="params">target_function</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">target_function</span>)</span></span><br><span class="line">    <span class="comment"># 如果please为True，额外输出一句Please! I am poor :(</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        msg, say_please = target_function(*args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> say_please:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(msg, <span class="string">&quot;Please! I am poor :(&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@beg</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">say_please=<span class="literal">False</span></span>):</span><br><span class="line">    msg = <span class="string">&quot;Can you buy me a beer?&quot;</span></span><br><span class="line">    <span class="keyword">return</span> msg, say_please</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(say())                 <span class="comment"># Can you buy me a beer?</span></span><br><span class="line"><span class="built_in">print</span>(say(say_please=<span class="literal">True</span>))  <span class="comment"># Can you buy me a beer? Please! I am poor :(</span></span><br></pre></td></tr></table></figure><p>装饰器之前也有专门的文章详细介绍，可以移步下面的传送门：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYyMDgyNg==&amp;mid=2247489105&amp;idx=1&amp;sn=277162de129f65f8d1b38dea1cc8c03a&amp;source=41#wechat_redirect">一文搞定Python装饰器，看完面试不再慌</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2023/03/02/hello-world/"/>
      <url>/2023/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ai领航员，超详细的算法工程师入门教程。从零开始入门学算法，入门人工智能行业，做一名优秀的算法工程师。本专栏持续更新。</p><p>真正做到通俗易懂，没有基础也能看，真正从零开始。</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><ul><li>官网地址：<a href="https://moutsea.github.io/">https://moutsea.github.io/</a></li></ul><p>​    如果出现无法打开的情况，请尝试刷新浏览器，或者清楚浏览器缓存。</p><ul><li>GitHub地址：<a href="https://github.com/moutsea/ai_tutorial">https://github.com/moutsea/ai_tutorial</a></li></ul><p>如果你发现本项目有内容上的错误，欢迎在 GitHub 提交 issues 或者 pull requests 进行指正，或者在博客下方给我留言。</p><h3 id="项目特点"><a href="#项目特点" class="headerlink" title="项目特点"></a>项目特点</h3><ul><li>市面上大多数入门教程针对的对象都是硕士生，不太适合萌新小白。而且算法领域相关知识点比较分散，很少有专栏将所有知识点串联起来。因此本教程从最浅显的知识点出发，甚至你完全不会编程，只要你坚持下来，一样完成入门</li><li>帮助算法学习者少走弯路，提高学习效率</li><li>可以当做面试指南或者是学习笔记</li><li>本专栏完全免费，用爱发电</li></ul><h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p>老梁：ACM-ICPC亚洲区银奖，本科毕业，自学机器学习转行做算法。BAT大厂经历，6年从业经验，目前在某外企担任广告算法专家。微信公众号Coder号主，持续3年更新超过1000篇技术文</p><p>Lingo：新加坡国立大学人工智能博士后在读，主要研究人工智能（AI）领域的计算机视觉（CV）、自然语言处理（NLP）以及多模态（MM）方向的技术。在顶级学术会议上发表过多篇学术论文，也担任顶会顶刊的审稿人。在读博期间获得过多项学术竞赛的冠亚军，并取得过深圳市政府举办的第一届全国人工智能亚军，夺取50万元竞赛奖金。秋招阶段从求职大军中脱颖而出并斩获多个百万年薪大厂offer。</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230303221923211.png" alt=""></p><h2 id="知识星球"><a href="#知识星球" class="headerlink" title="知识星球"></a>知识星球</h2><p>零距离知识社群、知识分享、专栏文章、答疑解惑、简历润色、项目分享</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/image-20230303212729395.png" style="zoom:33%;" /></p><h2 id="赞赏作者"><a href="#赞赏作者" class="headerlink" title="赞赏作者"></a>赞赏作者</h2><p>创作不易，你的赞赏和认可，是我最大的更新动力：</p><p><img src="https://moutsea-blog.oss-cn-hangzhou.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
